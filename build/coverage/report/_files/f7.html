<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="13.html">org.mozilla.javascript.regexp</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">RegExpImpl.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>RegExpImpl.java</TD><TD>100% (2/2)</TD><TD>100% (15/15)</TD><TD>86%  (1247/1453)</TD><TD>83%  (270.8/325)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">RegExpImpl</A></TD><TD>100% (1/1)</TD><TD>100% (14/14)</TD><TD>86%  (1241/1447)</TD><TD>83%  (268.8/323)</TD></TR><TR><TD CLASS="f"><A HREF="#1">interpretDollar (Context, RegExpImpl, String, int, int []): SubString</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">49%  (93/188)</TD><TD CLASS="h">45%  (21.1/47)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">find_split (Context, Scriptable, String, String, int, RegExpProxy, Scriptable...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">57%  (85/149)</TD><TD CLASS="h">48%  (16/33)</TD></TR><TR><TD CLASS="f"><A HREF="#3">matchOrReplace (Context, Scriptable, Scriptable, Object [], RegExpImpl, GlobD...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (208/229)</TD><TD>90%  (38.7/43)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">find_split (Context, Scriptable, String, String, Scriptable, int [], int [], ...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (128/135)</TD><TD>94%  (33/35)</TD></TR><TR><TD CLASS="f"><A HREF="#5">replace_glob (GlobData, Context, Scriptable, RegExpImpl, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (210/218)</TD><TD>98%  (45.9/47)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">js_split (Context, Scriptable, String, Object []): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>97%  (223/230)</TD><TD>95%  (47.3/50)</TD></TR><TR><TD CLASS="f"><A HREF="#7">action (Context, Scriptable, Scriptable, Object [], int): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>97%  (143/147)</TD><TD>96%  (28.9/30)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">RegExpImpl (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#9">compileRegExp (Context, String, String): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">do_replace (GlobData, Context, RegExpImpl): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (90/90)</TD><TD>100% (23/23)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getParenSubString (int): SubString</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (5/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">isRegExp (Scriptable): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#d">match_glob (GlobData, Context, Scriptable, int, RegExpImpl): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (23/23)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">wrapRegExp (Context, Scriptable, Object): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#f">GlobData</A></TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#f">GlobData (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</TD></TR><TR><TD CLASS="l">2</TD><TD> *</TD></TR><TR><TD CLASS="l">3</TD><TD> * This Source Code Form is subject to the terms of the Mozilla Public</TD></TR><TR><TD CLASS="l">4</TD><TD> * License, v. 2.0. If a copy of the MPL was not distributed with this</TD></TR><TR><TD CLASS="l">5</TD><TD> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</TD></TR><TR><TD CLASS="l">6</TD><TD> </TD></TR><TR><TD CLASS="l">7</TD><TD>package org.mozilla.javascript.regexp;</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>import org.mozilla.javascript.*;</TD></TR><TR><TD CLASS="l"><A NAME="0">10</A></TD><TD> </TD></TR><TR><TD CLASS="l">11</TD><TD>/**</TD></TR><TR><TD CLASS="l">12</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="c">13</A></TD><TD> */</TD></TR><TR CLASS="c"><TD CLASS="l">14</TD><TD>public class RegExpImpl implements RegExpProxy {</TD></TR><TR><TD CLASS="l">15</TD><TD> </TD></TR><TR><TD CLASS="l">16</TD><TD>    public boolean isRegExp(Scriptable obj) {</TD></TR><TR CLASS="c"><TD CLASS="l">17</TD><TD>        return obj instanceof NativeRegExp;</TD></TR><TR><TD CLASS="l"><A NAME="9">18</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>    public Object compileRegExp(Context cx, String source, String flags)</TD></TR><TR><TD CLASS="l">21</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">22</TD><TD>        return NativeRegExp.compileRE(cx, source, flags, false);</TD></TR><TR><TD CLASS="l">23</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="e">24</A></TD><TD> </TD></TR><TR><TD CLASS="l">25</TD><TD>    public Scriptable wrapRegExp(Context cx, Scriptable scope,</TD></TR><TR><TD CLASS="l">26</TD><TD>                                 Object compiled)</TD></TR><TR><TD CLASS="l">27</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">28</TD><TD>        return new NativeRegExp(scope, (RECompiled) compiled);</TD></TR><TR><TD CLASS="l">29</TD><TD>    }</TD></TR><TR><TD CLASS="l">30</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="7">31</A></TD><TD>    public Object action(Context cx, Scriptable scope,</TD></TR><TR><TD CLASS="l">32</TD><TD>                         Scriptable thisObj, Object[] args,</TD></TR><TR><TD CLASS="l">33</TD><TD>                         int actionType)</TD></TR><TR><TD CLASS="l">34</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">35</TD><TD>        GlobData data = new GlobData();</TD></TR><TR CLASS="c"><TD CLASS="l">36</TD><TD>        data.mode = actionType;</TD></TR><TR><TD CLASS="l">37</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">38</TD><TD>        switch (actionType) {</TD></TR><TR><TD CLASS="l">39</TD><TD>          case RA_MATCH:</TD></TR><TR><TD CLASS="l">40</TD><TD>            {</TD></TR><TR><TD CLASS="l">41</TD><TD>                Object rval;</TD></TR><TR CLASS="c"><TD CLASS="l">42</TD><TD>                data.optarg = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">43</TD><TD>                rval = matchOrReplace(cx, scope, thisObj, args,</TD></TR><TR><TD CLASS="l">44</TD><TD>                                      this, data, false);</TD></TR><TR CLASS="c"><TD CLASS="l">45</TD><TD>                return data.arrayobj == null ? rval : data.arrayobj;</TD></TR><TR><TD CLASS="l">46</TD><TD>            }</TD></TR><TR><TD CLASS="l">47</TD><TD> </TD></TR><TR><TD CLASS="l">48</TD><TD>          case RA_SEARCH:</TD></TR><TR CLASS="c"><TD CLASS="l">49</TD><TD>            data.optarg = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">50</TD><TD>            return matchOrReplace(cx, scope, thisObj, args,</TD></TR><TR><TD CLASS="l">51</TD><TD>                                  this, data, false);</TD></TR><TR><TD CLASS="l">52</TD><TD> </TD></TR><TR><TD CLASS="l">53</TD><TD>          case RA_REPLACE:</TD></TR><TR><TD CLASS="l">54</TD><TD>            {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="88% line coverage (15 out of 17 instructions)">55</TD><TD TITLE="88% line coverage (15 out of 17 instructions)">                Object arg1 = args.length &lt; 2 ? Undefined.instance : args[1];</TD></TR><TR CLASS="c"><TD CLASS="l">56</TD><TD>                String repstr = null;</TD></TR><TR CLASS="c"><TD CLASS="l">57</TD><TD>                Function lambda = null;</TD></TR><TR CLASS="c"><TD CLASS="l">58</TD><TD>                if (arg1 instanceof Function) {</TD></TR><TR CLASS="c"><TD CLASS="l">59</TD><TD>                    lambda = (Function) arg1;</TD></TR><TR><TD CLASS="l">60</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">61</TD><TD>                    repstr = ScriptRuntime.toString(arg1);</TD></TR><TR><TD CLASS="l">62</TD><TD>                }</TD></TR><TR><TD CLASS="l">63</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>                data.optarg = 2;</TD></TR><TR CLASS="c"><TD CLASS="l">65</TD><TD>                data.lambda = lambda;</TD></TR><TR CLASS="c"><TD CLASS="l">66</TD><TD>                data.repstr = repstr;</TD></TR><TR CLASS="c"><TD CLASS="l">67</TD><TD>                data.dollar = repstr == null ? -1 : repstr.indexOf('$');</TD></TR><TR CLASS="c"><TD CLASS="l">68</TD><TD>                data.charBuf = null;</TD></TR><TR CLASS="c"><TD CLASS="l">69</TD><TD>                data.leftIndex = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">70</TD><TD>                Object val = matchOrReplace(cx, scope, thisObj, args,</TD></TR><TR><TD CLASS="l">71</TD><TD>                                            this, data, true);</TD></TR><TR><TD CLASS="l">72</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">73</TD><TD>                if (data.charBuf == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">74</TD><TD>                    if (data.global || val == null</TD></TR><TR><TD CLASS="l">75</TD><TD>                        || !val.equals(Boolean.TRUE))</TD></TR><TR><TD CLASS="l">76</TD><TD>                    {</TD></TR><TR><TD CLASS="l">77</TD><TD>                        /* Didn't match even once. */</TD></TR><TR CLASS="c"><TD CLASS="l">78</TD><TD>                        return data.str;</TD></TR><TR><TD CLASS="l">79</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">80</TD><TD>                    SubString lc = this.leftContext;</TD></TR><TR CLASS="c"><TD CLASS="l">81</TD><TD>                    replace_glob(data, cx, scope, this, lc.index, lc.length);</TD></TR><TR><TD CLASS="l">82</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">83</TD><TD>                SubString rc = this.rightContext;</TD></TR><TR CLASS="c"><TD CLASS="l">84</TD><TD>                data.charBuf.append(rc.str, rc.index, rc.index + rc.length);</TD></TR><TR CLASS="c"><TD CLASS="l">85</TD><TD>                return data.charBuf.toString();</TD></TR><TR><TD CLASS="l">86</TD><TD>            }</TD></TR><TR><TD CLASS="l">87</TD><TD> </TD></TR><TR><TD CLASS="l">88</TD><TD>          default:</TD></TR><TR CLASS="z"><TD CLASS="l">89</TD><TD>            throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">90</TD><TD>        }</TD></TR><TR><TD CLASS="l">91</TD><TD>    }</TD></TR><TR><TD CLASS="l">92</TD><TD> </TD></TR><TR><TD CLASS="l">93</TD><TD>    /**</TD></TR><TR><TD CLASS="l">94</TD><TD>     * Analog of C match_or_replace.</TD></TR><TR><TD CLASS="l">95</TD><TD>     */</TD></TR><TR><TD CLASS="l">96</TD><TD>    private static Object matchOrReplace(Context cx, Scriptable scope,</TD></TR><TR><TD CLASS="l">97</TD><TD>                                         Scriptable thisObj, Object[] args,</TD></TR><TR><TD CLASS="l">98</TD><TD>                                         RegExpImpl reImpl,</TD></TR><TR><TD CLASS="l"><A NAME="3">99</A></TD><TD>                                         GlobData data, boolean forceFlat)</TD></TR><TR><TD CLASS="l">100</TD><TD>    {</TD></TR><TR><TD CLASS="l">101</TD><TD>        NativeRegExp re;</TD></TR><TR><TD CLASS="l">102</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">103</TD><TD>        String str = ScriptRuntime.toString(thisObj);</TD></TR><TR CLASS="c"><TD CLASS="l">104</TD><TD>        data.str = str;</TD></TR><TR CLASS="c"><TD CLASS="l">105</TD><TD>        Scriptable topScope = ScriptableObject.getTopLevelScope(scope);</TD></TR><TR><TD CLASS="l">106</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">107</TD><TD>        if (args.length == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">108</TD><TD>            RECompiled compiled = NativeRegExp.compileRE(cx, &#34;&#34;, &#34;&#34;, false);</TD></TR><TR CLASS="c"><TD CLASS="l">109</TD><TD>            re = new NativeRegExp(topScope, compiled);</TD></TR><TR CLASS="c"><TD CLASS="l">110</TD><TD>        } else if (args[0] instanceof NativeRegExp) {</TD></TR><TR CLASS="c"><TD CLASS="l">111</TD><TD>            re = (NativeRegExp) args[0];</TD></TR><TR><TD CLASS="l">112</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">113</TD><TD>            String src = ScriptRuntime.toString(args[0]);</TD></TR><TR><TD CLASS="l">114</TD><TD>            String opt;</TD></TR><TR CLASS="c"><TD CLASS="l">115</TD><TD>            if (data.optarg &lt; args.length) {</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>                args[0] = src;</TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>                opt = ScriptRuntime.toString(args[data.optarg]);</TD></TR><TR><TD CLASS="l">118</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">119</TD><TD>                opt = null;</TD></TR><TR><TD CLASS="l">120</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">121</TD><TD>            RECompiled compiled = NativeRegExp.compileRE(cx, src, opt, forceFlat);</TD></TR><TR CLASS="c"><TD CLASS="l">122</TD><TD>            re = new NativeRegExp(topScope, compiled);</TD></TR><TR><TD CLASS="l">123</TD><TD>        }</TD></TR><TR><TD CLASS="l">124</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">125</TD><TD>        data.global = (re.getFlags() &amp; NativeRegExp.JSREG_GLOB) != 0;</TD></TR><TR CLASS="c"><TD CLASS="l">126</TD><TD>        int[] indexp = { 0 };</TD></TR><TR CLASS="c"><TD CLASS="l">127</TD><TD>        Object result = null;</TD></TR><TR CLASS="c"><TD CLASS="l">128</TD><TD>        if (data.mode == RA_SEARCH) {</TD></TR><TR CLASS="c"><TD CLASS="l">129</TD><TD>            result = re.executeRegExp(cx, scope, reImpl,</TD></TR><TR><TD CLASS="l">130</TD><TD>                                      str, indexp, NativeRegExp.TEST);</TD></TR><TR CLASS="c"><TD CLASS="l">131</TD><TD>            if (result != null &amp;&amp; result.equals(Boolean.TRUE))</TD></TR><TR CLASS="c"><TD CLASS="l">132</TD><TD>                result = Integer.valueOf(reImpl.leftContext.length);</TD></TR><TR><TD CLASS="l">133</TD><TD>            else</TD></TR><TR CLASS="c"><TD CLASS="l">134</TD><TD>                result = Integer.valueOf(-1);</TD></TR><TR CLASS="c"><TD CLASS="l">135</TD><TD>        } else if (data.global) {</TD></TR><TR CLASS="c"><TD CLASS="l">136</TD><TD>            re.lastIndex = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">137</TD><TD>            for (int count = 0; indexp[0] &lt;= str.length(); count++) {</TD></TR><TR CLASS="c"><TD CLASS="l">138</TD><TD>                result = re.executeRegExp(cx, scope, reImpl,</TD></TR><TR><TD CLASS="l">139</TD><TD>                                          str, indexp, NativeRegExp.TEST);</TD></TR><TR CLASS="c"><TD CLASS="l">140</TD><TD>                if (result == null || !result.equals(Boolean.TRUE))</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>                    break;</TD></TR><TR CLASS="c"><TD CLASS="l">142</TD><TD>                if (data.mode == RA_MATCH) {</TD></TR><TR CLASS="c"><TD CLASS="l">143</TD><TD>                    match_glob(data, cx, scope, count, reImpl);</TD></TR><TR><TD CLASS="l">144</TD><TD>                } else {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (4 out of 6 instructions)">145</TD><TD TITLE="67% line coverage (4 out of 6 instructions)">                    if (data.mode != RA_REPLACE) Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">146</TD><TD>                    SubString lastMatch = reImpl.lastMatch;</TD></TR><TR CLASS="c"><TD CLASS="l">147</TD><TD>                    int leftIndex = data.leftIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">148</TD><TD>                    int leftlen = lastMatch.index - leftIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">149</TD><TD>                    data.leftIndex = lastMatch.index + lastMatch.length;</TD></TR><TR CLASS="c"><TD CLASS="l">150</TD><TD>                    replace_glob(data, cx, scope, reImpl, leftIndex, leftlen);</TD></TR><TR><TD CLASS="l">151</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">152</TD><TD>                if (reImpl.lastMatch.length == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">153</TD><TD>                    if (indexp[0] == str.length())</TD></TR><TR CLASS="c"><TD CLASS="l">154</TD><TD>                        break;</TD></TR><TR CLASS="z"><TD CLASS="l">155</TD><TD>                    indexp[0]++;</TD></TR><TR><TD CLASS="l">156</TD><TD>                }</TD></TR><TR><TD CLASS="l">157</TD><TD>            }</TD></TR><TR><TD CLASS="l">158</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">159</TD><TD>            result = re.executeRegExp(cx, scope, reImpl, str, indexp,</TD></TR><TR><TD CLASS="l">160</TD><TD>                                      ((data.mode == RA_REPLACE)</TD></TR><TR><TD CLASS="l">161</TD><TD>                                       ? NativeRegExp.TEST</TD></TR><TR><TD CLASS="l">162</TD><TD>                                       : NativeRegExp.MATCH));</TD></TR><TR><TD CLASS="l">163</TD><TD>        }</TD></TR><TR><TD CLASS="l">164</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">165</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">166</TD><TD>    }</TD></TR><TR><TD CLASS="l">167</TD><TD> </TD></TR><TR><TD CLASS="l">168</TD><TD> </TD></TR><TR><TD CLASS="l">169</TD><TD> </TD></TR><TR><TD CLASS="l">170</TD><TD>    public int find_split(Context cx, Scriptable scope, String target,</TD></TR><TR><TD CLASS="l"><A NAME="4">171</A></TD><TD>                          String separator, Scriptable reObj,</TD></TR><TR><TD CLASS="l">172</TD><TD>                          int[] ip, int[] matchlen,</TD></TR><TR><TD CLASS="l">173</TD><TD>                          boolean[] matched, String[][] parensp)</TD></TR><TR><TD CLASS="l">174</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">175</TD><TD>        int i = ip[0];</TD></TR><TR CLASS="c"><TD CLASS="l">176</TD><TD>        int length = target.length();</TD></TR><TR><TD CLASS="l">177</TD><TD>        int result;</TD></TR><TR><TD CLASS="l">178</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">179</TD><TD>        int version = cx.getLanguageVersion();</TD></TR><TR CLASS="c"><TD CLASS="l">180</TD><TD>        NativeRegExp re = (NativeRegExp) reObj;</TD></TR><TR><TD CLASS="l">181</TD><TD>        again:</TD></TR><TR><TD CLASS="l">182</TD><TD>        while (true) {  // imitating C label</TD></TR><TR><TD CLASS="l">183</TD><TD>            /* JS1.2 deviated from Perl by never matching at end of string. */</TD></TR><TR CLASS="c"><TD CLASS="l">184</TD><TD>            int ipsave = ip[0]; // reuse ip to save object creation</TD></TR><TR CLASS="c"><TD CLASS="l">185</TD><TD>            ip[0] = i;</TD></TR><TR CLASS="c"><TD CLASS="l">186</TD><TD>            Object ret = re.executeRegExp(cx, scope, this, target, ip,</TD></TR><TR><TD CLASS="l">187</TD><TD>                                          NativeRegExp.TEST);</TD></TR><TR CLASS="c"><TD CLASS="l">188</TD><TD>            if (ret != Boolean.TRUE) {</TD></TR><TR><TD CLASS="l">189</TD><TD>                // Mismatch: ensure our caller advances i past end of string.</TD></TR><TR CLASS="c"><TD CLASS="l">190</TD><TD>                ip[0] = ipsave;</TD></TR><TR CLASS="c"><TD CLASS="l">191</TD><TD>                matchlen[0] = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">192</TD><TD>                matched[0] = false;</TD></TR><TR CLASS="c"><TD CLASS="l">193</TD><TD>                return length;</TD></TR><TR><TD CLASS="l">194</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">195</TD><TD>            i = ip[0];</TD></TR><TR CLASS="c"><TD CLASS="l">196</TD><TD>            ip[0] = ipsave;</TD></TR><TR CLASS="c"><TD CLASS="l">197</TD><TD>            matched[0] = true;</TD></TR><TR><TD CLASS="l">198</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">199</TD><TD>            SubString sep = this.lastMatch;</TD></TR><TR CLASS="c"><TD CLASS="l">200</TD><TD>            matchlen[0] = sep.length;</TD></TR><TR CLASS="c"><TD CLASS="l">201</TD><TD>            if (matchlen[0] == 0) {</TD></TR><TR><TD CLASS="l">202</TD><TD>                /*</TD></TR><TR><TD CLASS="l">203</TD><TD>                 * Empty string match: never split on an empty</TD></TR><TR><TD CLASS="l">204</TD><TD>                 * match at the start of a find_split cycle.  Same</TD></TR><TR><TD CLASS="l">205</TD><TD>                 * rule as for an empty global match in</TD></TR><TR><TD CLASS="l">206</TD><TD>                 * match_or_replace.</TD></TR><TR><TD CLASS="l">207</TD><TD>                 */</TD></TR><TR CLASS="c"><TD CLASS="l">208</TD><TD>                if (i == ip[0]) {</TD></TR><TR><TD CLASS="l">209</TD><TD>                    /*</TD></TR><TR><TD CLASS="l">210</TD><TD>                     * &#34;Bump-along&#34; to avoid sticking at an empty</TD></TR><TR><TD CLASS="l">211</TD><TD>                     * match, but don't bump past end of string --</TD></TR><TR><TD CLASS="l">212</TD><TD>                     * our caller must do that by adding</TD></TR><TR><TD CLASS="l">213</TD><TD>                     * sep-&gt;length to our return value.</TD></TR><TR><TD CLASS="l">214</TD><TD>                     */</TD></TR><TR CLASS="c"><TD CLASS="l">215</TD><TD>                    if (i == length) {</TD></TR><TR CLASS="c"><TD CLASS="l">216</TD><TD>                        if (version == Context.VERSION_1_2) {</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>                            matchlen[0] = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                            result = i;</TD></TR><TR><TD CLASS="l">219</TD><TD>                        }</TD></TR><TR><TD CLASS="l">220</TD><TD>                        else</TD></TR><TR CLASS="c"><TD CLASS="l">221</TD><TD>                            result = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">223</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">224</TD><TD>                    i++;</TD></TR><TR CLASS="c"><TD CLASS="l">225</TD><TD>                    continue again; // imitating C goto</TD></TR><TR><TD CLASS="l">226</TD><TD>                }</TD></TR><TR><TD CLASS="l">227</TD><TD>            }</TD></TR><TR><TD CLASS="l">228</TD><TD>            // PR_ASSERT((size_t)i &gt;= sep-&gt;length);</TD></TR><TR CLASS="c"><TD CLASS="l">229</TD><TD>            result = i - matchlen[0];</TD></TR><TR CLASS="c"><TD CLASS="l">230</TD><TD>            break;</TD></TR><TR><TD CLASS="l">231</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">232</TD><TD>        int size = (parens == null) ? 0 : parens.length;</TD></TR><TR CLASS="c"><TD CLASS="l">233</TD><TD>        parensp[0] = new String[size];</TD></TR><TR CLASS="c"><TD CLASS="l">234</TD><TD>        for (int num = 0; num &lt; size; num++) {</TD></TR><TR CLASS="c"><TD CLASS="l">235</TD><TD>            SubString parsub = getParenSubString(num);</TD></TR><TR CLASS="c"><TD CLASS="l">236</TD><TD>            parensp[0][num] = parsub.toString();</TD></TR><TR><TD CLASS="l">237</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">238</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">239</TD><TD>    }</TD></TR><TR><TD CLASS="l">240</TD><TD> </TD></TR><TR><TD CLASS="l">241</TD><TD>    /**</TD></TR><TR><TD CLASS="l">242</TD><TD>     * Analog of REGEXP_PAREN_SUBSTRING in C jsregexp.h.</TD></TR><TR><TD CLASS="l"><A NAME="b">243</A></TD><TD>     * Assumes zero-based; i.e., for $3, i==2</TD></TR><TR><TD CLASS="l">244</TD><TD>     */</TD></TR><TR><TD CLASS="l">245</TD><TD>    SubString getParenSubString(int i)</TD></TR><TR><TD CLASS="l">246</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">247</TD><TD>        if (parens != null &amp;&amp; i &lt; parens.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">248</TD><TD>            SubString parsub = parens[i];</TD></TR><TR CLASS="c"><TD CLASS="l">249</TD><TD>            if (parsub != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">250</TD><TD>                return parsub;</TD></TR><TR><TD CLASS="l">251</TD><TD>            }</TD></TR><TR><TD CLASS="l">252</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">253</TD><TD>        return SubString.emptySubString;</TD></TR><TR><TD CLASS="l">254</TD><TD>    }</TD></TR><TR><TD CLASS="l">255</TD><TD> </TD></TR><TR><TD CLASS="l">256</TD><TD>    /*</TD></TR><TR><TD CLASS="l">257</TD><TD>     * Analog of match_glob() in jsstr.c</TD></TR><TR><TD CLASS="l">258</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="d">259</A></TD><TD>    private static void match_glob(GlobData mdata, Context cx,</TD></TR><TR><TD CLASS="l">260</TD><TD>                                   Scriptable scope, int count,</TD></TR><TR><TD CLASS="l">261</TD><TD>                                   RegExpImpl reImpl)</TD></TR><TR><TD CLASS="l">262</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">263</TD><TD>        if (mdata.arrayobj == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">264</TD><TD>            mdata.arrayobj = cx.newArray(scope, 0);</TD></TR><TR><TD CLASS="l">265</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">266</TD><TD>        SubString matchsub = reImpl.lastMatch;</TD></TR><TR CLASS="c"><TD CLASS="l">267</TD><TD>        String matchstr = matchsub.toString();</TD></TR><TR CLASS="c"><TD CLASS="l">268</TD><TD>        mdata.arrayobj.put(count, mdata.arrayobj, matchstr);</TD></TR><TR CLASS="c"><TD CLASS="l">269</TD><TD>    }</TD></TR><TR><TD CLASS="l">270</TD><TD> </TD></TR><TR><TD CLASS="l">271</TD><TD>    /*</TD></TR><TR><TD CLASS="l">272</TD><TD>     * Analog of replace_glob() in jsstr.c</TD></TR><TR><TD CLASS="l">273</TD><TD>     */</TD></TR><TR><TD CLASS="l">274</TD><TD>    private static void replace_glob(GlobData rdata, Context cx,</TD></TR><TR><TD CLASS="l">275</TD><TD>                                     Scriptable scope, RegExpImpl reImpl,</TD></TR><TR><TD CLASS="l"><A NAME="5">276</A></TD><TD>                                     int leftIndex, int leftlen)</TD></TR><TR><TD CLASS="l">277</TD><TD>    {</TD></TR><TR><TD CLASS="l">278</TD><TD>        int replen;</TD></TR><TR><TD CLASS="l">279</TD><TD>        String lambdaStr;</TD></TR><TR CLASS="c"><TD CLASS="l">280</TD><TD>        if (rdata.lambda != null) {</TD></TR><TR><TD CLASS="l">281</TD><TD>            // invoke lambda function with args lastMatch, $1, $2, ... $n,</TD></TR><TR><TD CLASS="l">282</TD><TD>            // leftContext.length, whole string.</TD></TR><TR CLASS="c"><TD CLASS="l">283</TD><TD>            SubString[] parens = reImpl.parens;</TD></TR><TR CLASS="c"><TD CLASS="l">284</TD><TD>            int parenCount = (parens == null) ? 0 : parens.length;</TD></TR><TR CLASS="c"><TD CLASS="l">285</TD><TD>            Object[] args = new Object[parenCount + 3];</TD></TR><TR CLASS="c"><TD CLASS="l">286</TD><TD>            args[0] = reImpl.lastMatch.toString();</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>            for (int i=0; i &lt; parenCount; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">288</TD><TD>                SubString sub = parens[i];</TD></TR><TR CLASS="c"><TD CLASS="l">289</TD><TD>                if (sub != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">290</TD><TD>                    args[i+1] = sub.toString();</TD></TR><TR><TD CLASS="l">291</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                    args[i+1] = Undefined.instance;</TD></TR><TR><TD CLASS="l">293</TD><TD>                }</TD></TR><TR><TD CLASS="l">294</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">295</TD><TD>            args[parenCount+1] = Integer.valueOf(reImpl.leftContext.length);</TD></TR><TR CLASS="c"><TD CLASS="l">296</TD><TD>            args[parenCount+2] = rdata.str;</TD></TR><TR><TD CLASS="l">297</TD><TD>            // This is a hack to prevent expose of reImpl data to</TD></TR><TR><TD CLASS="l">298</TD><TD>            // JS function which can run new regexps modifing</TD></TR><TR><TD CLASS="l">299</TD><TD>            // regexp that are used later by the engine.</TD></TR><TR><TD CLASS="l">300</TD><TD>            // TODO: redesign is necessary</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="91% line coverage (20 out of 22 instructions)">301</TD><TD TITLE="91% line coverage (20 out of 22 instructions)">            if (reImpl != ScriptRuntime.getRegExpProxy(cx)) Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">302</TD><TD>            RegExpImpl re2 = new RegExpImpl();</TD></TR><TR CLASS="c"><TD CLASS="l">303</TD><TD>            re2.multiline = reImpl.multiline;</TD></TR><TR CLASS="c"><TD CLASS="l">304</TD><TD>            re2.input = reImpl.input;</TD></TR><TR CLASS="c"><TD CLASS="l">305</TD><TD>            ScriptRuntime.setRegExpProxy(cx, re2);</TD></TR><TR><TD CLASS="l">306</TD><TD>            try {</TD></TR><TR CLASS="c"><TD CLASS="l">307</TD><TD>                Scriptable parent = ScriptableObject.getTopLevelScope(scope);</TD></TR><TR CLASS="c"><TD CLASS="l">308</TD><TD>                Object result = rdata.lambda.call(cx, parent, parent, args);</TD></TR><TR CLASS="c"><TD CLASS="l">309</TD><TD>                lambdaStr = ScriptRuntime.toString(result);</TD></TR><TR><TD CLASS="l">310</TD><TD>            } finally {</TD></TR><TR CLASS="c"><TD CLASS="l">311</TD><TD>                ScriptRuntime.setRegExpProxy(cx, reImpl);</TD></TR><TR CLASS="c"><TD CLASS="l">312</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">313</TD><TD>            replen = lambdaStr.length();</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">315</TD><TD>            lambdaStr = null;</TD></TR><TR CLASS="c"><TD CLASS="l">316</TD><TD>            replen = rdata.repstr.length();</TD></TR><TR CLASS="c"><TD CLASS="l">317</TD><TD>            if (rdata.dollar &gt;= 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">318</TD><TD>                int[] skip = new int[1];</TD></TR><TR CLASS="c"><TD CLASS="l">319</TD><TD>                int dp = rdata.dollar;</TD></TR><TR><TD CLASS="l">320</TD><TD>                do {</TD></TR><TR CLASS="c"><TD CLASS="l">321</TD><TD>                    SubString sub = interpretDollar(cx, reImpl, rdata.repstr,</TD></TR><TR><TD CLASS="l">322</TD><TD>                                                    dp, skip);</TD></TR><TR CLASS="c"><TD CLASS="l">323</TD><TD>                    if (sub != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">324</TD><TD>                        replen += sub.length - skip[0];</TD></TR><TR CLASS="c"><TD CLASS="l">325</TD><TD>                        dp += skip[0];</TD></TR><TR><TD CLASS="l">326</TD><TD>                    } else {</TD></TR><TR CLASS="c"><TD CLASS="l">327</TD><TD>                        ++dp;</TD></TR><TR><TD CLASS="l">328</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">329</TD><TD>                    dp = rdata.repstr.indexOf('$', dp);</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>                } while (dp &gt;= 0);</TD></TR><TR><TD CLASS="l">331</TD><TD>            }</TD></TR><TR><TD CLASS="l">332</TD><TD>        }</TD></TR><TR><TD CLASS="l">333</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">334</TD><TD>        int growth = leftlen + replen + reImpl.rightContext.length;</TD></TR><TR CLASS="c"><TD CLASS="l">335</TD><TD>        StringBuilder charBuf = rdata.charBuf;</TD></TR><TR CLASS="c"><TD CLASS="l">336</TD><TD>        if (charBuf == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">337</TD><TD>            charBuf = new StringBuilder(growth);</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>            rdata.charBuf = charBuf;</TD></TR><TR><TD CLASS="l">339</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">340</TD><TD>            charBuf.ensureCapacity(rdata.charBuf.length() + growth);</TD></TR><TR><TD CLASS="l">341</TD><TD>        }</TD></TR><TR><TD CLASS="l">342</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>        charBuf.append(reImpl.leftContext.str, leftIndex, leftIndex + leftlen);</TD></TR><TR CLASS="c"><TD CLASS="l">344</TD><TD>        if (rdata.lambda != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>            charBuf.append(lambdaStr);</TD></TR><TR><TD CLASS="l">346</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">347</TD><TD>            do_replace(rdata, cx, reImpl);</TD></TR><TR><TD CLASS="l">348</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">349</TD><TD>    }</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR><TD CLASS="l">351</TD><TD>    private static SubString interpretDollar(Context cx, RegExpImpl res,</TD></TR><TR><TD CLASS="l">352</TD><TD>                                             String da, int dp, int[] skip)</TD></TR><TR><TD CLASS="l"><A NAME="1">353</A></TD><TD>    {</TD></TR><TR><TD CLASS="l">354</TD><TD>        char dc;</TD></TR><TR><TD CLASS="l">355</TD><TD>        int num, tmp;</TD></TR><TR><TD CLASS="l">356</TD><TD> </TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="71% line coverage (5 out of 7 instructions)">357</TD><TD TITLE="71% line coverage (5 out of 7 instructions)">        if (da.charAt(dp) != '$') Kit.codeBug();</TD></TR><TR><TD CLASS="l">358</TD><TD> </TD></TR><TR><TD CLASS="l">359</TD><TD>        /* Allow a real backslash (literal &#34;\\&#34;) to escape &#34;$1&#34; etc. */</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        int version = cx.getLanguageVersion();</TD></TR><TR CLASS="c"><TD CLASS="l">361</TD><TD>        if (version != Context.VERSION_DEFAULT</TD></TR><TR><TD CLASS="l">362</TD><TD>            &amp;&amp; version &lt;= Context.VERSION_1_4)</TD></TR><TR><TD CLASS="l">363</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>            if (dp &gt; 0 &amp;&amp; da.charAt(dp - 1) == '\\')</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">366</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">367</TD><TD>        int daL = da.length();</TD></TR><TR CLASS="c"><TD CLASS="l">368</TD><TD>        if (dp + 1 &gt;= daL)</TD></TR><TR CLASS="c"><TD CLASS="l">369</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">370</TD><TD>        /* Interpret all Perl match-induced dollar variables. */</TD></TR><TR CLASS="c"><TD CLASS="l">371</TD><TD>        dc = da.charAt(dp + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">372</TD><TD>        if (NativeRegExp.isDigit(dc)) {</TD></TR><TR><TD CLASS="l">373</TD><TD>            int cp;</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>            if (version != Context.VERSION_DEFAULT</TD></TR><TR><TD CLASS="l">375</TD><TD>                &amp;&amp; version &lt;= Context.VERSION_1_4)</TD></TR><TR><TD CLASS="l">376</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                if (dc == '0')</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                    return null;</TD></TR><TR><TD CLASS="l">379</TD><TD>                /* Check for overflow to avoid gobbling arbitrary decimal digits. */</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                num = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>                cp = dp;</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                while (++cp &lt; daL &amp;&amp; NativeRegExp.isDigit(dc = da.charAt(cp)))</TD></TR><TR><TD CLASS="l">383</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>                    tmp = 10 * num + (dc - '0');</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>                    if (tmp &lt; num)</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                        break;</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>                    num = tmp;</TD></TR><TR><TD CLASS="l">388</TD><TD>                }</TD></TR><TR><TD CLASS="l">389</TD><TD>            }</TD></TR><TR><TD CLASS="l">390</TD><TD>            else {  /* ECMA 3, 1-9 or 01-99 */</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="88% line coverage (14 out of 16 instructions)">391</TD><TD TITLE="88% line coverage (14 out of 16 instructions)">                int parenCount = (res.parens == null) ? 0 : res.parens.length;</TD></TR><TR CLASS="c"><TD CLASS="l">392</TD><TD>                num = dc - '0';</TD></TR><TR CLASS="c"><TD CLASS="l">393</TD><TD>                if (num &gt; parenCount)</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                    return null;</TD></TR><TR CLASS="c"><TD CLASS="l">395</TD><TD>                cp = dp + 2;</TD></TR><TR CLASS="c"><TD CLASS="l">396</TD><TD>                if ((dp + 2) &lt; daL) {</TD></TR><TR CLASS="c"><TD CLASS="l">397</TD><TD>                    dc = da.charAt(dp + 2);</TD></TR><TR CLASS="c"><TD CLASS="l">398</TD><TD>                    if (NativeRegExp.isDigit(dc)) {</TD></TR><TR CLASS="c"><TD CLASS="l">399</TD><TD>                        tmp = 10 * num + (dc - '0');</TD></TR><TR CLASS="c"><TD CLASS="l">400</TD><TD>                        if (tmp &lt;= parenCount) {</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                            cp++;</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>                            num = tmp;</TD></TR><TR><TD CLASS="l">403</TD><TD>                        }</TD></TR><TR><TD CLASS="l">404</TD><TD>                    }</TD></TR><TR><TD CLASS="l">405</TD><TD>                }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="50% line coverage (2 out of 4 instructions)">406</TD><TD TITLE="50% line coverage (2 out of 4 instructions)">                if (num == 0) return null;  /* $0 or $00 is not valid */</TD></TR><TR><TD CLASS="l">407</TD><TD>            }</TD></TR><TR><TD CLASS="l">408</TD><TD>            /* Adjust num from 1 $n-origin to 0 array-index-origin. */</TD></TR><TR CLASS="c"><TD CLASS="l">409</TD><TD>            num--;</TD></TR><TR CLASS="c"><TD CLASS="l">410</TD><TD>            skip[0] = cp - dp;</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>            return res.getParenSubString(num);</TD></TR><TR><TD CLASS="l">412</TD><TD>        }</TD></TR><TR><TD CLASS="l">413</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">414</TD><TD>        skip[0] = 2;</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>        switch (dc) {</TD></TR><TR><TD CLASS="l">416</TD><TD>          case '$':</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>            return new SubString(&#34;$&#34;);</TD></TR><TR><TD CLASS="l">418</TD><TD>          case '&amp;':</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>            return res.lastMatch;</TD></TR><TR><TD CLASS="l">420</TD><TD>          case '+':</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>            return res.lastParen;</TD></TR><TR><TD CLASS="l">422</TD><TD>          case '`':</TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>            if (version == Context.VERSION_1_2) {</TD></TR><TR><TD CLASS="l">424</TD><TD>                /*</TD></TR><TR><TD CLASS="l">425</TD><TD>                 * JS1.2 imitated the Perl4 bug where left context at each step</TD></TR><TR><TD CLASS="l">426</TD><TD>                 * in an iterative use of a global regexp started from last match,</TD></TR><TR><TD CLASS="l">427</TD><TD>                 * not from the start of the target string.  But Perl4 does start</TD></TR><TR><TD CLASS="l">428</TD><TD>                 * $` at the beginning of the target string when it is used in a</TD></TR><TR><TD CLASS="l">429</TD><TD>                 * substitution, so we emulate that special case here.</TD></TR><TR><TD CLASS="l">430</TD><TD>                 */</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                res.leftContext.index = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                res.leftContext.length = res.lastMatch.index;</TD></TR><TR><TD CLASS="l">433</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>            return res.leftContext;</TD></TR><TR><TD CLASS="l">435</TD><TD>          case '\'':</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>            return res.rightContext;</TD></TR><TR><TD CLASS="l">437</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">439</TD><TD>    }</TD></TR><TR><TD CLASS="l">440</TD><TD> </TD></TR><TR><TD CLASS="l">441</TD><TD>    /**</TD></TR><TR><TD CLASS="l">442</TD><TD>     * Analog of do_replace in jsstr.c</TD></TR><TR><TD CLASS="l"><A NAME="a">443</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">444</TD><TD>    private static void do_replace(GlobData rdata, Context cx,</TD></TR><TR><TD CLASS="l">445</TD><TD>                                   RegExpImpl regExpImpl)</TD></TR><TR><TD CLASS="l">446</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">447</TD><TD>        StringBuilder charBuf = rdata.charBuf;</TD></TR><TR CLASS="c"><TD CLASS="l">448</TD><TD>        int cp = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">449</TD><TD>        String da = rdata.repstr;</TD></TR><TR CLASS="c"><TD CLASS="l">450</TD><TD>        int dp = rdata.dollar;</TD></TR><TR CLASS="c"><TD CLASS="l">451</TD><TD>        if (dp != -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">452</TD><TD>            int[] skip = new int[1];</TD></TR><TR><TD CLASS="l">453</TD><TD>            do {</TD></TR><TR CLASS="c"><TD CLASS="l">454</TD><TD>                int len = dp - cp;</TD></TR><TR CLASS="c"><TD CLASS="l">455</TD><TD>                charBuf.append(da.substring(cp, dp));</TD></TR><TR CLASS="c"><TD CLASS="l">456</TD><TD>                cp = dp;</TD></TR><TR CLASS="c"><TD CLASS="l">457</TD><TD>                SubString sub = interpretDollar(cx, regExpImpl, da,</TD></TR><TR><TD CLASS="l">458</TD><TD>                                                dp, skip);</TD></TR><TR CLASS="c"><TD CLASS="l">459</TD><TD>                if (sub != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">460</TD><TD>                    len = sub.length;</TD></TR><TR CLASS="c"><TD CLASS="l">461</TD><TD>                    if (len &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">462</TD><TD>                        charBuf.append(sub.str, sub.index, sub.index + len);</TD></TR><TR><TD CLASS="l">463</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">464</TD><TD>                    cp += skip[0];</TD></TR><TR CLASS="c"><TD CLASS="l">465</TD><TD>                    dp += skip[0];</TD></TR><TR><TD CLASS="l">466</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">467</TD><TD>                    ++dp;</TD></TR><TR><TD CLASS="l">468</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">469</TD><TD>                dp = da.indexOf('$', dp);</TD></TR><TR CLASS="c"><TD CLASS="l">470</TD><TD>            } while (dp &gt;= 0);</TD></TR><TR><TD CLASS="l">471</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">472</TD><TD>        int daL = da.length();</TD></TR><TR CLASS="c"><TD CLASS="l">473</TD><TD>        if (daL &gt; cp) {</TD></TR><TR CLASS="c"><TD CLASS="l">474</TD><TD>            charBuf.append(da.substring(cp, daL));</TD></TR><TR><TD CLASS="l">475</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">476</TD><TD>    }</TD></TR><TR><TD CLASS="l">477</TD><TD> </TD></TR><TR><TD CLASS="l">478</TD><TD>    /*</TD></TR><TR><TD CLASS="l">479</TD><TD>     * See ECMA 15.5.4.8.  Modified to match JS 1.2 - optionally takes</TD></TR><TR><TD CLASS="l">480</TD><TD>     * a limit argument and accepts a regular expression as the split</TD></TR><TR><TD CLASS="l">481</TD><TD>     * argument.</TD></TR><TR><TD CLASS="l">482</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="6">483</A></TD><TD>    public Object js_split(Context cx, Scriptable scope,</TD></TR><TR><TD CLASS="l">484</TD><TD>                                   String target, Object[] args)</TD></TR><TR><TD CLASS="l">485</TD><TD>    {</TD></TR><TR><TD CLASS="l">486</TD><TD>        // create an empty Array to return;</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>        Scriptable result = cx.newArray(scope, 0);</TD></TR><TR><TD CLASS="l">488</TD><TD> </TD></TR><TR><TD CLASS="l">489</TD><TD>        // return an array consisting of the target if no separator given</TD></TR><TR><TD CLASS="l">490</TD><TD>        // don't check against undefined, because we want</TD></TR><TR><TD CLASS="l">491</TD><TD>        // 'fooundefinedbar'.split(void 0) to split to ['foo', 'bar']</TD></TR><TR CLASS="c"><TD CLASS="l">492</TD><TD>        if (args.length &lt; 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">493</TD><TD>            result.put(0, result, target);</TD></TR><TR CLASS="c"><TD CLASS="l">494</TD><TD>            return result;</TD></TR><TR><TD CLASS="l">495</TD><TD>        }</TD></TR><TR><TD CLASS="l">496</TD><TD> </TD></TR><TR><TD CLASS="l">497</TD><TD>        // Use the second argument as the split limit, if given.</TD></TR><TR CLASS="c"><TD CLASS="l">498</TD><TD>        boolean limited = (args.length &gt; 1) &amp;&amp; (args[1] != Undefined.instance);</TD></TR><TR CLASS="c"><TD CLASS="l">499</TD><TD>        long limit = 0;  // Initialize to avoid warning.</TD></TR><TR CLASS="c"><TD CLASS="l">500</TD><TD>        if (limited) {</TD></TR><TR><TD CLASS="l">501</TD><TD>            /* Clamp limit between 0 and 1 + string length. */</TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>            limit = ScriptRuntime.toUint32(args[1]);</TD></TR><TR CLASS="c"><TD CLASS="l">503</TD><TD>            if (limit &gt; target.length())</TD></TR><TR CLASS="c"><TD CLASS="l">504</TD><TD>                limit = 1 + target.length();</TD></TR><TR><TD CLASS="l">505</TD><TD>        }</TD></TR><TR><TD CLASS="l">506</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">507</TD><TD>        String separator = null;</TD></TR><TR CLASS="c"><TD CLASS="l">508</TD><TD>        int[] matchlen = new int[1];</TD></TR><TR CLASS="c"><TD CLASS="l">509</TD><TD>        Scriptable re = null;</TD></TR><TR CLASS="c"><TD CLASS="l">510</TD><TD>        RegExpProxy reProxy = null;</TD></TR><TR CLASS="c"><TD CLASS="l">511</TD><TD>        if (args[0] instanceof Scriptable) {</TD></TR><TR CLASS="c"><TD CLASS="l">512</TD><TD>            reProxy = ScriptRuntime.getRegExpProxy(cx);</TD></TR><TR CLASS="c"><TD CLASS="l">513</TD><TD>            if (reProxy != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">514</TD><TD>                Scriptable test = (Scriptable)args[0];</TD></TR><TR CLASS="c"><TD CLASS="l">515</TD><TD>                if (reProxy.isRegExp(test)) {</TD></TR><TR CLASS="c"><TD CLASS="l">516</TD><TD>                    re = test;</TD></TR><TR><TD CLASS="l">517</TD><TD>                }</TD></TR><TR><TD CLASS="l">518</TD><TD>            }</TD></TR><TR><TD CLASS="l">519</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">520</TD><TD>        if (re == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">521</TD><TD>            separator = ScriptRuntime.toString(args[0]);</TD></TR><TR CLASS="c"><TD CLASS="l">522</TD><TD>            matchlen[0] = separator.length();</TD></TR><TR><TD CLASS="l">523</TD><TD>        }</TD></TR><TR><TD CLASS="l">524</TD><TD> </TD></TR><TR><TD CLASS="l">525</TD><TD>        // split target with separator or re</TD></TR><TR CLASS="c"><TD CLASS="l">526</TD><TD>        int[] ip = { 0 };</TD></TR><TR><TD CLASS="l">527</TD><TD>        int match;</TD></TR><TR CLASS="c"><TD CLASS="l">528</TD><TD>        int len = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">529</TD><TD>        boolean[] matched = { false };</TD></TR><TR CLASS="c"><TD CLASS="l">530</TD><TD>        String[][] parens = { null };</TD></TR><TR CLASS="c"><TD CLASS="l">531</TD><TD>        int version = cx.getLanguageVersion();</TD></TR><TR><TD CLASS="l">532</TD><TD>        while ((match = find_split(cx, scope, target, separator, version,</TD></TR><TR><TD CLASS="l">533</TD><TD>                                   reProxy, re, ip, matchlen, matched, parens))</TD></TR><TR CLASS="c"><TD CLASS="l">534</TD><TD>               &gt;= 0)</TD></TR><TR><TD CLASS="l">535</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">536</TD><TD>            if ((limited &amp;&amp; len &gt;= limit) || (match &gt; target.length()))</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>                break;</TD></TR><TR><TD CLASS="l">538</TD><TD> </TD></TR><TR><TD CLASS="l">539</TD><TD>            String substr;</TD></TR><TR CLASS="c"><TD CLASS="l">540</TD><TD>            if (target.length() == 0)</TD></TR><TR CLASS="c"><TD CLASS="l">541</TD><TD>                substr = target;</TD></TR><TR><TD CLASS="l">542</TD><TD>            else</TD></TR><TR CLASS="c"><TD CLASS="l">543</TD><TD>                substr = target.substring(ip[0], match);</TD></TR><TR><TD CLASS="l">544</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">545</TD><TD>            result.put(len, result, substr);</TD></TR><TR CLASS="c"><TD CLASS="l">546</TD><TD>            len++;</TD></TR><TR><TD CLASS="l">547</TD><TD>        /*</TD></TR><TR><TD CLASS="l">548</TD><TD>         * Imitate perl's feature of including parenthesized substrings</TD></TR><TR><TD CLASS="l">549</TD><TD>         * that matched part of the delimiter in the new array, after the</TD></TR><TR><TD CLASS="l">550</TD><TD>         * split substring that was delimited.</TD></TR><TR><TD CLASS="l">551</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">552</TD><TD>            if (re != null &amp;&amp; matched[0] == true) {</TD></TR><TR CLASS="c"><TD CLASS="l">553</TD><TD>                int size = parens[0].length;</TD></TR><TR CLASS="c"><TD CLASS="l">554</TD><TD>                for (int num = 0; num &lt; size; num++) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="29% line coverage (2 out of 7 instructions)">555</TD><TD TITLE="29% line coverage (2 out of 7 instructions)">                    if (limited &amp;&amp; len &gt;= limit)</TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                        break;</TD></TR><TR CLASS="c"><TD CLASS="l">557</TD><TD>                    result.put(len, result, parens[0][num]);</TD></TR><TR CLASS="c"><TD CLASS="l">558</TD><TD>                    len++;</TD></TR><TR><TD CLASS="l">559</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">560</TD><TD>                matched[0] = false;</TD></TR><TR><TD CLASS="l">561</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">562</TD><TD>            ip[0] = match + matchlen[0];</TD></TR><TR><TD CLASS="l">563</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">564</TD><TD>            if (version &lt; Context.VERSION_1_3</TD></TR><TR><TD CLASS="l">565</TD><TD>                &amp;&amp; version != Context.VERSION_DEFAULT)</TD></TR><TR><TD CLASS="l">566</TD><TD>            {</TD></TR><TR><TD CLASS="l">567</TD><TD>        /*</TD></TR><TR><TD CLASS="l">568</TD><TD>         * Deviate from ECMA to imitate Perl, which omits a final</TD></TR><TR><TD CLASS="l">569</TD><TD>         * split unless a limit argument is given and big enough.</TD></TR><TR><TD CLASS="l">570</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">571</TD><TD>                if (!limited &amp;&amp; ip[0] == target.length())</TD></TR><TR CLASS="c"><TD CLASS="l">572</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">573</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">574</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">575</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">576</TD><TD>    }</TD></TR><TR><TD CLASS="l">577</TD><TD> </TD></TR><TR><TD CLASS="l">578</TD><TD>    /*</TD></TR><TR><TD CLASS="l">579</TD><TD>     * Used by js_split to find the next split point in target,</TD></TR><TR><TD CLASS="l">580</TD><TD>     * starting at offset ip and looking either for the given</TD></TR><TR><TD CLASS="l">581</TD><TD>     * separator substring, or for the next re match.  ip and</TD></TR><TR><TD CLASS="l">582</TD><TD>     * matchlen must be reference variables (assumed to be arrays of</TD></TR><TR><TD CLASS="l">583</TD><TD>     * length 1) so they can be updated in the leading whitespace or</TD></TR><TR><TD CLASS="l">584</TD><TD>     * re case.</TD></TR><TR><TD CLASS="l">585</TD><TD>     *</TD></TR><TR><TD CLASS="l">586</TD><TD>     * Return -1 on end of string, &gt;= 0 for a valid index of the next</TD></TR><TR><TD CLASS="l">587</TD><TD>     * separator occurrence if found, or the string length if no</TD></TR><TR><TD CLASS="l">588</TD><TD>     * separator is found.</TD></TR><TR><TD CLASS="l">589</TD><TD>     */</TD></TR><TR><TD CLASS="l">590</TD><TD>    private static int find_split(Context cx, Scriptable scope, String target,</TD></TR><TR><TD CLASS="l">591</TD><TD>                                  String separator, int version,</TD></TR><TR><TD CLASS="l"><A NAME="2">592</A></TD><TD>                                  RegExpProxy reProxy, Scriptable re,</TD></TR><TR><TD CLASS="l">593</TD><TD>                                  int[] ip, int[] matchlen, boolean[] matched,</TD></TR><TR><TD CLASS="l">594</TD><TD>                                  String[][] parensp)</TD></TR><TR><TD CLASS="l">595</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">596</TD><TD>        int i = ip[0];</TD></TR><TR CLASS="c"><TD CLASS="l">597</TD><TD>        int length = target.length();</TD></TR><TR><TD CLASS="l">598</TD><TD> </TD></TR><TR><TD CLASS="l">599</TD><TD>        /*</TD></TR><TR><TD CLASS="l">600</TD><TD>         * Perl4 special case for str.split(' '), only if the user has selected</TD></TR><TR><TD CLASS="l">601</TD><TD>         * JavaScript1.2 explicitly.  Split on whitespace, and skip leading w/s.</TD></TR><TR><TD CLASS="l">602</TD><TD>         * Strange but true, apparently modeled after awk.</TD></TR><TR><TD CLASS="l">603</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">604</TD><TD>        if (version == Context.VERSION_1_2 &amp;&amp;</TD></TR><TR><TD CLASS="l">605</TD><TD>            re == null &amp;&amp; separator.length() == 1 &amp;&amp; separator.charAt(0) == ' ')</TD></TR><TR><TD CLASS="l">606</TD><TD>        {</TD></TR><TR><TD CLASS="l">607</TD><TD>            /* Skip leading whitespace if at front of str. */</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>            if (i == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>                while (i &lt; length &amp;&amp; Character.isWhitespace(target.charAt(i)))</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>                    i++;</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>                ip[0] = i;</TD></TR><TR><TD CLASS="l">612</TD><TD>            }</TD></TR><TR><TD CLASS="l">613</TD><TD> </TD></TR><TR><TD CLASS="l">614</TD><TD>            /* Don't delimit whitespace at end of string. */</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>            if (i == length)</TD></TR><TR CLASS="z"><TD CLASS="l">616</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">617</TD><TD> </TD></TR><TR><TD CLASS="l">618</TD><TD>            /* Skip over the non-whitespace chars. */</TD></TR><TR><TD CLASS="l">619</TD><TD>            while (i &lt; length</TD></TR><TR CLASS="z"><TD CLASS="l">620</TD><TD>                   &amp;&amp; !Character.isWhitespace(target.charAt(i)))</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>                i++;</TD></TR><TR><TD CLASS="l">622</TD><TD> </TD></TR><TR><TD CLASS="l">623</TD><TD>            /* Now skip the next run of whitespace. */</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>            int j = i;</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>            while (j &lt; length &amp;&amp; Character.isWhitespace(target.charAt(j)))</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                j++;</TD></TR><TR><TD CLASS="l">627</TD><TD> </TD></TR><TR><TD CLASS="l">628</TD><TD>            /* Update matchlen to count delimiter chars. */</TD></TR><TR CLASS="z"><TD CLASS="l">629</TD><TD>            matchlen[0] = j - i;</TD></TR><TR CLASS="z"><TD CLASS="l">630</TD><TD>            return i;</TD></TR><TR><TD CLASS="l">631</TD><TD>        }</TD></TR><TR><TD CLASS="l">632</TD><TD> </TD></TR><TR><TD CLASS="l">633</TD><TD>        /*</TD></TR><TR><TD CLASS="l">634</TD><TD>         * Stop if past end of string.  If at end of string, we will</TD></TR><TR><TD CLASS="l">635</TD><TD>         * return target length, so that</TD></TR><TR><TD CLASS="l">636</TD><TD>         *</TD></TR><TR><TD CLASS="l">637</TD><TD>         *  &#34;ab,&#34;.split(',') =&gt; new Array(&#34;ab&#34;, &#34;&#34;)</TD></TR><TR><TD CLASS="l">638</TD><TD>         *</TD></TR><TR><TD CLASS="l">639</TD><TD>         * and the resulting array converts back to the string &#34;ab,&#34;</TD></TR><TR><TD CLASS="l">640</TD><TD>         * for symmetry.  NB: This differs from perl, which drops the</TD></TR><TR><TD CLASS="l">641</TD><TD>         * trailing empty substring if the LIMIT argument is omitted.</TD></TR><TR><TD CLASS="l">642</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">643</TD><TD>        if (i &gt; length)</TD></TR><TR CLASS="c"><TD CLASS="l">644</TD><TD>            return -1;</TD></TR><TR><TD CLASS="l">645</TD><TD> </TD></TR><TR><TD CLASS="l">646</TD><TD>        /*</TD></TR><TR><TD CLASS="l">647</TD><TD>         * Match a regular expression against the separator at or</TD></TR><TR><TD CLASS="l">648</TD><TD>         * above index i.  Return -1 at end of string instead of</TD></TR><TR><TD CLASS="l">649</TD><TD>         * trying for a match, so we don't get stuck in a loop.</TD></TR><TR><TD CLASS="l">650</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">651</TD><TD>        if (re != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">652</TD><TD>            return reProxy.find_split(cx, scope, target, separator, re,</TD></TR><TR><TD CLASS="l">653</TD><TD>                                      ip, matchlen, matched, parensp);</TD></TR><TR><TD CLASS="l">654</TD><TD>        }</TD></TR><TR><TD CLASS="l">655</TD><TD> </TD></TR><TR><TD CLASS="l">656</TD><TD>        /*</TD></TR><TR><TD CLASS="l">657</TD><TD>         * Deviate from ECMA by never splitting an empty string by any separator</TD></TR><TR><TD CLASS="l">658</TD><TD>         * string into a non-empty array (an array of length 1 that contains the</TD></TR><TR><TD CLASS="l">659</TD><TD>         * empty string).</TD></TR><TR><TD CLASS="l">660</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">661</TD><TD>        if (version != Context.VERSION_DEFAULT &amp;&amp; version &lt; Context.VERSION_1_3</TD></TR><TR><TD CLASS="l">662</TD><TD>            &amp;&amp; length == 0)</TD></TR><TR CLASS="c"><TD CLASS="l">663</TD><TD>            return -1;</TD></TR><TR><TD CLASS="l">664</TD><TD> </TD></TR><TR><TD CLASS="l">665</TD><TD>        /*</TD></TR><TR><TD CLASS="l">666</TD><TD>         * Special case: if sep is the empty string, split str into</TD></TR><TR><TD CLASS="l">667</TD><TD>         * one character substrings.  Let our caller worry about</TD></TR><TR><TD CLASS="l">668</TD><TD>         * whether to split once at end of string into an empty</TD></TR><TR><TD CLASS="l">669</TD><TD>         * substring.</TD></TR><TR><TD CLASS="l">670</TD><TD>         *</TD></TR><TR><TD CLASS="l">671</TD><TD>         * For 1.2 compatibility, at the end of the string, we return the length as</TD></TR><TR><TD CLASS="l">672</TD><TD>         * the result, and set the separator length to 1 -- this allows the caller</TD></TR><TR><TD CLASS="l">673</TD><TD>         * to include an additional null string at the end of the substring list.</TD></TR><TR><TD CLASS="l">674</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">675</TD><TD>        if (separator.length() == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">676</TD><TD>            if (version == Context.VERSION_1_2) {</TD></TR><TR CLASS="z"><TD CLASS="l">677</TD><TD>                if (i == length) {</TD></TR><TR CLASS="z"><TD CLASS="l">678</TD><TD>                    matchlen[0] = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>                    return i;</TD></TR><TR><TD CLASS="l">680</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">681</TD><TD>                return i + 1;</TD></TR><TR><TD CLASS="l">682</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">683</TD><TD>            return (i == length) ? -1 : i + 1;</TD></TR><TR><TD CLASS="l">684</TD><TD>        }</TD></TR><TR><TD CLASS="l">685</TD><TD> </TD></TR><TR><TD CLASS="l">686</TD><TD>        /* Punt to j.l.s.indexOf; return target length if separator is</TD></TR><TR><TD CLASS="l">687</TD><TD>         * not found.</TD></TR><TR><TD CLASS="l">688</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">689</TD><TD>        if (ip[0] &gt;= length)</TD></TR><TR CLASS="c"><TD CLASS="l">690</TD><TD>            return length;</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">692</TD><TD>        i = target.indexOf(separator, ip[0]);</TD></TR><TR><TD CLASS="l">693</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">694</TD><TD>        return (i != -1) ? i : length;</TD></TR><TR><TD CLASS="l">695</TD><TD>    }</TD></TR><TR><TD CLASS="l">696</TD><TD> </TD></TR><TR><TD CLASS="l">697</TD><TD>    protected String          input;         /* input string to match (perl $_, GC root) */</TD></TR><TR><TD CLASS="l">698</TD><TD>    protected boolean         multiline;     /* whether input contains newlines (perl $*) */</TD></TR><TR><TD CLASS="l">699</TD><TD>    protected SubString[]     parens;        /* Vector of SubString; last set of parens</TD></TR><TR><TD CLASS="l">700</TD><TD>                                      matched (perl $1, $2) */</TD></TR><TR><TD CLASS="l">701</TD><TD>    protected SubString       lastMatch;     /* last string matched (perl $&amp;) */</TD></TR><TR><TD CLASS="l">702</TD><TD>    protected SubString       lastParen;     /* last paren matched (perl $+) */</TD></TR><TR><TD CLASS="l">703</TD><TD>    protected SubString       leftContext;   /* input to left of last match (perl $`) */</TD></TR><TR><TD CLASS="l"><A NAME="f">704</A></TD><TD>    protected SubString       rightContext;  /* input to right of last match (perl $') */</TD></TR><TR><TD CLASS="l">705</TD><TD>}</TD></TR><TR><TD CLASS="l">706</TD><TD> </TD></TR><TR><TD CLASS="l">707</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">708</TD><TD>final class GlobData</TD></TR><TR><TD CLASS="l">709</TD><TD>{</TD></TR><TR><TD CLASS="l">710</TD><TD>    int      mode;      /* input: return index, match object, or void */</TD></TR><TR><TD CLASS="l">711</TD><TD>    int      optarg;    /* input: index of optional flags argument */</TD></TR><TR><TD CLASS="l">712</TD><TD>    boolean  global;    /* output: whether regexp was global */</TD></TR><TR><TD CLASS="l">713</TD><TD>    String   str;       /* output: 'this' parameter object as string */</TD></TR><TR><TD CLASS="l">714</TD><TD> </TD></TR><TR><TD CLASS="l">715</TD><TD>    // match-specific data</TD></TR><TR><TD CLASS="l">716</TD><TD> </TD></TR><TR><TD CLASS="l">717</TD><TD>    Scriptable arrayobj;</TD></TR><TR><TD CLASS="l">718</TD><TD> </TD></TR><TR><TD CLASS="l">719</TD><TD>    // replace-specific data</TD></TR><TR><TD CLASS="l">720</TD><TD> </TD></TR><TR><TD CLASS="l">721</TD><TD>    Function      lambda;        /* replacement function object or null */</TD></TR><TR><TD CLASS="l">722</TD><TD>    String        repstr;        /* replacement string */</TD></TR><TR CLASS="c"><TD CLASS="l">723</TD><TD>    int           dollar = -1;   /* -1 or index of first $ in repstr */</TD></TR><TR><TD CLASS="l">724</TD><TD>    StringBuilder charBuf;       /* result characters, null initially */</TD></TR><TR><TD CLASS="l">725</TD><TD>    int           leftIndex;     /* leftContext index, always 0 for JS1.2 */</TD></TR><TR><TD CLASS="l">726</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="13.html">org.mozilla.javascript.regexp</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>