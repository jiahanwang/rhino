<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">DToA.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>DToA.java</TD><TD>100% (1/1)</TD><TD>88%  (14/16)</TD><TD CLASS="h">64%  (1577/2469)</TD><TD CLASS="h">63%  (362.2/576)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">DToA</A></TD><TD>100% (1/1)</TD><TD>88%  (14/16)</TD><TD CLASS="h">64%  (1577/2469)</TD><TD CLASS="h">63%  (362.2/576)</TD></TR><TR><TD CLASS="f"><A HREF="#1">BASEDIGIT (int): char</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">DToA (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3">JS_dtobasestr (int, double): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">14%  (47/325)</TD><TD CLASS="h">14%  (11.7/83)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">roundOff (StringBuilder): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">58%  (19/33)</TD><TD CLASS="h">73%  (8/11)</TD></TR><TR><TD CLASS="f"><A HREF="#5">JS_dtoa (double, int, boolean, int, boolean [], StringBuilder): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (882/1417)</TD><TD CLASS="h">63%  (216.1/343)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">hi0bits (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>85%  (44/52)</TD><TD>83%  (15/18)</TD></TR><TR><TD CLASS="f"><A HREF="#7">d2b (double, int [], int []): BigInteger</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>85%  (116/137)</TD><TD>93%  (27/29)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">JS_dtostr (StringBuilder, int, int, double): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (167/185)</TD><TD>90%  (39.6/44)</TD></TR><TR><TD CLASS="f"><A HREF="#9">stripTrailingZeroes (StringBuilder): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>94%  (17/18)</TD><TD>97%  (3.9/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">lo0bits (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>97%  (74/76)</TD><TD>96%  (25/26)</TD></TR><TR><TD CLASS="f"><A HREF="#b">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (142/142)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">pow5mult (BigInteger, int): BigInteger</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#d">setWord0 (double, int): double</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">stuffBits (byte [], int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (33/33)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#f">word0 (double): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">word1 (double): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</TD></TR><TR><TD CLASS="l">2</TD><TD> *</TD></TR><TR><TD CLASS="l">3</TD><TD> * This Source Code Form is subject to the terms of the Mozilla Public</TD></TR><TR><TD CLASS="l">4</TD><TD> * License, v. 2.0. If a copy of the MPL was not distributed with this</TD></TR><TR><TD CLASS="l">5</TD><TD> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</TD></TR><TR><TD CLASS="l">6</TD><TD> </TD></TR><TR><TD CLASS="l">7</TD><TD>/****************************************************************</TD></TR><TR><TD CLASS="l">8</TD><TD>  *</TD></TR><TR><TD CLASS="l">9</TD><TD>  * The author of this software is David M. Gay.</TD></TR><TR><TD CLASS="l">10</TD><TD>  *</TD></TR><TR><TD CLASS="l">11</TD><TD>  * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.</TD></TR><TR><TD CLASS="l">12</TD><TD>  *</TD></TR><TR><TD CLASS="l">13</TD><TD>  * Permission to use, copy, modify, and distribute this software for any</TD></TR><TR><TD CLASS="l">14</TD><TD>  * purpose without fee is hereby granted, provided that this entire notice</TD></TR><TR><TD CLASS="l">15</TD><TD>  * is included in all copies of any software which is or includes a copy</TD></TR><TR><TD CLASS="l">16</TD><TD>  * or modification of this software and in all copies of the supporting</TD></TR><TR><TD CLASS="l">17</TD><TD>  * documentation for such software.</TD></TR><TR><TD CLASS="l">18</TD><TD>  *</TD></TR><TR><TD CLASS="l">19</TD><TD>  * THIS SOFTWARE IS BEING PROVIDED &#34;AS IS&#34;, WITHOUT ANY EXPRESS OR IMPLIED</TD></TR><TR><TD CLASS="l">20</TD><TD>  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY</TD></TR><TR><TD CLASS="l">21</TD><TD>  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</TD></TR><TR><TD CLASS="l">22</TD><TD>  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</TD></TR><TR><TD CLASS="l">23</TD><TD>  *</TD></TR><TR><TD CLASS="l">24</TD><TD>  ***************************************************************/</TD></TR><TR><TD CLASS="l">25</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="0">26</A></TD><TD>package org.mozilla.javascript;</TD></TR><TR><TD CLASS="l">27</TD><TD> </TD></TR><TR><TD CLASS="l">28</TD><TD>import java.math.BigInteger;</TD></TR><TR><TD CLASS="l">29</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1">30</A></TD><TD>class DToA {</TD></TR><TR><TD CLASS="l">31</TD><TD> </TD></TR><TR><TD CLASS="l">32</TD><TD> </TD></TR><TR><TD CLASS="l">33</TD><TD>    private static char BASEDIGIT(int digit) {</TD></TR><TR CLASS="z"><TD CLASS="l">34</TD><TD>        return (char)((digit &gt;= 10) ? 'a' - 10 + digit : '0' + digit);</TD></TR><TR><TD CLASS="l">35</TD><TD>    }</TD></TR><TR><TD CLASS="l">36</TD><TD> </TD></TR><TR><TD CLASS="l">37</TD><TD>    static final int</TD></TR><TR><TD CLASS="l">38</TD><TD>        DTOSTR_STANDARD = 0,              /* Either fixed or exponential format; round-trip */</TD></TR><TR><TD CLASS="l">39</TD><TD>        DTOSTR_STANDARD_EXPONENTIAL = 1,  /* Always exponential format; round-trip */</TD></TR><TR><TD CLASS="l">40</TD><TD>        DTOSTR_FIXED = 2,                 /* Round to &lt;precision&gt; digits after the decimal point; exponential if number is large */</TD></TR><TR><TD CLASS="l">41</TD><TD>        DTOSTR_EXPONENTIAL = 3,           /* Always exponential format; &lt;precision&gt; significant digits */</TD></TR><TR><TD CLASS="l">42</TD><TD>        DTOSTR_PRECISION = 4;             /* Either fixed or exponential format; &lt;precision&gt; significant digits */</TD></TR><TR><TD CLASS="l">43</TD><TD> </TD></TR><TR><TD CLASS="l">44</TD><TD> </TD></TR><TR><TD CLASS="l">45</TD><TD>    private static final int Frac_mask = 0xfffff;</TD></TR><TR><TD CLASS="l">46</TD><TD>    private static final int Exp_shift = 20;</TD></TR><TR><TD CLASS="l">47</TD><TD>    private static final int Exp_msk1 = 0x100000;</TD></TR><TR><TD CLASS="l">48</TD><TD> </TD></TR><TR><TD CLASS="l">49</TD><TD>    private static final long Frac_maskL = 0xfffffffffffffL;</TD></TR><TR><TD CLASS="l">50</TD><TD>    private static final int Exp_shiftL = 52;</TD></TR><TR><TD CLASS="l">51</TD><TD>    private static final long Exp_msk1L = 0x10000000000000L;</TD></TR><TR><TD CLASS="l">52</TD><TD> </TD></TR><TR><TD CLASS="l">53</TD><TD>    private static final int Bias = 1023;</TD></TR><TR><TD CLASS="l">54</TD><TD>    private static final int P = 53;</TD></TR><TR><TD CLASS="l">55</TD><TD> </TD></TR><TR><TD CLASS="l">56</TD><TD>    private static final int Exp_shift1 = 20;</TD></TR><TR><TD CLASS="l">57</TD><TD>    private static final int Exp_mask  = 0x7ff00000;</TD></TR><TR><TD CLASS="l">58</TD><TD>    private static final int Exp_mask_shifted = 0x7ff;</TD></TR><TR><TD CLASS="l">59</TD><TD>    private static final int Bndry_mask  = 0xfffff;</TD></TR><TR><TD CLASS="l">60</TD><TD>    private static final int Log2P = 1;</TD></TR><TR><TD CLASS="l">61</TD><TD> </TD></TR><TR><TD CLASS="l">62</TD><TD>    private static final int Sign_bit = 0x80000000;</TD></TR><TR><TD CLASS="l">63</TD><TD>    private static final int Exp_11  = 0x3ff00000;</TD></TR><TR><TD CLASS="l">64</TD><TD>    private static final int Ten_pmax = 22;</TD></TR><TR><TD CLASS="l">65</TD><TD>    private static final int Quick_max = 14;</TD></TR><TR><TD CLASS="l">66</TD><TD>    private static final int Bletch = 0x10;</TD></TR><TR><TD CLASS="l">67</TD><TD>    private static final int Frac_mask1 = 0xfffff;</TD></TR><TR><TD CLASS="l"><A NAME="b">68</A></TD><TD>    private static final int Int_max = 14;</TD></TR><TR><TD CLASS="l">69</TD><TD>    private static final int n_bigtens = 5;</TD></TR><TR><TD CLASS="l">70</TD><TD> </TD></TR><TR><TD CLASS="l">71</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">72</TD><TD>    private static final double tens[] = {</TD></TR><TR><TD CLASS="l">73</TD><TD>        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,</TD></TR><TR><TD CLASS="l">74</TD><TD>        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,</TD></TR><TR><TD CLASS="l">75</TD><TD>        1e20, 1e21, 1e22</TD></TR><TR><TD CLASS="l">76</TD><TD>    };</TD></TR><TR><TD CLASS="l">77</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">78</TD><TD>    private static final double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };</TD></TR><TR><TD CLASS="l"><A NAME="a">79</A></TD><TD> </TD></TR><TR><TD CLASS="l">80</TD><TD>    private static int lo0bits(int y)</TD></TR><TR><TD CLASS="l">81</TD><TD>    {</TD></TR><TR><TD CLASS="l">82</TD><TD>        int k;</TD></TR><TR CLASS="c"><TD CLASS="l">83</TD><TD>        int x = y;</TD></TR><TR><TD CLASS="l">84</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">85</TD><TD>        if ((x &amp; 7) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">86</TD><TD>            if ((x &amp; 1) != 0)</TD></TR><TR CLASS="c"><TD CLASS="l">87</TD><TD>                return 0;</TD></TR><TR CLASS="c"><TD CLASS="l">88</TD><TD>            if ((x &amp; 2) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">89</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">90</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">91</TD><TD>            return 2;</TD></TR><TR><TD CLASS="l">92</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">93</TD><TD>        k = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">94</TD><TD>        if ((x &amp; 0xffff) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">95</TD><TD>            k = 16;</TD></TR><TR CLASS="c"><TD CLASS="l">96</TD><TD>            x &gt;&gt;&gt;= 16;</TD></TR><TR><TD CLASS="l">97</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">98</TD><TD>        if ((x &amp; 0xff) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">99</TD><TD>            k += 8;</TD></TR><TR CLASS="c"><TD CLASS="l">100</TD><TD>            x &gt;&gt;&gt;= 8;</TD></TR><TR><TD CLASS="l">101</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">102</TD><TD>        if ((x &amp; 0xf) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">103</TD><TD>            k += 4;</TD></TR><TR CLASS="c"><TD CLASS="l">104</TD><TD>            x &gt;&gt;&gt;= 4;</TD></TR><TR><TD CLASS="l">105</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">106</TD><TD>        if ((x &amp; 0x3) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">107</TD><TD>            k += 2;</TD></TR><TR CLASS="c"><TD CLASS="l">108</TD><TD>            x &gt;&gt;&gt;= 2;</TD></TR><TR><TD CLASS="l">109</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">110</TD><TD>        if ((x &amp; 1) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">111</TD><TD>            k++;</TD></TR><TR CLASS="c"><TD CLASS="l">112</TD><TD>            x &gt;&gt;&gt;= 1;</TD></TR><TR CLASS="c"><TD CLASS="l">113</TD><TD>            if ((x &amp; 1) == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>                return 32;</TD></TR><TR><TD CLASS="l">115</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">116</TD><TD>        return k;</TD></TR><TR><TD CLASS="l">117</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="6">118</A></TD><TD> </TD></TR><TR><TD CLASS="l">119</TD><TD>    /* Return the number (0 through 32) of most significant zero bits in x. */</TD></TR><TR><TD CLASS="l">120</TD><TD>    private static int hi0bits(int x)</TD></TR><TR><TD CLASS="l">121</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">122</TD><TD>        int k = 0;</TD></TR><TR><TD CLASS="l">123</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">124</TD><TD>        if ((x &amp; 0xffff0000) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">125</TD><TD>            k = 16;</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>            x &lt;&lt;= 16;</TD></TR><TR><TD CLASS="l">127</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">128</TD><TD>        if ((x &amp; 0xff000000) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">129</TD><TD>            k += 8;</TD></TR><TR CLASS="c"><TD CLASS="l">130</TD><TD>            x &lt;&lt;= 8;</TD></TR><TR><TD CLASS="l">131</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">132</TD><TD>        if ((x &amp; 0xf0000000) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">133</TD><TD>            k += 4;</TD></TR><TR CLASS="c"><TD CLASS="l">134</TD><TD>            x &lt;&lt;= 4;</TD></TR><TR><TD CLASS="l">135</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">136</TD><TD>        if ((x &amp; 0xc0000000) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">137</TD><TD>            k += 2;</TD></TR><TR CLASS="c"><TD CLASS="l">138</TD><TD>            x &lt;&lt;= 2;</TD></TR><TR><TD CLASS="l">139</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">140</TD><TD>        if ((x &amp; 0x80000000) == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">141</TD><TD>            k++;</TD></TR><TR CLASS="c"><TD CLASS="l">142</TD><TD>            if ((x &amp; 0x40000000) == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>                return 32;</TD></TR><TR><TD CLASS="l">144</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">145</TD><TD>        return k;</TD></TR><TR><TD CLASS="l"><A NAME="e">146</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">147</TD><TD> </TD></TR><TR><TD CLASS="l">148</TD><TD>    private static void stuffBits(byte bits[], int offset, int val)</TD></TR><TR><TD CLASS="l">149</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">150</TD><TD>        bits[offset] = (byte)(val &gt;&gt; 24);</TD></TR><TR CLASS="c"><TD CLASS="l">151</TD><TD>        bits[offset + 1] = (byte)(val &gt;&gt; 16);</TD></TR><TR CLASS="c"><TD CLASS="l">152</TD><TD>        bits[offset + 2] = (byte)(val &gt;&gt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">153</TD><TD>        bits[offset + 3] = (byte)(val);</TD></TR><TR CLASS="c"><TD CLASS="l">154</TD><TD>    }</TD></TR><TR><TD CLASS="l">155</TD><TD> </TD></TR><TR><TD CLASS="l">156</TD><TD>    /* Convert d into the form b*2^e, where b is an odd integer.  b is the returned</TD></TR><TR><TD CLASS="l">157</TD><TD>     * Bigint and e is the returned binary exponent.  Return the number of significant</TD></TR><TR><TD CLASS="l">158</TD><TD>     * bits in b in bits.  d must be finite and nonzero. */</TD></TR><TR><TD CLASS="l"><A NAME="7">159</A></TD><TD>    private static BigInteger d2b(double d, int[] e, int[] bits)</TD></TR><TR><TD CLASS="l">160</TD><TD>    {</TD></TR><TR><TD CLASS="l">161</TD><TD>        byte dbl_bits[];</TD></TR><TR><TD CLASS="l">162</TD><TD>        int i, k, y, z, de;</TD></TR><TR CLASS="c"><TD CLASS="l">163</TD><TD>        long dBits = Double.doubleToLongBits(d);</TD></TR><TR CLASS="c"><TD CLASS="l">164</TD><TD>        int d0 = (int)(dBits &gt;&gt;&gt; 32);</TD></TR><TR CLASS="c"><TD CLASS="l">165</TD><TD>        int d1 = (int)(dBits);</TD></TR><TR><TD CLASS="l">166</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">167</TD><TD>        z = d0 &amp; Frac_mask;</TD></TR><TR CLASS="c"><TD CLASS="l">168</TD><TD>        d0 &amp;= 0x7fffffff;   /* clear sign bit, which we ignore */</TD></TR><TR><TD CLASS="l">169</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">170</TD><TD>        if ((de = (d0 &gt;&gt;&gt; Exp_shift)) != 0)</TD></TR><TR CLASS="c"><TD CLASS="l">171</TD><TD>            z |= Exp_msk1;</TD></TR><TR><TD CLASS="l">172</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">173</TD><TD>        if ((y = d1) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">174</TD><TD>            dbl_bits = new byte[8];</TD></TR><TR CLASS="c"><TD CLASS="l">175</TD><TD>            k = lo0bits(y);</TD></TR><TR CLASS="c"><TD CLASS="l">176</TD><TD>            y &gt;&gt;&gt;= k;</TD></TR><TR CLASS="c"><TD CLASS="l">177</TD><TD>            if (k != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">178</TD><TD>                stuffBits(dbl_bits, 4, y | z &lt;&lt; (32 - k));</TD></TR><TR CLASS="c"><TD CLASS="l">179</TD><TD>                z &gt;&gt;= k;</TD></TR><TR><TD CLASS="l">180</TD><TD>            }</TD></TR><TR><TD CLASS="l">181</TD><TD>            else</TD></TR><TR CLASS="c"><TD CLASS="l">182</TD><TD>                stuffBits(dbl_bits, 4, y);</TD></TR><TR CLASS="c"><TD CLASS="l">183</TD><TD>            stuffBits(dbl_bits, 0, z);</TD></TR><TR CLASS="c"><TD CLASS="l">184</TD><TD>            i = (z != 0) ? 2 : 1;</TD></TR><TR><TD CLASS="l">185</TD><TD>        }</TD></TR><TR><TD CLASS="l">186</TD><TD>        else {</TD></TR><TR><TD CLASS="l">187</TD><TD>    //        JS_ASSERT(z);</TD></TR><TR CLASS="c"><TD CLASS="l">188</TD><TD>            dbl_bits = new byte[4];</TD></TR><TR CLASS="c"><TD CLASS="l">189</TD><TD>            k = lo0bits(z);</TD></TR><TR CLASS="c"><TD CLASS="l">190</TD><TD>            z &gt;&gt;&gt;= k;</TD></TR><TR CLASS="c"><TD CLASS="l">191</TD><TD>            stuffBits(dbl_bits, 0, z);</TD></TR><TR CLASS="c"><TD CLASS="l">192</TD><TD>            k += 32;</TD></TR><TR CLASS="c"><TD CLASS="l">193</TD><TD>            i = 1;</TD></TR><TR><TD CLASS="l">194</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">195</TD><TD>        if (de != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">196</TD><TD>            e[0] = de - Bias - (P-1) + k;</TD></TR><TR CLASS="c"><TD CLASS="l">197</TD><TD>            bits[0] = P - k;</TD></TR><TR><TD CLASS="l">198</TD><TD>        }</TD></TR><TR><TD CLASS="l">199</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>            e[0] = de - Bias - (P-1) + 1 + k;</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>            bits[0] = 32*i - hi0bits(z);</TD></TR><TR><TD CLASS="l">202</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">203</TD><TD>        return new BigInteger(dbl_bits);</TD></TR><TR><TD CLASS="l"><A NAME="3">204</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">205</TD><TD> </TD></TR><TR><TD CLASS="l">206</TD><TD>    static String JS_dtobasestr(int base, double d)</TD></TR><TR><TD CLASS="l">207</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">208</TD><TD>        if (!(2 &lt;= base &amp;&amp; base &lt;= 36))</TD></TR><TR CLASS="z"><TD CLASS="l">209</TD><TD>            throw new IllegalArgumentException(&#34;Bad base: &#34;+base);</TD></TR><TR><TD CLASS="l">210</TD><TD> </TD></TR><TR><TD CLASS="l">211</TD><TD>        /* Check for Infinity and NaN */</TD></TR><TR CLASS="c"><TD CLASS="l">212</TD><TD>        if (Double.isNaN(d)) {</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>            return &#34;NaN&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">214</TD><TD>        } else if (Double.isInfinite(d)) {</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>            return (d &gt; 0.0) ? &#34;Infinity&#34; : &#34;-Infinity&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">216</TD><TD>        } else if (d == 0) {</TD></TR><TR><TD CLASS="l">217</TD><TD>            // ALERT: should it distinguish -0.0 from +0.0 ?</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>            return &#34;0&#34;;</TD></TR><TR><TD CLASS="l">219</TD><TD>        }</TD></TR><TR><TD CLASS="l">220</TD><TD> </TD></TR><TR><TD CLASS="l">221</TD><TD>        boolean negative;</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>        if (d &gt;= 0.0) {</TD></TR><TR CLASS="c"><TD CLASS="l">223</TD><TD>            negative = false;</TD></TR><TR><TD CLASS="l">224</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>            negative = true;</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>            d = -d;</TD></TR><TR><TD CLASS="l">227</TD><TD>        }</TD></TR><TR><TD CLASS="l">228</TD><TD> </TD></TR><TR><TD CLASS="l">229</TD><TD>        /* Get the integer part of d including '-' sign. */</TD></TR><TR><TD CLASS="l">230</TD><TD>        String intDigits;</TD></TR><TR><TD CLASS="l">231</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">232</TD><TD>        double dfloor = Math.floor(d);</TD></TR><TR CLASS="c"><TD CLASS="l">233</TD><TD>        long lfloor = (long)dfloor;</TD></TR><TR CLASS="c"><TD CLASS="l">234</TD><TD>        if (lfloor == dfloor) {</TD></TR><TR><TD CLASS="l">235</TD><TD>            // int part fits long</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="70% line coverage (7 out of 10 instructions)">236</TD><TD TITLE="70% line coverage (7 out of 10 instructions)">            intDigits = Long.toString((negative) ? -lfloor : lfloor, base);</TD></TR><TR><TD CLASS="l">237</TD><TD>        } else {</TD></TR><TR><TD CLASS="l">238</TD><TD>            // BigInteger should be used</TD></TR><TR CLASS="z"><TD CLASS="l">239</TD><TD>            long floorBits = Double.doubleToLongBits(dfloor);</TD></TR><TR CLASS="z"><TD CLASS="l">240</TD><TD>            int exp = (int)(floorBits &gt;&gt; Exp_shiftL) &amp; Exp_mask_shifted;</TD></TR><TR><TD CLASS="l">241</TD><TD>            long mantissa;</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>            if (exp == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>                mantissa = (floorBits &amp; Frac_maskL) &lt;&lt; 1;</TD></TR><TR><TD CLASS="l">244</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                mantissa = (floorBits &amp; Frac_maskL) | Exp_msk1L;</TD></TR><TR><TD CLASS="l">246</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>            if (negative) {</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                mantissa = -mantissa;</TD></TR><TR><TD CLASS="l">249</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>            exp -= 1075;</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>            BigInteger x = BigInteger.valueOf(mantissa);</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>            if (exp &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>                x = x.shiftLeft(exp);</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>            } else if (exp &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                x = x.shiftRight(-exp);</TD></TR><TR><TD CLASS="l">256</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>            intDigits = x.toString(base);</TD></TR><TR><TD CLASS="l">258</TD><TD>        }</TD></TR><TR><TD CLASS="l">259</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">260</TD><TD>        if (d == dfloor) {</TD></TR><TR><TD CLASS="l">261</TD><TD>            // No fraction part</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>            return intDigits;</TD></TR><TR><TD CLASS="l">263</TD><TD>        } else {</TD></TR><TR><TD CLASS="l">264</TD><TD>            /* We have a fraction. */</TD></TR><TR><TD CLASS="l">265</TD><TD> </TD></TR><TR><TD CLASS="l">266</TD><TD>            StringBuilder buffer;       /* The output string */</TD></TR><TR><TD CLASS="l">267</TD><TD>            int digit;</TD></TR><TR><TD CLASS="l">268</TD><TD>            double df;           /* The fractional part of d */</TD></TR><TR><TD CLASS="l">269</TD><TD>            BigInteger b;</TD></TR><TR><TD CLASS="l">270</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>            buffer = new StringBuilder();</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>            buffer.append(intDigits).append('.');</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>            df = d - dfloor;</TD></TR><TR><TD CLASS="l">274</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>            long dBits = Double.doubleToLongBits(d);</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>            int word0 = (int)(dBits &gt;&gt; 32);</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>            int word1 = (int)(dBits);</TD></TR><TR><TD CLASS="l">278</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>            int[] e = new int[1];</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>            int[] bbits = new int[1];</TD></TR><TR><TD CLASS="l">281</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>            b = d2b(df, e, bbits);</TD></TR><TR><TD CLASS="l">283</TD><TD>//            JS_ASSERT(e &lt; 0);</TD></TR><TR><TD CLASS="l">284</TD><TD>            /* At this point df = b * 2^e.  e must be less than zero because 0 &lt; df &lt; 1. */</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>            int s2 = -(word0 &gt;&gt;&gt; Exp_shift1 &amp; Exp_mask &gt;&gt; Exp_shift1);</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>            if (s2 == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>                s2 = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>            s2 += Bias + P;</TD></TR><TR><TD CLASS="l">290</TD><TD>            /* 1/2^s2 = (nextDouble(d) - d)/2 */</TD></TR><TR><TD CLASS="l">291</TD><TD>//            JS_ASSERT(-s2 &lt; e);</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>            BigInteger mlo = BigInteger.valueOf(1);</TD></TR><TR CLASS="z"><TD CLASS="l">293</TD><TD>            BigInteger mhi = mlo;</TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>            if ((word1 == 0) &amp;&amp; ((word0 &amp; Bndry_mask) == 0)</TD></TR><TR><TD CLASS="l">295</TD><TD>                &amp;&amp; ((word0 &amp; (Exp_mask &amp; Exp_mask &lt;&lt; 1)) != 0)) {</TD></TR><TR><TD CLASS="l">296</TD><TD>                /* The special case.  Here we want to be within a quarter of the last input</TD></TR><TR><TD CLASS="l">297</TD><TD>                   significant digit instead of one half of it when the output string's value is less than d.  */</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                s2 += Log2P;</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                mhi = BigInteger.valueOf(1&lt;&lt;Log2P);</TD></TR><TR><TD CLASS="l">300</TD><TD>            }</TD></TR><TR><TD CLASS="l">301</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">302</TD><TD>            b = b.shiftLeft(e[0] + s2);</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>            BigInteger s = BigInteger.valueOf(1);</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>            s = s.shiftLeft(s2);</TD></TR><TR><TD CLASS="l">305</TD><TD>            /* At this point we have the following:</TD></TR><TR><TD CLASS="l">306</TD><TD>             *   s = 2^s2;</TD></TR><TR><TD CLASS="l">307</TD><TD>             *   1 &gt; df = b/2^s2 &gt; 0;</TD></TR><TR><TD CLASS="l">308</TD><TD>             *   (d - prevDouble(d))/2 = mlo/2^s2;</TD></TR><TR><TD CLASS="l">309</TD><TD>             *   (nextDouble(d) - d)/2 = mhi/2^s2. */</TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>            BigInteger bigBase = BigInteger.valueOf(base);</TD></TR><TR><TD CLASS="l">311</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>            boolean done = false;</TD></TR><TR><TD CLASS="l">313</TD><TD>            do {</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                b = b.multiply(bigBase);</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                BigInteger[] divResult = b.divideAndRemainder(s);</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>                b = divResult[1];</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                digit = (char)(divResult[0].intValue());</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>                if (mlo == mhi)</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                    mlo = mhi = mlo.multiply(bigBase);</TD></TR><TR><TD CLASS="l">320</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                    mlo = mlo.multiply(bigBase);</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>                    mhi = mhi.multiply(bigBase);</TD></TR><TR><TD CLASS="l">323</TD><TD>                }</TD></TR><TR><TD CLASS="l">324</TD><TD> </TD></TR><TR><TD CLASS="l">325</TD><TD>                /* Do we yet have the shortest string that will round to d? */</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                int j = b.compareTo(mlo);</TD></TR><TR><TD CLASS="l">327</TD><TD>                /* j is b/2^s2 compared with mlo/2^s2. */</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                BigInteger delta = s.subtract(mhi);</TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                int j1 = (delta.signum() &lt;= 0) ? 1 : b.compareTo(delta);</TD></TR><TR><TD CLASS="l">330</TD><TD>                /* j1 is b/2^s2 compared with 1 - mhi/2^s2. */</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                if (j1 == 0 &amp;&amp; ((word1 &amp; 1) == 0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                    if (j &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                        digit++;</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                    done = true;</TD></TR><TR><TD CLASS="l">335</TD><TD>                } else</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                if (j &lt; 0 || (j == 0 &amp;&amp; ((word1 &amp; 1) == 0))) {</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                    if (j1 &gt; 0) {</TD></TR><TR><TD CLASS="l">338</TD><TD>                        /* Either dig or dig+1 would work here as the least significant digit.</TD></TR><TR><TD CLASS="l">339</TD><TD>                           Use whichever would produce an output value closer to d. */</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                        b = b.shiftLeft(1);</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>                        j1 = b.compareTo(s);</TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                        if (j1 &gt; 0) /* The even test (|| (j1 == 0 &amp;&amp; (digit &amp; 1))) is not here because it messes up odd base output</TD></TR><TR><TD CLASS="l">343</TD><TD>                                     * such as 3.5 in base 3.  */</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                            digit++;</TD></TR><TR><TD CLASS="l">345</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">346</TD><TD>                    done = true;</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                } else if (j1 &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                    digit++;</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                    done = true;</TD></TR><TR><TD CLASS="l">350</TD><TD>                }</TD></TR><TR><TD CLASS="l">351</TD><TD>//                JS_ASSERT(digit &lt; (uint32)base);</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                buffer.append(BASEDIGIT(digit));</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>            } while (!done);</TD></TR><TR><TD CLASS="l">354</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>            return buffer.toString();</TD></TR><TR><TD CLASS="l">356</TD><TD>        }</TD></TR><TR><TD CLASS="l">357</TD><TD> </TD></TR><TR><TD CLASS="l">358</TD><TD>    }</TD></TR><TR><TD CLASS="l">359</TD><TD> </TD></TR><TR><TD CLASS="l">360</TD><TD>    /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.</TD></TR><TR><TD CLASS="l">361</TD><TD>     *</TD></TR><TR><TD CLASS="l">362</TD><TD>     * Inspired by &#34;How to Print Floating-Point Numbers Accurately&#34; by</TD></TR><TR><TD CLASS="l">363</TD><TD>     * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].</TD></TR><TR><TD CLASS="l">364</TD><TD>     *</TD></TR><TR><TD CLASS="l">365</TD><TD>     * Modifications:</TD></TR><TR><TD CLASS="l">366</TD><TD>     *  1. Rather than iterating, we use a simple numeric overestimate</TD></TR><TR><TD CLASS="l">367</TD><TD>     *     to determine k = floor(log10(d)).  We scale relevant</TD></TR><TR><TD CLASS="l">368</TD><TD>     *     quantities using O(log2(k)) rather than O(k) multiplications.</TD></TR><TR><TD CLASS="l">369</TD><TD>     *  2. For some modes &gt; 2 (corresponding to ecvt and fcvt), we don't</TD></TR><TR><TD CLASS="l">370</TD><TD>     *     try to generate digits strictly left to right.  Instead, we</TD></TR><TR><TD CLASS="l">371</TD><TD>     *     compute with fewer bits and propagate the carry if necessary</TD></TR><TR><TD CLASS="l">372</TD><TD>     *     when rounding the final digit up.  This is often faster.</TD></TR><TR><TD CLASS="l">373</TD><TD>     *  3. Under the assumption that input will be rounded nearest,</TD></TR><TR><TD CLASS="l">374</TD><TD>     *     mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.</TD></TR><TR><TD CLASS="l">375</TD><TD>     *     That is, we allow equality in stopping tests when the</TD></TR><TR><TD CLASS="l">376</TD><TD>     *     round-nearest rule will give the same floating-point value</TD></TR><TR><TD CLASS="l">377</TD><TD>     *     as would satisfaction of the stopping test with strict</TD></TR><TR><TD CLASS="l">378</TD><TD>     *     inequality.</TD></TR><TR><TD CLASS="l">379</TD><TD>     *  4. We remove common factors of powers of 2 from relevant</TD></TR><TR><TD CLASS="l">380</TD><TD>     *     quantities.</TD></TR><TR><TD CLASS="l">381</TD><TD>     *  5. When converting floating-point integers less than 1e16,</TD></TR><TR><TD CLASS="l">382</TD><TD>     *     we use floating-point arithmetic rather than resorting</TD></TR><TR><TD CLASS="l">383</TD><TD>     *     to multiple-precision integers.</TD></TR><TR><TD CLASS="l">384</TD><TD>     *  6. When asked to produce fewer than 15 digits, we first try</TD></TR><TR><TD CLASS="l">385</TD><TD>     *     to get by with floating-point arithmetic; we resort to</TD></TR><TR><TD CLASS="l">386</TD><TD>     *     multiple-precision integer arithmetic only if we cannot</TD></TR><TR><TD CLASS="l">387</TD><TD>     *     guarantee that the floating-point calculation has given</TD></TR><TR><TD CLASS="l">388</TD><TD>     *     the correctly rounded result.  For k requested digits and</TD></TR><TR><TD CLASS="l">389</TD><TD>     *     &#34;uniformly&#34; distributed input, the probability is</TD></TR><TR><TD CLASS="l">390</TD><TD>     *     something like 10^(k-15) that we must resort to the Long</TD></TR><TR><TD CLASS="l">391</TD><TD>     *     calculation.</TD></TR><TR><TD CLASS="l"><A NAME="f">392</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">393</TD><TD> </TD></TR><TR><TD CLASS="l">394</TD><TD>    static int word0(double d)</TD></TR><TR><TD CLASS="l">395</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">396</TD><TD>        long dBits = Double.doubleToLongBits(d);</TD></TR><TR CLASS="c"><TD CLASS="l">397</TD><TD>        return (int)(dBits &gt;&gt; 32);</TD></TR><TR><TD CLASS="l"><A NAME="d">398</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">399</TD><TD> </TD></TR><TR><TD CLASS="l">400</TD><TD>    static double setWord0(double d, int i)</TD></TR><TR><TD CLASS="l">401</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">402</TD><TD>        long dBits = Double.doubleToLongBits(d);</TD></TR><TR CLASS="c"><TD CLASS="l">403</TD><TD>        dBits = ((long)i &lt;&lt; 32) | (dBits &amp; 0x0FFFFFFFFL);</TD></TR><TR CLASS="c"><TD CLASS="l">404</TD><TD>        return Double.longBitsToDouble(dBits);</TD></TR><TR><TD CLASS="l"><A NAME="10">405</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR><TD CLASS="l">407</TD><TD>    static int word1(double d)</TD></TR><TR><TD CLASS="l">408</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">409</TD><TD>        long dBits = Double.doubleToLongBits(d);</TD></TR><TR CLASS="c"><TD CLASS="l">410</TD><TD>        return (int)(dBits);</TD></TR><TR><TD CLASS="l">411</TD><TD>    }</TD></TR><TR><TD CLASS="l">412</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="c">413</A></TD><TD>    /* Return b * 5^k.  k must be nonnegative. */</TD></TR><TR><TD CLASS="l">414</TD><TD>    // XXXX the C version built a cache of these</TD></TR><TR><TD CLASS="l">415</TD><TD>    static BigInteger pow5mult(BigInteger b, int k)</TD></TR><TR><TD CLASS="l">416</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">417</TD><TD>        return b.multiply(BigInteger.valueOf(5).pow(k));</TD></TR><TR><TD CLASS="l"><A NAME="4">418</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">419</TD><TD> </TD></TR><TR><TD CLASS="l">420</TD><TD>    static boolean roundOff(StringBuilder buf)</TD></TR><TR><TD CLASS="l">421</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">422</TD><TD>        int i = buf.length();</TD></TR><TR CLASS="c"><TD CLASS="l">423</TD><TD>        while (i != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>            --i;</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>            char c = buf.charAt(i);</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>            if (c != '9') {</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>                buf.setCharAt(i, (char)(c + 1));</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>                buf.setLength(i + 1);</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">430</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">432</TD><TD>        buf.setLength(0);</TD></TR><TR CLASS="c"><TD CLASS="l">433</TD><TD>        return true;</TD></TR><TR><TD CLASS="l">434</TD><TD>    }</TD></TR><TR><TD CLASS="l">435</TD><TD> </TD></TR><TR><TD CLASS="l">436</TD><TD>    /* Always emits at least one digit. */</TD></TR><TR><TD CLASS="l">437</TD><TD>    /* If biasUp is set, then rounding in modes 2 and 3 will round away from zero</TD></TR><TR><TD CLASS="l">438</TD><TD>     * when the number is exactly halfway between two representable values.  For example,</TD></TR><TR><TD CLASS="l">439</TD><TD>     * rounding 2.5 to zero digits after the decimal point will return 3 and not 2.</TD></TR><TR><TD CLASS="l">440</TD><TD>     * 2.49 will still round to 2, and 2.51 will still round to 3. */</TD></TR><TR><TD CLASS="l">441</TD><TD>    /* bufsize should be at least 20 for modes 0 and 1.  For the other modes,</TD></TR><TR><TD CLASS="l">442</TD><TD>     * bufsize should be two greater than the maximum number of output characters expected. */</TD></TR><TR><TD CLASS="l">443</TD><TD>    static int</TD></TR><TR><TD CLASS="l">444</TD><TD>    JS_dtoa(double d, int mode, boolean biasUp, int ndigits,</TD></TR><TR><TD CLASS="l">445</TD><TD>                    boolean[] sign, StringBuilder buf)</TD></TR><TR><TD CLASS="l">446</TD><TD>    {</TD></TR><TR><TD CLASS="l">447</TD><TD>        /*  Arguments ndigits, decpt, sign are similar to those</TD></TR><TR><TD CLASS="l">448</TD><TD>            of ecvt and fcvt; trailing zeros are suppressed from</TD></TR><TR><TD CLASS="l">449</TD><TD>            the returned string.  If not null, *rve is set to point</TD></TR><TR><TD CLASS="l">450</TD><TD>            to the end of the return value.  If d is +-Infinity or NaN,</TD></TR><TR><TD CLASS="l">451</TD><TD>            then *decpt is set to 9999.</TD></TR><TR><TD CLASS="l">452</TD><TD> </TD></TR><TR><TD CLASS="l">453</TD><TD>            mode:</TD></TR><TR><TD CLASS="l">454</TD><TD>            0 ==&gt; shortest string that yields d when read in</TD></TR><TR><TD CLASS="l">455</TD><TD>            and rounded to nearest.</TD></TR><TR><TD CLASS="l">456</TD><TD>            1 ==&gt; like 0, but with Steele &amp; White stopping rule;</TD></TR><TR><TD CLASS="l">457</TD><TD>            e.g. with IEEE P754 arithmetic , mode 0 gives</TD></TR><TR><TD CLASS="l">458</TD><TD>            1e23 whereas mode 1 gives 9.999999999999999e22.</TD></TR><TR><TD CLASS="l">459</TD><TD>            2 ==&gt; max(1,ndigits) significant digits.  This gives a</TD></TR><TR><TD CLASS="l">460</TD><TD>            return value similar to that of ecvt, except</TD></TR><TR><TD CLASS="l">461</TD><TD>            that trailing zeros are suppressed.</TD></TR><TR><TD CLASS="l">462</TD><TD>            3 ==&gt; through ndigits past the decimal point.  This</TD></TR><TR><TD CLASS="l">463</TD><TD>            gives a return value similar to that from fcvt,</TD></TR><TR><TD CLASS="l">464</TD><TD>            except that trailing zeros are suppressed, and</TD></TR><TR><TD CLASS="l">465</TD><TD>            ndigits can be negative.</TD></TR><TR><TD CLASS="l">466</TD><TD>            4-9 should give the same return values as 2-3, i.e.,</TD></TR><TR><TD CLASS="l">467</TD><TD>            4 &lt;= mode &lt;= 9 ==&gt; same return as mode</TD></TR><TR><TD CLASS="l">468</TD><TD>            2 + (mode &amp; 1).  These modes are mainly for</TD></TR><TR><TD CLASS="l">469</TD><TD>            debugging; often they run slower but sometimes</TD></TR><TR><TD CLASS="l">470</TD><TD>            faster than modes 2-3.</TD></TR><TR><TD CLASS="l">471</TD><TD>            4,5,8,9 ==&gt; left-to-right digit generation.</TD></TR><TR><TD CLASS="l">472</TD><TD>            6-9 ==&gt; don't try fast floating-point estimate</TD></TR><TR><TD CLASS="l">473</TD><TD>            (if applicable).</TD></TR><TR><TD CLASS="l">474</TD><TD> </TD></TR><TR><TD CLASS="l">475</TD><TD>            Values of mode other than 0-9 are treated as mode 0.</TD></TR><TR><TD CLASS="l">476</TD><TD> </TD></TR><TR><TD CLASS="l">477</TD><TD>            Sufficient space is allocated to the return value</TD></TR><TR><TD CLASS="l">478</TD><TD>            to hold the suppressed trailing zeros.</TD></TR><TR><TD CLASS="l">479</TD><TD>        */</TD></TR><TR><TD CLASS="l">480</TD><TD> </TD></TR><TR><TD CLASS="l">481</TD><TD>        int b2, b5, i, ieps, ilim, ilim0, ilim1,</TD></TR><TR><TD CLASS="l">482</TD><TD>            j, j1, k, k0, m2, m5, s2, s5;</TD></TR><TR><TD CLASS="l"><A NAME="5">483</A></TD><TD>        char dig;</TD></TR><TR><TD CLASS="l">484</TD><TD>        long L;</TD></TR><TR><TD CLASS="l">485</TD><TD>        long x;</TD></TR><TR><TD CLASS="l">486</TD><TD>        BigInteger b, b1, delta, mlo, mhi, S;</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>        int[] be = new int[1];</TD></TR><TR CLASS="c"><TD CLASS="l">488</TD><TD>        int[] bbits = new int[1];</TD></TR><TR><TD CLASS="l">489</TD><TD>        double d2, ds, eps;</TD></TR><TR><TD CLASS="l">490</TD><TD>        boolean spec_case, denorm, k_check, try_quick, leftright;</TD></TR><TR><TD CLASS="l">491</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">492</TD><TD>        if ((word0(d) &amp; Sign_bit) != 0) {</TD></TR><TR><TD CLASS="l">493</TD><TD>            /* set sign for everything, including 0's and NaNs */</TD></TR><TR CLASS="c"><TD CLASS="l">494</TD><TD>            sign[0] = true;</TD></TR><TR><TD CLASS="l">495</TD><TD>            // word0(d) &amp;= ~Sign_bit;  /* clear sign bit */</TD></TR><TR CLASS="c"><TD CLASS="l">496</TD><TD>            d = setWord0(d, word0(d) &amp; ~Sign_bit);</TD></TR><TR><TD CLASS="l">497</TD><TD>        }</TD></TR><TR><TD CLASS="l">498</TD><TD>        else</TD></TR><TR CLASS="c"><TD CLASS="l">499</TD><TD>            sign[0] = false;</TD></TR><TR><TD CLASS="l">500</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">501</TD><TD>        if ((word0(d) &amp; Exp_mask) == Exp_mask) {</TD></TR><TR><TD CLASS="l">502</TD><TD>            /* Infinity or NaN */</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>            buf.append(((word1(d) == 0) &amp;&amp; ((word0(d) &amp; Frac_mask) == 0)) ? &#34;Infinity&#34; : &#34;NaN&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>            return 9999;</TD></TR><TR><TD CLASS="l">505</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">506</TD><TD>        if (d == 0) {</TD></TR><TR><TD CLASS="l">507</TD><TD>//          no_digits:</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>            buf.setLength(0);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>            buf.append('0');        /* copy &#34;0&#34; to buffer */</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>            return 1;</TD></TR><TR><TD CLASS="l">511</TD><TD>        }</TD></TR><TR><TD CLASS="l">512</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">513</TD><TD>        b = d2b(d, be, bbits);</TD></TR><TR CLASS="c"><TD CLASS="l">514</TD><TD>        if ((i = (word0(d) &gt;&gt;&gt; Exp_shift1 &amp; (Exp_mask&gt;&gt;Exp_shift1))) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">515</TD><TD>            d2 = setWord0(d, (word0(d) &amp; Frac_mask1) | Exp_11);</TD></TR><TR><TD CLASS="l">516</TD><TD>            /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5</TD></TR><TR><TD CLASS="l">517</TD><TD>             * log10(x)  =  log(x) / log(10)</TD></TR><TR><TD CLASS="l">518</TD><TD>             *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))</TD></TR><TR><TD CLASS="l">519</TD><TD>             * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)</TD></TR><TR><TD CLASS="l">520</TD><TD>             *</TD></TR><TR><TD CLASS="l">521</TD><TD>             * This suggests computing an approximation k to log10(d) by</TD></TR><TR><TD CLASS="l">522</TD><TD>             *</TD></TR><TR><TD CLASS="l">523</TD><TD>             * k = (i - Bias)*0.301029995663981</TD></TR><TR><TD CLASS="l">524</TD><TD>             *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );</TD></TR><TR><TD CLASS="l">525</TD><TD>             *</TD></TR><TR><TD CLASS="l">526</TD><TD>             * We want k to be too large rather than too small.</TD></TR><TR><TD CLASS="l">527</TD><TD>             * The error in the first-order Taylor series approximation</TD></TR><TR><TD CLASS="l">528</TD><TD>             * is in our favor, so we just round up the constant enough</TD></TR><TR><TD CLASS="l">529</TD><TD>             * to compensate for any error in the multiplication of</TD></TR><TR><TD CLASS="l">530</TD><TD>             * (i - Bias) by 0.301029995663981; since |i - Bias| &lt;= 1077,</TD></TR><TR><TD CLASS="l">531</TD><TD>             * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,</TD></TR><TR><TD CLASS="l">532</TD><TD>             * adding 1e-13 to the constant term more than suffices.</TD></TR><TR><TD CLASS="l">533</TD><TD>             * Hence we adjust the constant term to 0.1760912590558.</TD></TR><TR><TD CLASS="l">534</TD><TD>             * (We could get a more accurate k by invoking log10,</TD></TR><TR><TD CLASS="l">535</TD><TD>             *  but this is probably not worthwhile.)</TD></TR><TR><TD CLASS="l">536</TD><TD>             */</TD></TR><TR CLASS="c"><TD CLASS="l">537</TD><TD>            i -= Bias;</TD></TR><TR CLASS="c"><TD CLASS="l">538</TD><TD>            denorm = false;</TD></TR><TR><TD CLASS="l">539</TD><TD>        }</TD></TR><TR><TD CLASS="l">540</TD><TD>        else {</TD></TR><TR><TD CLASS="l">541</TD><TD>            /* d is denormalized */</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>            i = bbits[0] + be[0] + (Bias + (P-1) - 1);</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>            x = (i &gt; 32)</TD></TR><TR><TD CLASS="l">544</TD><TD>                    ? ((long) word0(d)) &lt;&lt; (64 - i) | word1(d) &gt;&gt;&gt; (i - 32)</TD></TR><TR><TD CLASS="l">545</TD><TD>                    : ((long) word1(d)) &lt;&lt; (32 - i);</TD></TR><TR><TD CLASS="l">546</TD><TD>//            d2 = x;</TD></TR><TR><TD CLASS="l">547</TD><TD>//            word0(d2) -= 31*Exp_msk1; /* adjust exponent */</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>            d2 = setWord0(x, word0(x) - 31*Exp_msk1);</TD></TR><TR CLASS="z"><TD CLASS="l">549</TD><TD>            i -= (Bias + (P-1) - 1) + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>            denorm = true;</TD></TR><TR><TD CLASS="l">551</TD><TD>        }</TD></TR><TR><TD CLASS="l">552</TD><TD>        /* At this point d = f*2^i, where 1 &lt;= f &lt; 2.  d2 is an approximation of f. */</TD></TR><TR CLASS="c"><TD CLASS="l">553</TD><TD>        ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;</TD></TR><TR CLASS="c"><TD CLASS="l">554</TD><TD>        k = (int)ds;</TD></TR><TR CLASS="c"><TD CLASS="l">555</TD><TD>        if (ds &lt; 0.0 &amp;&amp; ds != k)</TD></TR><TR CLASS="c"><TD CLASS="l">556</TD><TD>            k--;    /* want k = floor(ds) */</TD></TR><TR CLASS="c"><TD CLASS="l">557</TD><TD>        k_check = true;</TD></TR><TR CLASS="c"><TD CLASS="l">558</TD><TD>        if (k &gt;= 0 &amp;&amp; k &lt;= Ten_pmax) {</TD></TR><TR CLASS="c"><TD CLASS="l">559</TD><TD>            if (d &lt; tens[k])</TD></TR><TR CLASS="z"><TD CLASS="l">560</TD><TD>                k--;</TD></TR><TR CLASS="c"><TD CLASS="l">561</TD><TD>            k_check = false;</TD></TR><TR><TD CLASS="l">562</TD><TD>        }</TD></TR><TR><TD CLASS="l">563</TD><TD>        /* At this point floor(log10(d)) &lt;= k &lt;= floor(log10(d))+1.</TD></TR><TR><TD CLASS="l">564</TD><TD>           If k_check is zero, we're guaranteed that k = floor(log10(d)). */</TD></TR><TR CLASS="c"><TD CLASS="l">565</TD><TD>        j = bbits[0] - i - 1;</TD></TR><TR><TD CLASS="l">566</TD><TD>        /* At this point d = b/2^j, where b is an odd integer. */</TD></TR><TR CLASS="c"><TD CLASS="l">567</TD><TD>        if (j &gt;= 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">568</TD><TD>            b2 = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">569</TD><TD>            s2 = j;</TD></TR><TR><TD CLASS="l">570</TD><TD>        }</TD></TR><TR><TD CLASS="l">571</TD><TD>        else {</TD></TR><TR CLASS="c"><TD CLASS="l">572</TD><TD>            b2 = -j;</TD></TR><TR CLASS="c"><TD CLASS="l">573</TD><TD>            s2 = 0;</TD></TR><TR><TD CLASS="l">574</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">575</TD><TD>        if (k &gt;= 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">576</TD><TD>            b5 = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">577</TD><TD>            s5 = k;</TD></TR><TR CLASS="c"><TD CLASS="l">578</TD><TD>            s2 += k;</TD></TR><TR><TD CLASS="l">579</TD><TD>        }</TD></TR><TR><TD CLASS="l">580</TD><TD>        else {</TD></TR><TR CLASS="c"><TD CLASS="l">581</TD><TD>            b2 -= k;</TD></TR><TR CLASS="c"><TD CLASS="l">582</TD><TD>            b5 = -k;</TD></TR><TR CLASS="c"><TD CLASS="l">583</TD><TD>            s5 = 0;</TD></TR><TR><TD CLASS="l">584</TD><TD>        }</TD></TR><TR><TD CLASS="l">585</TD><TD>        /* At this point d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5), where b is an odd integer,</TD></TR><TR><TD CLASS="l">586</TD><TD>           b2 &gt;= 0, b5 &gt;= 0, s2 &gt;= 0, and s5 &gt;= 0. */</TD></TR><TR CLASS="c"><TD CLASS="l">587</TD><TD>        if (mode &lt; 0 || mode &gt; 9)</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>            mode = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">589</TD><TD>        try_quick = true;</TD></TR><TR CLASS="c"><TD CLASS="l">590</TD><TD>        if (mode &gt; 5) {</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>            mode -= 4;</TD></TR><TR CLASS="z"><TD CLASS="l">592</TD><TD>            try_quick = false;</TD></TR><TR><TD CLASS="l">593</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">594</TD><TD>        leftright = true;</TD></TR><TR CLASS="c"><TD CLASS="l">595</TD><TD>        ilim = ilim1 = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">596</TD><TD>        switch(mode) {</TD></TR><TR><TD CLASS="l">597</TD><TD>            case 0:</TD></TR><TR><TD CLASS="l">598</TD><TD>            case 1:</TD></TR><TR CLASS="c"><TD CLASS="l">599</TD><TD>                ilim = ilim1 = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">600</TD><TD>                i = 18;</TD></TR><TR CLASS="c"><TD CLASS="l">601</TD><TD>                ndigits = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">602</TD><TD>                break;</TD></TR><TR><TD CLASS="l">603</TD><TD>            case 2:</TD></TR><TR CLASS="c"><TD CLASS="l">604</TD><TD>                leftright = false;</TD></TR><TR><TD CLASS="l">605</TD><TD>                /* no break */</TD></TR><TR><TD CLASS="l">606</TD><TD>            case 4:</TD></TR><TR CLASS="c"><TD CLASS="l">607</TD><TD>                if (ndigits &lt;= 0)</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                    ndigits = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">609</TD><TD>                ilim = ilim1 = i = ndigits;</TD></TR><TR CLASS="c"><TD CLASS="l">610</TD><TD>                break;</TD></TR><TR><TD CLASS="l">611</TD><TD>            case 3:</TD></TR><TR CLASS="c"><TD CLASS="l">612</TD><TD>                leftright = false;</TD></TR><TR><TD CLASS="l">613</TD><TD>                /* no break */</TD></TR><TR><TD CLASS="l">614</TD><TD>            case 5:</TD></TR><TR CLASS="c"><TD CLASS="l">615</TD><TD>                i = ndigits + k + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">616</TD><TD>                ilim = i;</TD></TR><TR CLASS="c"><TD CLASS="l">617</TD><TD>                ilim1 = i - 1;</TD></TR><TR CLASS="c"><TD CLASS="l">618</TD><TD>                if (i &lt;= 0)</TD></TR><TR CLASS="c"><TD CLASS="l">619</TD><TD>                    i = 1;</TD></TR><TR><TD CLASS="l">620</TD><TD>        }</TD></TR><TR><TD CLASS="l">621</TD><TD>        /* ilim is the maximum number of significant digits we want, based on k and ndigits. */</TD></TR><TR><TD CLASS="l">622</TD><TD>        /* ilim1 is the maximum number of significant digits we want, based on k and ndigits,</TD></TR><TR><TD CLASS="l">623</TD><TD>           when it turns out that k was computed too high by one. */</TD></TR><TR><TD CLASS="l">624</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">625</TD><TD>        boolean fast_failed = false;</TD></TR><TR CLASS="c"><TD CLASS="l">626</TD><TD>        if (ilim &gt;= 0 &amp;&amp; ilim &lt;= Quick_max &amp;&amp; try_quick) {</TD></TR><TR><TD CLASS="l">627</TD><TD> </TD></TR><TR><TD CLASS="l">628</TD><TD>            /* Try to get by with floating-point arithmetic. */</TD></TR><TR><TD CLASS="l">629</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">630</TD><TD>            i = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">631</TD><TD>            d2 = d;</TD></TR><TR CLASS="c"><TD CLASS="l">632</TD><TD>            k0 = k;</TD></TR><TR CLASS="c"><TD CLASS="l">633</TD><TD>            ilim0 = ilim;</TD></TR><TR CLASS="c"><TD CLASS="l">634</TD><TD>            ieps = 2; /* conservative */</TD></TR><TR><TD CLASS="l">635</TD><TD>            /* Divide d by 10^k, keeping track of the roundoff error and avoiding overflows. */</TD></TR><TR CLASS="c"><TD CLASS="l">636</TD><TD>            if (k &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">637</TD><TD>                ds = tens[k&amp;0xf];</TD></TR><TR CLASS="c"><TD CLASS="l">638</TD><TD>                j = k &gt;&gt; 4;</TD></TR><TR CLASS="c"><TD CLASS="l">639</TD><TD>                if ((j &amp; Bletch) != 0) {</TD></TR><TR><TD CLASS="l">640</TD><TD>                    /* prevent overflows */</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>                    j &amp;= Bletch - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>                    d /= bigtens[n_bigtens-1];</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>                    ieps++;</TD></TR><TR><TD CLASS="l">644</TD><TD>                }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="25% line coverage (2 out of 8 instructions)">645</TD><TD TITLE="25% line coverage (2 out of 8 instructions)">                for(; (j != 0); j &gt;&gt;= 1, i++)</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                    if ((j &amp; 1) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                        ieps++;</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                        ds *= bigtens[i];</TD></TR><TR><TD CLASS="l">649</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">650</TD><TD>                d /= ds;</TD></TR><TR><TD CLASS="l">651</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">652</TD><TD>            else if ((j1 = -k) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">653</TD><TD>                d *= tens[j1 &amp; 0xf];</TD></TR><TR CLASS="c"><TD CLASS="l">654</TD><TD>                for(j = j1 &gt;&gt; 4; (j != 0); j &gt;&gt;= 1, i++)</TD></TR><TR CLASS="c"><TD CLASS="l">655</TD><TD>                    if ((j &amp; 1) != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">656</TD><TD>                        ieps++;</TD></TR><TR CLASS="c"><TD CLASS="l">657</TD><TD>                        d *= bigtens[i];</TD></TR><TR><TD CLASS="l">658</TD><TD>                    }</TD></TR><TR><TD CLASS="l">659</TD><TD>            }</TD></TR><TR><TD CLASS="l">660</TD><TD>            /* Check that k was computed correctly. */</TD></TR><TR CLASS="c"><TD CLASS="l">661</TD><TD>            if (k_check &amp;&amp; d &lt; 1.0 &amp;&amp; ilim &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                if (ilim1 &lt;= 0)</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                    fast_failed = true;</TD></TR><TR><TD CLASS="l">664</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>                    ilim = ilim1;</TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>                    k--;</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                    d *= 10.;</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>                    ieps++;</TD></TR><TR><TD CLASS="l">669</TD><TD>                }</TD></TR><TR><TD CLASS="l">670</TD><TD>            }</TD></TR><TR><TD CLASS="l">671</TD><TD>            /* eps bounds the cumulative error. */</TD></TR><TR><TD CLASS="l">672</TD><TD>//            eps = ieps*d + 7.0;</TD></TR><TR><TD CLASS="l">673</TD><TD>//            word0(eps) -= (P-1)*Exp_msk1;</TD></TR><TR CLASS="c"><TD CLASS="l">674</TD><TD>            eps = ieps*d + 7.0;</TD></TR><TR CLASS="c"><TD CLASS="l">675</TD><TD>            eps = setWord0(eps, word0(eps) - (P-1)*Exp_msk1);</TD></TR><TR CLASS="c"><TD CLASS="l">676</TD><TD>            if (ilim == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">677</TD><TD>                S = mhi = null;</TD></TR><TR CLASS="c"><TD CLASS="l">678</TD><TD>                d -= 5.0;</TD></TR><TR CLASS="c"><TD CLASS="l">679</TD><TD>                if (d &gt; eps) {</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>                    buf.append('1');</TD></TR><TR CLASS="z"><TD CLASS="l">681</TD><TD>                    k++;</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>                    return k + 1;</TD></TR><TR><TD CLASS="l">683</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">684</TD><TD>                if (d &lt; -eps) {</TD></TR><TR CLASS="c"><TD CLASS="l">685</TD><TD>                    buf.setLength(0);</TD></TR><TR CLASS="c"><TD CLASS="l">686</TD><TD>                    buf.append('0');        /* copy &#34;0&#34; to buffer */</TD></TR><TR CLASS="c"><TD CLASS="l">687</TD><TD>                    return 1;</TD></TR><TR><TD CLASS="l">688</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                fast_failed = true;</TD></TR><TR><TD CLASS="l">690</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">691</TD><TD>            if (!fast_failed) {</TD></TR><TR CLASS="c"><TD CLASS="l">692</TD><TD>                fast_failed = true;</TD></TR><TR CLASS="c"><TD CLASS="l">693</TD><TD>                if (leftright) {</TD></TR><TR><TD CLASS="l">694</TD><TD>                    /* Use Steele &amp; White method of only</TD></TR><TR><TD CLASS="l">695</TD><TD>                     * generating digits needed.</TD></TR><TR><TD CLASS="l">696</TD><TD>                     */</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>                    eps = 0.5/tens[ilim-1] - eps;</TD></TR><TR CLASS="z"><TD CLASS="l">698</TD><TD>                    for(i = 0;;) {</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                        L = (long)d;</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                        d -= L;</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>                        buf.append((char)('0' + L));</TD></TR><TR CLASS="z"><TD CLASS="l">702</TD><TD>                        if (d &lt; eps) {</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>                            return k + 1;</TD></TR><TR><TD CLASS="l">704</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>                        if (1.0 - d &lt; eps) {</TD></TR><TR><TD CLASS="l">706</TD><TD>//                            goto bump_up;</TD></TR><TR><TD CLASS="l">707</TD><TD>                                char lastCh;</TD></TR><TR><TD CLASS="l">708</TD><TD>                                while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                                    lastCh = buf.charAt(buf.length() - 1);</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>                                    buf.setLength(buf.length() - 1);</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                                    if (lastCh != '9') break;</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                                    if (buf.length() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                                        k++;</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                                        lastCh = '0';</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">716</TD><TD>                                    }</TD></TR><TR><TD CLASS="l">717</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>                                buf.append((char)(lastCh + 1));</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                                return k + 1;</TD></TR><TR><TD CLASS="l">720</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                        if (++i &gt;= ilim)</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                            break;</TD></TR><TR CLASS="z"><TD CLASS="l">723</TD><TD>                        eps *= 10.0;</TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                        d *= 10.0;</TD></TR><TR><TD CLASS="l">725</TD><TD>                    }</TD></TR><TR><TD CLASS="l">726</TD><TD>                }</TD></TR><TR><TD CLASS="l">727</TD><TD>                else {</TD></TR><TR><TD CLASS="l">728</TD><TD>                    /* Generate ilim digits, then fix them up. */</TD></TR><TR CLASS="c"><TD CLASS="l">729</TD><TD>                    eps *= tens[ilim-1];</TD></TR><TR CLASS="c"><TD CLASS="l">730</TD><TD>                    for(i = 1;; i++, d *= 10.0) {</TD></TR><TR CLASS="c"><TD CLASS="l">731</TD><TD>                        L = (long)d;</TD></TR><TR CLASS="c"><TD CLASS="l">732</TD><TD>                        d -= L;</TD></TR><TR CLASS="c"><TD CLASS="l">733</TD><TD>                        buf.append((char)('0' + L));</TD></TR><TR CLASS="c"><TD CLASS="l">734</TD><TD>                        if (i == ilim) {</TD></TR><TR CLASS="c"><TD CLASS="l">735</TD><TD>                            if (d &gt; 0.5 + eps) {</TD></TR><TR><TD CLASS="l">736</TD><TD>//                                goto bump_up;</TD></TR><TR><TD CLASS="l">737</TD><TD>                                char lastCh;</TD></TR><TR><TD CLASS="l">738</TD><TD>                                while (true) {</TD></TR><TR CLASS="c"><TD CLASS="l">739</TD><TD>                                    lastCh = buf.charAt(buf.length() - 1);</TD></TR><TR CLASS="c"><TD CLASS="l">740</TD><TD>                                    buf.setLength(buf.length() - 1);</TD></TR><TR CLASS="c"><TD CLASS="l">741</TD><TD>                                    if (lastCh != '9') break;</TD></TR><TR CLASS="z"><TD CLASS="l">742</TD><TD>                                    if (buf.length() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>                                        k++;</TD></TR><TR CLASS="z"><TD CLASS="l">744</TD><TD>                                        lastCh = '0';</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">746</TD><TD>                                    }</TD></TR><TR><TD CLASS="l">747</TD><TD>                                }</TD></TR><TR CLASS="c"><TD CLASS="l">748</TD><TD>                                buf.append((char)(lastCh + 1));</TD></TR><TR CLASS="c"><TD CLASS="l">749</TD><TD>                                return k + 1;</TD></TR><TR><TD CLASS="l">750</TD><TD>                            }</TD></TR><TR><TD CLASS="l">751</TD><TD>                            else</TD></TR><TR CLASS="c"><TD CLASS="l">752</TD><TD>                                if (d &lt; 0.5 - eps) {</TD></TR><TR CLASS="c"><TD CLASS="l">753</TD><TD>                                    stripTrailingZeroes(buf);</TD></TR><TR><TD CLASS="l">754</TD><TD>//                                    while(*--s == '0') ;</TD></TR><TR><TD CLASS="l">755</TD><TD>//                                    s++;</TD></TR><TR CLASS="c"><TD CLASS="l">756</TD><TD>                                    return k + 1;</TD></TR><TR><TD CLASS="l">757</TD><TD>                                }</TD></TR><TR><TD CLASS="l">758</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">759</TD><TD>                        }</TD></TR><TR><TD CLASS="l">760</TD><TD>                    }</TD></TR><TR><TD CLASS="l">761</TD><TD>                }</TD></TR><TR><TD CLASS="l">762</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">763</TD><TD>            if (fast_failed) {</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                buf.setLength(0);</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                d = d2;</TD></TR><TR CLASS="z"><TD CLASS="l">766</TD><TD>                k = k0;</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>                ilim = ilim0;</TD></TR><TR><TD CLASS="l">768</TD><TD>            }</TD></TR><TR><TD CLASS="l">769</TD><TD>        }</TD></TR><TR><TD CLASS="l">770</TD><TD> </TD></TR><TR><TD CLASS="l">771</TD><TD>        /* Do we have a &#34;small&#34; integer? */</TD></TR><TR><TD CLASS="l">772</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">773</TD><TD>        if (be[0] &gt;= 0 &amp;&amp; k &lt;= Int_max) {</TD></TR><TR><TD CLASS="l">774</TD><TD>            /* Yes. */</TD></TR><TR CLASS="c"><TD CLASS="l">775</TD><TD>            ds = tens[k];</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (6 out of 8 instructions)">776</TD><TD TITLE="75% line coverage (6 out of 8 instructions)">            if (ndigits &lt; 0 &amp;&amp; ilim &lt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">777</TD><TD>                S = mhi = null;</TD></TR><TR CLASS="z"><TD CLASS="l">778</TD><TD>                if (ilim &lt; 0 || d &lt; 5*ds || (!biasUp &amp;&amp; d == 5*ds)) {</TD></TR><TR CLASS="z"><TD CLASS="l">779</TD><TD>                    buf.setLength(0);</TD></TR><TR CLASS="z"><TD CLASS="l">780</TD><TD>                    buf.append('0');        /* copy &#34;0&#34; to buffer */</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>                    return 1;</TD></TR><TR><TD CLASS="l">782</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">783</TD><TD>                buf.append('1');</TD></TR><TR CLASS="z"><TD CLASS="l">784</TD><TD>                k++;</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>                return k + 1;</TD></TR><TR><TD CLASS="l">786</TD><TD>            }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="50% line coverage (2 out of 4 instructions)">787</TD><TD TITLE="50% line coverage (2 out of 4 instructions)">            for(i = 1;; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">788</TD><TD>                L = (long) (d / ds);</TD></TR><TR CLASS="c"><TD CLASS="l">789</TD><TD>                d -= L*ds;</TD></TR><TR CLASS="c"><TD CLASS="l">790</TD><TD>                buf.append((char)('0' + L));</TD></TR><TR CLASS="c"><TD CLASS="l">791</TD><TD>                if (i == ilim) {</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>                    d += d;</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                    if ((d &gt; ds) || (d == ds &amp;&amp; (((L &amp; 1) != 0) || biasUp))) {</TD></TR><TR><TD CLASS="l">794</TD><TD>//                    bump_up:</TD></TR><TR><TD CLASS="l">795</TD><TD>//                        while(*--s == '9')</TD></TR><TR><TD CLASS="l">796</TD><TD>//                            if (s == buf) {</TD></TR><TR><TD CLASS="l">797</TD><TD>//                                k++;</TD></TR><TR><TD CLASS="l">798</TD><TD>//                                *s = '0';</TD></TR><TR><TD CLASS="l">799</TD><TD>//                                break;</TD></TR><TR><TD CLASS="l">800</TD><TD>//                            }</TD></TR><TR><TD CLASS="l">801</TD><TD>//                        ++*s++;</TD></TR><TR><TD CLASS="l">802</TD><TD>                        char lastCh;</TD></TR><TR><TD CLASS="l">803</TD><TD>                        while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">804</TD><TD>                            lastCh = buf.charAt(buf.length() - 1);</TD></TR><TR CLASS="z"><TD CLASS="l">805</TD><TD>                            buf.setLength(buf.length() - 1);</TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>                            if (lastCh != '9') break;</TD></TR><TR CLASS="z"><TD CLASS="l">807</TD><TD>                            if (buf.length() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">808</TD><TD>                                k++;</TD></TR><TR CLASS="z"><TD CLASS="l">809</TD><TD>                                lastCh = '0';</TD></TR><TR CLASS="z"><TD CLASS="l">810</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">811</TD><TD>                            }</TD></TR><TR><TD CLASS="l">812</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">813</TD><TD>                        buf.append((char)(lastCh + 1));</TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>                    }</TD></TR><TR><TD CLASS="l">815</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">816</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">817</TD><TD>                d *= 10.0;</TD></TR><TR CLASS="c"><TD CLASS="l">818</TD><TD>                if (d == 0)</TD></TR><TR CLASS="c"><TD CLASS="l">819</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">820</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">821</TD><TD>            return k + 1;</TD></TR><TR><TD CLASS="l">822</TD><TD>        }</TD></TR><TR><TD CLASS="l">823</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">824</TD><TD>        m2 = b2;</TD></TR><TR CLASS="c"><TD CLASS="l">825</TD><TD>        m5 = b5;</TD></TR><TR CLASS="c"><TD CLASS="l">826</TD><TD>        mhi = mlo = null;</TD></TR><TR CLASS="c"><TD CLASS="l">827</TD><TD>        if (leftright) {</TD></TR><TR CLASS="c"><TD CLASS="l">828</TD><TD>            if (mode &lt; 2) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="60% line coverage (9 out of 15 instructions)">829</TD><TD TITLE="60% line coverage (9 out of 15 instructions)">                i = (denorm) ? be[0] + (Bias + (P-1) - 1 + 1) : 1 + P - bbits[0];</TD></TR><TR><TD CLASS="l">830</TD><TD>                /* i is 1 plus the number of trailing zero bits in d's significand. Thus,</TD></TR><TR><TD CLASS="l">831</TD><TD>                   (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 lsb of d)/10^k. */</TD></TR><TR><TD CLASS="l">832</TD><TD>            }</TD></TR><TR><TD CLASS="l">833</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>                j = ilim - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">835</TD><TD>                if (m5 &gt;= j)</TD></TR><TR CLASS="z"><TD CLASS="l">836</TD><TD>                    m5 -= j;</TD></TR><TR><TD CLASS="l">837</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">838</TD><TD>                    s5 += j -= m5;</TD></TR><TR CLASS="z"><TD CLASS="l">839</TD><TD>                    b5 += j;</TD></TR><TR CLASS="z"><TD CLASS="l">840</TD><TD>                    m5 = 0;</TD></TR><TR><TD CLASS="l">841</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">842</TD><TD>                if ((i = ilim) &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">843</TD><TD>                    m2 -= i;</TD></TR><TR CLASS="z"><TD CLASS="l">844</TD><TD>                    i = 0;</TD></TR><TR><TD CLASS="l">845</TD><TD>                }</TD></TR><TR><TD CLASS="l">846</TD><TD>                /* (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 * 10^(1-ilim))/10^k. */</TD></TR><TR><TD CLASS="l">847</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">848</TD><TD>            b2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">849</TD><TD>            s2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">850</TD><TD>            mhi = BigInteger.valueOf(1);</TD></TR><TR><TD CLASS="l">851</TD><TD>            /* (mhi * 2^m2 * 5^m5) / (2^s2 * 5^s5) = one-half of last printed (when mode &gt;= 2) or</TD></TR><TR><TD CLASS="l">852</TD><TD>               input (when mode &lt; 2) significant digit, divided by 10^k. */</TD></TR><TR><TD CLASS="l">853</TD><TD>        }</TD></TR><TR><TD CLASS="l">854</TD><TD>        /* We still have d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5).  Reduce common factors in</TD></TR><TR><TD CLASS="l">855</TD><TD>           b2, m2, and s2 without changing the equalities. */</TD></TR><TR CLASS="c"><TD CLASS="l">856</TD><TD>        if (m2 &gt; 0 &amp;&amp; s2 &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">857</TD><TD>            i = (m2 &lt; s2) ? m2 : s2;</TD></TR><TR CLASS="c"><TD CLASS="l">858</TD><TD>            b2 -= i;</TD></TR><TR CLASS="c"><TD CLASS="l">859</TD><TD>            m2 -= i;</TD></TR><TR CLASS="c"><TD CLASS="l">860</TD><TD>            s2 -= i;</TD></TR><TR><TD CLASS="l">861</TD><TD>        }</TD></TR><TR><TD CLASS="l">862</TD><TD> </TD></TR><TR><TD CLASS="l">863</TD><TD>        /* Fold b5 into b and m5 into mhi. */</TD></TR><TR CLASS="c"><TD CLASS="l">864</TD><TD>        if (b5 &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">865</TD><TD>            if (leftright) {</TD></TR><TR CLASS="c"><TD CLASS="l">866</TD><TD>                if (m5 &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">867</TD><TD>                    mhi = pow5mult(mhi, m5);</TD></TR><TR CLASS="c"><TD CLASS="l">868</TD><TD>                    b1 = mhi.multiply(b);</TD></TR><TR CLASS="c"><TD CLASS="l">869</TD><TD>                    b = b1;</TD></TR><TR><TD CLASS="l">870</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">871</TD><TD>                if ((j = b5 - m5) != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">872</TD><TD>                    b = pow5mult(b, j);</TD></TR><TR><TD CLASS="l">873</TD><TD>            }</TD></TR><TR><TD CLASS="l">874</TD><TD>            else</TD></TR><TR CLASS="c"><TD CLASS="l">875</TD><TD>                b = pow5mult(b, b5);</TD></TR><TR><TD CLASS="l">876</TD><TD>        }</TD></TR><TR><TD CLASS="l">877</TD><TD>        /* Now we have d/10^k = (b * 2^b2) / (2^s2 * 5^s5) and</TD></TR><TR><TD CLASS="l">878</TD><TD>           (mhi * 2^m2) / (2^s2 * 5^s5) = one-half of last printed or input significant digit, divided by 10^k. */</TD></TR><TR><TD CLASS="l">879</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">880</TD><TD>        S = BigInteger.valueOf(1);</TD></TR><TR CLASS="c"><TD CLASS="l">881</TD><TD>        if (s5 &gt; 0)</TD></TR><TR CLASS="c"><TD CLASS="l">882</TD><TD>            S = pow5mult(S, s5);</TD></TR><TR><TD CLASS="l">883</TD><TD>        /* Now we have d/10^k = (b * 2^b2) / (S * 2^s2) and</TD></TR><TR><TD CLASS="l">884</TD><TD>           (mhi * 2^m2) / (S * 2^s2) = one-half of last printed or input significant digit, divided by 10^k. */</TD></TR><TR><TD CLASS="l">885</TD><TD> </TD></TR><TR><TD CLASS="l">886</TD><TD>        /* Check for special case that d is a normalized power of 2. */</TD></TR><TR CLASS="c"><TD CLASS="l">887</TD><TD>        spec_case = false;</TD></TR><TR CLASS="c"><TD CLASS="l">888</TD><TD>        if (mode &lt; 2) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="23% line coverage (3 out of 13 instructions)">889</TD><TD TITLE="23% line coverage (3 out of 13 instructions)">            if ( (word1(d) == 0) &amp;&amp; ((word0(d) &amp; Bndry_mask) == 0)</TD></TR><TR><TD CLASS="l">890</TD><TD>                &amp;&amp; ((word0(d) &amp; (Exp_mask &amp; Exp_mask &lt;&lt; 1)) != 0)</TD></TR><TR><TD CLASS="l">891</TD><TD>                ) {</TD></TR><TR><TD CLASS="l">892</TD><TD>                /* The special case.  Here we want to be within a quarter of the last input</TD></TR><TR><TD CLASS="l">893</TD><TD>                   significant digit instead of one half of it when the decimal output string's value is less than d.  */</TD></TR><TR CLASS="z"><TD CLASS="l">894</TD><TD>                b2 += Log2P;</TD></TR><TR CLASS="z"><TD CLASS="l">895</TD><TD>                s2 += Log2P;</TD></TR><TR CLASS="z"><TD CLASS="l">896</TD><TD>                spec_case = true;</TD></TR><TR><TD CLASS="l">897</TD><TD>            }</TD></TR><TR><TD CLASS="l">898</TD><TD>        }</TD></TR><TR><TD CLASS="l">899</TD><TD> </TD></TR><TR><TD CLASS="l">900</TD><TD>        /* Arrange for convenient computation of quotients:</TD></TR><TR><TD CLASS="l">901</TD><TD>         * shift left if necessary so divisor has 4 leading 0 bits.</TD></TR><TR><TD CLASS="l">902</TD><TD>         *</TD></TR><TR><TD CLASS="l">903</TD><TD>         * Perhaps we should just compute leading 28 bits of S once</TD></TR><TR><TD CLASS="l">904</TD><TD>         * and for all and pass them and a shift to quorem, so it</TD></TR><TR><TD CLASS="l">905</TD><TD>         * can do shifts and ors to compute the numerator for q.</TD></TR><TR><TD CLASS="l">906</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">907</TD><TD>        byte [] S_bytes = S.toByteArray();</TD></TR><TR CLASS="c"><TD CLASS="l">908</TD><TD>        int S_hiWord = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">909</TD><TD>        for (int idx = 0; idx &lt; 4; idx++) {</TD></TR><TR CLASS="c"><TD CLASS="l">910</TD><TD>            S_hiWord = (S_hiWord &lt;&lt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">911</TD><TD>            if (idx &lt; S_bytes.length)</TD></TR><TR CLASS="c"><TD CLASS="l">912</TD><TD>                S_hiWord |= (S_bytes[idx] &amp; 0xFF);</TD></TR><TR><TD CLASS="l">913</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">914</TD><TD>        if ((i = (((s5 != 0) ? 32 - hi0bits(S_hiWord) : 1) + s2) &amp; 0x1f) != 0)</TD></TR><TR CLASS="c"><TD CLASS="l">915</TD><TD>            i = 32 - i;</TD></TR><TR><TD CLASS="l">916</TD><TD>        /* i is the number of leading zero bits in the most significant word of S*2^s2. */</TD></TR><TR CLASS="c"><TD CLASS="l">917</TD><TD>        if (i &gt; 4) {</TD></TR><TR CLASS="c"><TD CLASS="l">918</TD><TD>            i -= 4;</TD></TR><TR CLASS="c"><TD CLASS="l">919</TD><TD>            b2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">920</TD><TD>            m2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">921</TD><TD>            s2 += i;</TD></TR><TR><TD CLASS="l">922</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">923</TD><TD>        else if (i &lt; 4) {</TD></TR><TR CLASS="c"><TD CLASS="l">924</TD><TD>            i += 28;</TD></TR><TR CLASS="c"><TD CLASS="l">925</TD><TD>            b2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">926</TD><TD>            m2 += i;</TD></TR><TR CLASS="c"><TD CLASS="l">927</TD><TD>            s2 += i;</TD></TR><TR><TD CLASS="l">928</TD><TD>        }</TD></TR><TR><TD CLASS="l">929</TD><TD>        /* Now S*2^s2 has exactly four leading zero bits in its most significant word. */</TD></TR><TR CLASS="c"><TD CLASS="l">930</TD><TD>        if (b2 &gt; 0)</TD></TR><TR CLASS="c"><TD CLASS="l">931</TD><TD>            b = b.shiftLeft(b2);</TD></TR><TR CLASS="c"><TD CLASS="l">932</TD><TD>        if (s2 &gt; 0)</TD></TR><TR CLASS="c"><TD CLASS="l">933</TD><TD>            S = S.shiftLeft(s2);</TD></TR><TR><TD CLASS="l">934</TD><TD>        /* Now we have d/10^k = b/S and</TD></TR><TR><TD CLASS="l">935</TD><TD>           (mhi * 2^m2) / S = maximum acceptable error, divided by 10^k. */</TD></TR><TR CLASS="c"><TD CLASS="l">936</TD><TD>        if (k_check) {</TD></TR><TR CLASS="c"><TD CLASS="l">937</TD><TD>            if (b.compareTo(S) &lt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">938</TD><TD>                k--;</TD></TR><TR CLASS="c"><TD CLASS="l">939</TD><TD>                b = b.multiply(BigInteger.valueOf(10));  /* we botched the k estimate */</TD></TR><TR CLASS="c"><TD CLASS="l">940</TD><TD>                if (leftright)</TD></TR><TR CLASS="c"><TD CLASS="l">941</TD><TD>                    mhi = mhi.multiply(BigInteger.valueOf(10));</TD></TR><TR CLASS="c"><TD CLASS="l">942</TD><TD>                ilim = ilim1;</TD></TR><TR><TD CLASS="l">943</TD><TD>            }</TD></TR><TR><TD CLASS="l">944</TD><TD>        }</TD></TR><TR><TD CLASS="l">945</TD><TD>        /* At this point 1 &lt;= d/10^k = b/S &lt; 10. */</TD></TR><TR><TD CLASS="l">946</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">947</TD><TD>        if (ilim &lt;= 0 &amp;&amp; mode &gt; 2) {</TD></TR><TR><TD CLASS="l">948</TD><TD>            /* We're doing fixed-mode output and d is less than the minimum nonzero output in this mode.</TD></TR><TR><TD CLASS="l">949</TD><TD>               Output either zero or the minimum nonzero output depending on which is closer to d. */</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="12% line coverage (2 out of 17 instructions)">950</TD><TD TITLE="12% line coverage (2 out of 17 instructions)">            if ((ilim &lt; 0 )</TD></TR><TR><TD CLASS="l">951</TD><TD>                    || ((i = b.compareTo(S = S.multiply(BigInteger.valueOf(5)))) &lt; 0)</TD></TR><TR><TD CLASS="l">952</TD><TD>                    || ((i == 0 &amp;&amp; !biasUp))) {</TD></TR><TR><TD CLASS="l">953</TD><TD>            /* Always emit at least one digit.  If the number appears to be zero</TD></TR><TR><TD CLASS="l">954</TD><TD>               using the current mode, then emit one '0' digit and set decpt to 1. */</TD></TR><TR><TD CLASS="l">955</TD><TD>            /*no_digits:</TD></TR><TR><TD CLASS="l">956</TD><TD>                k = -1 - ndigits;</TD></TR><TR><TD CLASS="l">957</TD><TD>                goto ret; */</TD></TR><TR CLASS="c"><TD CLASS="l">958</TD><TD>                buf.setLength(0);</TD></TR><TR CLASS="c"><TD CLASS="l">959</TD><TD>                buf.append('0');        /* copy &#34;0&#34; to buffer */</TD></TR><TR CLASS="c"><TD CLASS="l">960</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">961</TD><TD>//                goto no_digits;</TD></TR><TR><TD CLASS="l">962</TD><TD>            }</TD></TR><TR><TD CLASS="l">963</TD><TD>//        one_digit:</TD></TR><TR CLASS="z"><TD CLASS="l">964</TD><TD>            buf.append('1');</TD></TR><TR CLASS="z"><TD CLASS="l">965</TD><TD>            k++;</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>            return k + 1;</TD></TR><TR><TD CLASS="l">967</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">968</TD><TD>        if (leftright) {</TD></TR><TR CLASS="c"><TD CLASS="l">969</TD><TD>            if (m2 &gt; 0)</TD></TR><TR CLASS="c"><TD CLASS="l">970</TD><TD>                mhi = mhi.shiftLeft(m2);</TD></TR><TR><TD CLASS="l">971</TD><TD> </TD></TR><TR><TD CLASS="l">972</TD><TD>            /* Compute mlo -- check for special case</TD></TR><TR><TD CLASS="l">973</TD><TD>             * that d is a normalized power of 2.</TD></TR><TR><TD CLASS="l">974</TD><TD>             */</TD></TR><TR><TD CLASS="l">975</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">976</TD><TD>            mlo = mhi;</TD></TR><TR CLASS="c"><TD CLASS="l">977</TD><TD>            if (spec_case) {</TD></TR><TR CLASS="z"><TD CLASS="l">978</TD><TD>                mhi = mlo;</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>                mhi = mhi.shiftLeft(Log2P);</TD></TR><TR><TD CLASS="l">980</TD><TD>            }</TD></TR><TR><TD CLASS="l">981</TD><TD>            /* mlo/S = maximum acceptable error, divided by 10^k, if the output is less than d. */</TD></TR><TR><TD CLASS="l">982</TD><TD>            /* mhi/S = maximum acceptable error, divided by 10^k, if the output is greater than d. */</TD></TR><TR><TD CLASS="l">983</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">984</TD><TD>            for(i = 1;;i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">985</TD><TD>                BigInteger[] divResult = b.divideAndRemainder(S);</TD></TR><TR CLASS="c"><TD CLASS="l">986</TD><TD>                b = divResult[1];</TD></TR><TR CLASS="c"><TD CLASS="l">987</TD><TD>                dig = (char)(divResult[0].intValue() + '0');</TD></TR><TR><TD CLASS="l">988</TD><TD>                /* Do we yet have the shortest decimal string</TD></TR><TR><TD CLASS="l">989</TD><TD>                 * that will round to d?</TD></TR><TR><TD CLASS="l">990</TD><TD>                 */</TD></TR><TR CLASS="c"><TD CLASS="l">991</TD><TD>                j = b.compareTo(mlo);</TD></TR><TR><TD CLASS="l">992</TD><TD>                /* j is b/S compared with mlo/S. */</TD></TR><TR CLASS="c"><TD CLASS="l">993</TD><TD>                delta = S.subtract(mhi);</TD></TR><TR CLASS="c"><TD CLASS="l">994</TD><TD>                j1 = (delta.signum() &lt;= 0) ? 1 : b.compareTo(delta);</TD></TR><TR><TD CLASS="l">995</TD><TD>                /* j1 is b/S compared with 1 - mhi/S. */</TD></TR><TR CLASS="c"><TD CLASS="l">996</TD><TD>                if ((j1 == 0) &amp;&amp; (mode == 0) &amp;&amp; ((word1(d) &amp; 1) == 0)) {</TD></TR><TR CLASS="c"><TD CLASS="l">997</TD><TD>                    if (dig == '9') {</TD></TR><TR CLASS="c"><TD CLASS="l">998</TD><TD>                        buf.append('9');</TD></TR><TR CLASS="c"><TD CLASS="l">999</TD><TD>                        if (roundOff(buf)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1000</TD><TD>                            k++;</TD></TR><TR CLASS="c"><TD CLASS="l">1001</TD><TD>                            buf.append('1');</TD></TR><TR><TD CLASS="l">1002</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">1003</TD><TD>                        return k + 1;</TD></TR><TR><TD CLASS="l">1004</TD><TD>//                        goto round_9_up;</TD></TR><TR><TD CLASS="l">1005</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">1006</TD><TD>                    if (j &gt; 0)</TD></TR><TR CLASS="c"><TD CLASS="l">1007</TD><TD>                        dig++;</TD></TR><TR CLASS="c"><TD CLASS="l">1008</TD><TD>                    buf.append(dig);</TD></TR><TR CLASS="c"><TD CLASS="l">1009</TD><TD>                    return k + 1;</TD></TR><TR><TD CLASS="l">1010</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1011</TD><TD>                if ((j &lt; 0)</TD></TR><TR><TD CLASS="l">1012</TD><TD>                        || ((j == 0)</TD></TR><TR><TD CLASS="l">1013</TD><TD>                            &amp;&amp; (mode == 0)</TD></TR><TR><TD CLASS="l">1014</TD><TD>                            &amp;&amp; ((word1(d) &amp; 1) == 0)</TD></TR><TR><TD CLASS="l">1015</TD><TD>                    )) {</TD></TR><TR CLASS="c"><TD CLASS="l">1016</TD><TD>                    if (j1 &gt; 0) {</TD></TR><TR><TD CLASS="l">1017</TD><TD>                        /* Either dig or dig+1 would work here as the least significant decimal digit.</TD></TR><TR><TD CLASS="l">1018</TD><TD>                           Use whichever would produce a decimal value closer to d. */</TD></TR><TR CLASS="c"><TD CLASS="l">1019</TD><TD>                        b = b.shiftLeft(1);</TD></TR><TR CLASS="c"><TD CLASS="l">1020</TD><TD>                        j1 = b.compareTo(S);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (18 out of 27 instructions)">1021</TD><TD TITLE="67% line coverage (18 out of 27 instructions)">                        if (((j1 &gt; 0) || (j1 == 0 &amp;&amp; (((dig &amp; 1) == 1) || biasUp)))</TD></TR><TR><TD CLASS="l">1022</TD><TD>                            &amp;&amp; (dig++ == '9')) {</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>                                buf.append('9');</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                                if (roundOff(buf)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                                    k++;</TD></TR><TR CLASS="z"><TD CLASS="l">1026</TD><TD>                                    buf.append('1');</TD></TR><TR><TD CLASS="l">1027</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1028</TD><TD>                                return k + 1;</TD></TR><TR><TD CLASS="l">1029</TD><TD>//                                goto round_9_up;</TD></TR><TR><TD CLASS="l">1030</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1031</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">1032</TD><TD>                    buf.append(dig);</TD></TR><TR CLASS="c"><TD CLASS="l">1033</TD><TD>                    return k + 1;</TD></TR><TR><TD CLASS="l">1034</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1035</TD><TD>                if (j1 &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">1036</TD><TD>                    if (dig == '9') { /* possible if i == 1 */</TD></TR><TR><TD CLASS="l">1037</TD><TD>//                    round_9_up:</TD></TR><TR><TD CLASS="l">1038</TD><TD>//                        *s++ = '9';</TD></TR><TR><TD CLASS="l">1039</TD><TD>//                        goto roundoff;</TD></TR><TR CLASS="c"><TD CLASS="l">1040</TD><TD>                        buf.append('9');</TD></TR><TR CLASS="c"><TD CLASS="l">1041</TD><TD>                        if (roundOff(buf)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1042</TD><TD>                            k++;</TD></TR><TR CLASS="c"><TD CLASS="l">1043</TD><TD>                            buf.append('1');</TD></TR><TR><TD CLASS="l">1044</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">1045</TD><TD>                        return k + 1;</TD></TR><TR><TD CLASS="l">1046</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">1047</TD><TD>                    buf.append((char)(dig + 1));</TD></TR><TR CLASS="c"><TD CLASS="l">1048</TD><TD>                    return k + 1;</TD></TR><TR><TD CLASS="l">1049</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1050</TD><TD>                buf.append(dig);</TD></TR><TR CLASS="c"><TD CLASS="l">1051</TD><TD>                if (i == ilim)</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>                    break;</TD></TR><TR CLASS="c"><TD CLASS="l">1053</TD><TD>                b = b.multiply(BigInteger.valueOf(10));</TD></TR><TR CLASS="c"><TD CLASS="l">1054</TD><TD>                if (mlo == mhi)</TD></TR><TR CLASS="c"><TD CLASS="l">1055</TD><TD>                    mlo = mhi = mhi.multiply(BigInteger.valueOf(10));</TD></TR><TR><TD CLASS="l">1056</TD><TD>                else {</TD></TR><TR CLASS="z"><TD CLASS="l">1057</TD><TD>                    mlo = mlo.multiply(BigInteger.valueOf(10));</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>                    mhi = mhi.multiply(BigInteger.valueOf(10));</TD></TR><TR><TD CLASS="l">1059</TD><TD>                }</TD></TR><TR><TD CLASS="l">1060</TD><TD>            }</TD></TR><TR><TD CLASS="l">1061</TD><TD>        }</TD></TR><TR><TD CLASS="l">1062</TD><TD>        else</TD></TR><TR CLASS="z"><TD CLASS="l">1063</TD><TD>            for(i = 1;; i++) {</TD></TR><TR><TD CLASS="l">1064</TD><TD>//                (char)(dig = quorem(b,S) + '0');</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>                BigInteger[] divResult = b.divideAndRemainder(S);</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>                b = divResult[1];</TD></TR><TR CLASS="z"><TD CLASS="l">1067</TD><TD>                dig = (char)(divResult[0].intValue() + '0');</TD></TR><TR CLASS="z"><TD CLASS="l">1068</TD><TD>                buf.append(dig);</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                if (i &gt;= ilim)</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                    break;</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>                b = b.multiply(BigInteger.valueOf(10));</TD></TR><TR><TD CLASS="l">1072</TD><TD>            }</TD></TR><TR><TD CLASS="l">1073</TD><TD> </TD></TR><TR><TD CLASS="l">1074</TD><TD>        /* Round off last digit */</TD></TR><TR><TD CLASS="l">1075</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1076</TD><TD>        b = b.shiftLeft(1);</TD></TR><TR CLASS="z"><TD CLASS="l">1077</TD><TD>        j = b.compareTo(S);</TD></TR><TR CLASS="z"><TD CLASS="l">1078</TD><TD>        if ((j &gt; 0) || (j == 0 &amp;&amp; (((dig &amp; 1) == 1) || biasUp))) {</TD></TR><TR><TD CLASS="l">1079</TD><TD>//        roundoff:</TD></TR><TR><TD CLASS="l">1080</TD><TD>//            while(*--s == '9')</TD></TR><TR><TD CLASS="l">1081</TD><TD>//                if (s == buf) {</TD></TR><TR><TD CLASS="l">1082</TD><TD>//                    k++;</TD></TR><TR><TD CLASS="l">1083</TD><TD>//                    *s++ = '1';</TD></TR><TR><TD CLASS="l">1084</TD><TD>//                    goto ret;</TD></TR><TR><TD CLASS="l">1085</TD><TD>//                }</TD></TR><TR><TD CLASS="l">1086</TD><TD>//            ++*s++;</TD></TR><TR CLASS="z"><TD CLASS="l">1087</TD><TD>            if (roundOff(buf)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1088</TD><TD>                k++;</TD></TR><TR CLASS="z"><TD CLASS="l">1089</TD><TD>                buf.append('1');</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>                return k + 1;</TD></TR><TR><TD CLASS="l">1091</TD><TD>            }</TD></TR><TR><TD CLASS="l">1092</TD><TD>        }</TD></TR><TR><TD CLASS="l">1093</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">1094</TD><TD>            stripTrailingZeroes(buf);</TD></TR><TR><TD CLASS="l">1095</TD><TD>//            while(*--s == '0') ;</TD></TR><TR><TD CLASS="l">1096</TD><TD>//            s++;</TD></TR><TR><TD CLASS="l">1097</TD><TD>        }</TD></TR><TR><TD CLASS="l">1098</TD><TD>//      ret:</TD></TR><TR><TD CLASS="l">1099</TD><TD>//        Bfree(S);</TD></TR><TR><TD CLASS="l">1100</TD><TD>//        if (mhi) {</TD></TR><TR><TD CLASS="l">1101</TD><TD>//            if (mlo &amp;&amp; mlo != mhi)</TD></TR><TR><TD CLASS="l">1102</TD><TD>//                Bfree(mlo);</TD></TR><TR><TD CLASS="l">1103</TD><TD>//            Bfree(mhi);</TD></TR><TR><TD CLASS="l">1104</TD><TD>//        }</TD></TR><TR><TD CLASS="l">1105</TD><TD>//      ret1:</TD></TR><TR><TD CLASS="l">1106</TD><TD>//        Bfree(b);</TD></TR><TR><TD CLASS="l">1107</TD><TD>//        JS_ASSERT(s &lt; buf + bufsize);</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>        return k + 1;</TD></TR><TR><TD CLASS="l">1109</TD><TD>    }</TD></TR><TR><TD CLASS="l">1110</TD><TD> </TD></TR><TR><TD CLASS="l">1111</TD><TD>    private static void</TD></TR><TR><TD CLASS="l"><A NAME="9">1112</A></TD><TD>    stripTrailingZeroes(StringBuilder buf)</TD></TR><TR><TD CLASS="l">1113</TD><TD>    {</TD></TR><TR><TD CLASS="l">1114</TD><TD>//      while(*--s == '0') ;</TD></TR><TR><TD CLASS="l">1115</TD><TD>//      s++;</TD></TR><TR CLASS="c"><TD CLASS="l">1116</TD><TD>        int bl = buf.length();</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="89% line coverage (8 out of 9 instructions)">1117</TD><TD TITLE="89% line coverage (8 out of 9 instructions)">        while(bl--&gt;0 &amp;&amp; buf.charAt(bl) == '0') {</TD></TR><TR><TD CLASS="l">1118</TD><TD>          // empty</TD></TR><TR><TD CLASS="l">1119</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1120</TD><TD>        buf.setLength(bl + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">1121</TD><TD>    }</TD></TR><TR><TD CLASS="l">1122</TD><TD> </TD></TR><TR><TD CLASS="l">1123</TD><TD>    /* Mapping of JSDToStrMode -&gt; JS_dtoa mode */</TD></TR><TR CLASS="c"><TD CLASS="l">1124</TD><TD>    private static final int dtoaModes[] = {</TD></TR><TR><TD CLASS="l">1125</TD><TD>        0,   /* DTOSTR_STANDARD */</TD></TR><TR><TD CLASS="l">1126</TD><TD>        0,   /* DTOSTR_STANDARD_EXPONENTIAL, */</TD></TR><TR><TD CLASS="l">1127</TD><TD>        3,   /* DTOSTR_FIXED, */</TD></TR><TR><TD CLASS="l">1128</TD><TD>        2,   /* DTOSTR_EXPONENTIAL, */</TD></TR><TR><TD CLASS="l">1129</TD><TD>        2};  /* DTOSTR_PRECISION */</TD></TR><TR><TD CLASS="l">1130</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="8">1131</A></TD><TD>    static void</TD></TR><TR><TD CLASS="l">1132</TD><TD>    JS_dtostr(StringBuilder buffer, int mode, int precision, double d)</TD></TR><TR><TD CLASS="l">1133</TD><TD>    {</TD></TR><TR><TD CLASS="l">1134</TD><TD>        int decPt;                                    /* Position of decimal point relative to first digit returned by JS_dtoa */</TD></TR><TR CLASS="c"><TD CLASS="l">1135</TD><TD>        boolean[] sign = new boolean[1];            /* true if the sign bit was set in d */</TD></TR><TR><TD CLASS="l">1136</TD><TD>        int nDigits;                                /* Number of significand digits returned by JS_dtoa */</TD></TR><TR><TD CLASS="l">1137</TD><TD> </TD></TR><TR><TD CLASS="l">1138</TD><TD>//        JS_ASSERT(bufferSize &gt;= (size_t)(mode &lt;= DTOSTR_STANDARD_EXPONENTIAL ? DTOSTR_STANDARD_BUFFER_SIZE :</TD></TR><TR><TD CLASS="l">1139</TD><TD>//                DTOSTR_VARIABLE_BUFFER_SIZE(precision)));</TD></TR><TR><TD CLASS="l">1140</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1141</TD><TD>        if (mode == DTOSTR_FIXED &amp;&amp; (d &gt;= 1e21 || d &lt;= -1e21))</TD></TR><TR CLASS="z"><TD CLASS="l">1142</TD><TD>            mode = DTOSTR_STANDARD; /* Change mode here rather than below because the buffer may not be large enough to hold a large integer. */</TD></TR><TR><TD CLASS="l">1143</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1144</TD><TD>        decPt = JS_dtoa(d, dtoaModes[mode], mode &gt;= DTOSTR_FIXED, precision, sign, buffer);</TD></TR><TR CLASS="c"><TD CLASS="l">1145</TD><TD>        nDigits = buffer.length();</TD></TR><TR><TD CLASS="l">1146</TD><TD> </TD></TR><TR><TD CLASS="l">1147</TD><TD>        /* If Infinity, -Infinity, or NaN, return the string regardless of the mode. */</TD></TR><TR CLASS="c"><TD CLASS="l">1148</TD><TD>        if (decPt != 9999) {</TD></TR><TR CLASS="c"><TD CLASS="l">1149</TD><TD>            boolean exponentialNotation = false;</TD></TR><TR CLASS="c"><TD CLASS="l">1150</TD><TD>            int minNDigits = 0;         /* Minimum number of significand digits required by mode and precision */</TD></TR><TR><TD CLASS="l">1151</TD><TD>            int p;</TD></TR><TR><TD CLASS="l">1152</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1153</TD><TD>            switch (mode) {</TD></TR><TR><TD CLASS="l">1154</TD><TD>                case DTOSTR_STANDARD:</TD></TR><TR CLASS="c"><TD CLASS="l">1155</TD><TD>                    if (decPt &lt; -5 || decPt &gt; 21)</TD></TR><TR CLASS="c"><TD CLASS="l">1156</TD><TD>                        exponentialNotation = true;</TD></TR><TR><TD CLASS="l">1157</TD><TD>                    else</TD></TR><TR CLASS="c"><TD CLASS="l">1158</TD><TD>                        minNDigits = decPt;</TD></TR><TR CLASS="c"><TD CLASS="l">1159</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1160</TD><TD> </TD></TR><TR><TD CLASS="l">1161</TD><TD>                case DTOSTR_FIXED:</TD></TR><TR CLASS="c"><TD CLASS="l">1162</TD><TD>                    if (precision &gt;= 0)</TD></TR><TR CLASS="c"><TD CLASS="l">1163</TD><TD>                        minNDigits = decPt + precision;</TD></TR><TR><TD CLASS="l">1164</TD><TD>                    else</TD></TR><TR CLASS="z"><TD CLASS="l">1165</TD><TD>                        minNDigits = decPt;</TD></TR><TR CLASS="z"><TD CLASS="l">1166</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1167</TD><TD> </TD></TR><TR><TD CLASS="l">1168</TD><TD>                case DTOSTR_EXPONENTIAL:</TD></TR><TR><TD CLASS="l">1169</TD><TD>//                    JS_ASSERT(precision &gt; 0);</TD></TR><TR CLASS="c"><TD CLASS="l">1170</TD><TD>                    minNDigits = precision;</TD></TR><TR><TD CLASS="l">1171</TD><TD>                    /* Fall through */</TD></TR><TR><TD CLASS="l">1172</TD><TD>                case DTOSTR_STANDARD_EXPONENTIAL:</TD></TR><TR CLASS="c"><TD CLASS="l">1173</TD><TD>                    exponentialNotation = true;</TD></TR><TR CLASS="c"><TD CLASS="l">1174</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1175</TD><TD> </TD></TR><TR><TD CLASS="l">1176</TD><TD>                case DTOSTR_PRECISION:</TD></TR><TR><TD CLASS="l">1177</TD><TD>//                    JS_ASSERT(precision &gt; 0);</TD></TR><TR CLASS="c"><TD CLASS="l">1178</TD><TD>                    minNDigits = precision;</TD></TR><TR CLASS="c"><TD CLASS="l">1179</TD><TD>                    if (decPt &lt; -5 || decPt &gt; precision)</TD></TR><TR CLASS="z"><TD CLASS="l">1180</TD><TD>                        exponentialNotation = true;</TD></TR><TR><TD CLASS="l">1181</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1182</TD><TD>            }</TD></TR><TR><TD CLASS="l">1183</TD><TD> </TD></TR><TR><TD CLASS="l">1184</TD><TD>            /* If the number has fewer than minNDigits, pad it with zeros at the end */</TD></TR><TR CLASS="c"><TD CLASS="l">1185</TD><TD>            if (nDigits &lt; minNDigits) {</TD></TR><TR CLASS="c"><TD CLASS="l">1186</TD><TD>                p = minNDigits;</TD></TR><TR CLASS="c"><TD CLASS="l">1187</TD><TD>                nDigits = minNDigits;</TD></TR><TR><TD CLASS="l">1188</TD><TD>                do {</TD></TR><TR CLASS="c"><TD CLASS="l">1189</TD><TD>                    buffer.append('0');</TD></TR><TR CLASS="c"><TD CLASS="l">1190</TD><TD>                } while (buffer.length() != p);</TD></TR><TR><TD CLASS="l">1191</TD><TD>            }</TD></TR><TR><TD CLASS="l">1192</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1193</TD><TD>            if (exponentialNotation) {</TD></TR><TR><TD CLASS="l">1194</TD><TD>                /* Insert a decimal point if more than one significand digit */</TD></TR><TR CLASS="c"><TD CLASS="l">1195</TD><TD>                if (nDigits != 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">1196</TD><TD>                    buffer.insert(1, '.');</TD></TR><TR><TD CLASS="l">1197</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1198</TD><TD>                buffer.append('e');</TD></TR><TR CLASS="c"><TD CLASS="l">1199</TD><TD>                if ((decPt - 1) &gt;= 0)</TD></TR><TR CLASS="c"><TD CLASS="l">1200</TD><TD>                    buffer.append('+');</TD></TR><TR CLASS="c"><TD CLASS="l">1201</TD><TD>                buffer.append(decPt - 1);</TD></TR><TR><TD CLASS="l">1202</TD><TD>//                JS_snprintf(numEnd, bufferSize - (numEnd - buffer), &#34;e%+d&#34;, decPt-1);</TD></TR><TR CLASS="c"><TD CLASS="l">1203</TD><TD>            } else if (decPt != nDigits) {</TD></TR><TR><TD CLASS="l">1204</TD><TD>                /* Some kind of a fraction in fixed notation */</TD></TR><TR><TD CLASS="l">1205</TD><TD>//                JS_ASSERT(decPt &lt;= nDigits);</TD></TR><TR CLASS="c"><TD CLASS="l">1206</TD><TD>                if (decPt &gt; 0) {</TD></TR><TR><TD CLASS="l">1207</TD><TD>                    /* dd...dd . dd...dd */</TD></TR><TR CLASS="c"><TD CLASS="l">1208</TD><TD>                    buffer.insert(decPt, '.');</TD></TR><TR><TD CLASS="l">1209</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">1210</TD><TD>                    /* 0 . 00...00dd...dd */</TD></TR><TR CLASS="c"><TD CLASS="l">1211</TD><TD>                    for (int i = 0; i &lt; 1 - decPt; i++)</TD></TR><TR CLASS="c"><TD CLASS="l">1212</TD><TD>                        buffer.insert(0, '0');</TD></TR><TR CLASS="c"><TD CLASS="l">1213</TD><TD>                    buffer.insert(1, '.');</TD></TR><TR><TD CLASS="l">1214</TD><TD>                }</TD></TR><TR><TD CLASS="l">1215</TD><TD>            }</TD></TR><TR><TD CLASS="l">1216</TD><TD>        }</TD></TR><TR><TD CLASS="l">1217</TD><TD> </TD></TR><TR><TD CLASS="l">1218</TD><TD>        /* If negative and neither -0.0 nor NaN, output a leading '-'. */</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="56% line coverage (14 out of 25 instructions)">1219</TD><TD TITLE="56% line coverage (14 out of 25 instructions)">        if (sign[0] &amp;&amp;</TD></TR><TR><TD CLASS="l">1220</TD><TD>                !(word0(d) == Sign_bit &amp;&amp; word1(d) == 0) &amp;&amp;</TD></TR><TR><TD CLASS="l">1221</TD><TD>                !((word0(d) &amp; Exp_mask) == Exp_mask &amp;&amp;</TD></TR><TR><TD CLASS="l">1222</TD><TD>                  ((word1(d) != 0) || ((word0(d) &amp; Frac_mask) != 0)))) {</TD></TR><TR CLASS="c"><TD CLASS="l">1223</TD><TD>            buffer.insert(0, '-');</TD></TR><TR><TD CLASS="l">1224</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1225</TD><TD>    }</TD></TR><TR><TD CLASS="l">1226</TD><TD> </TD></TR><TR><TD CLASS="l">1227</TD><TD>}</TD></TR><TR><TD CLASS="l">1228</TD><TD> </TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>