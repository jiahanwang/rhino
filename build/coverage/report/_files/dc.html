<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">IRFactory.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>IRFactory.java</TD><TD>100% (1/1)</TD><TD>94%  (80/85)</TD><TD>88%  (4618/5264)</TD><TD>89%  (1104.8/1243)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">IRFactory</A></TD><TD>100% (1/1)</TD><TD>94%  (80/85)</TD><TD>88%  (4618/5264)</TD><TD>89%  (1104.8/1243)</TD></TR><TR><TD CLASS="f"><A HREF="#0">IRFactory (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">createExprStatementNoReturn (Node, int): Node</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3">decompileElementGet (ElementGet): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">genExprTransformHelper (GeneratorExpression): Node</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/228)</TD><TD CLASS="h">0%   (0/47)</TD></TR><TR><TD CLASS="f"><A HREF="#5">transformGenExpr (GeneratorExpression): Node</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/160)</TD><TD CLASS="h">0%   (0/36)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">createElementGet (Node, String, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">50%  (11/22)</TD><TD CLASS="h">50%  (2/4)</TD></TR><TR><TD CLASS="f"><A HREF="#7">decompile (AstNode): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">52%  (33/64)</TD><TD CLASS="h">65%  (13/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">createLoopNode (Node, int): Scope</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">69%  (9/13)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR><TD CLASS="f"><A HREF="#9">createCatch (String, Node, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">72%  (13/18)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">createAssignment (int, Node, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">76%  (122/161)</TD><TD CLASS="h">73%  (30/41)</TD></TR><TR><TD CLASS="f"><A HREF="#b">createUseLocal (Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (15/17)</TD><TD>92%  (3.7/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">transformFunction (FunctionNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (115/130)</TD><TD>88%  (23/26)</TD></TR><TR><TD CLASS="f"><A HREF="#d">closeSwitch (Node): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (35/39)</TD><TD>95%  (10.5/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">addSwitchCase (Node, Node, Node): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (39/43)</TD><TD>96%  (12.5/13)</TD></TR><TR><TD CLASS="f"><A HREF="#f">transformWhileLoop (WhileLoop): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (50/55)</TD><TD>99%  (10.9/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">decompileFunctionHeader (FunctionNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>92%  (58/63)</TD><TD>93%  (14/15)</TD></TR><TR><TD CLASS="f"><A HREF="#11">transformDoLoop (DoLoop): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>92%  (58/63)</TD><TD>99%  (12.9/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">transformForLoop (ForLoop): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>92%  (71/77)</TD><TD>100% (15.9/16)</TD></TR><TR><TD CLASS="f"><A HREF="#13">transformLetNode (LetNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (63/68)</TD><TD>97%  (15.5/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">createPropertyGet (Node, String, String, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (51/55)</TD><TD>92%  (11/12)</TD></TR><TR><TD CLASS="f"><A HREF="#15">createBinary (int, Node, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (206/222)</TD><TD>93%  (53/57)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">createForIn (int, Node, Node, Node, Node, boolean): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (185/199)</TD><TD>90%  (43/48)</TD></TR><TR><TD CLASS="f"><A HREF="#17">transformArrayComp (ArrayComprehension): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (69/74)</TD><TD>100% (13.9/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">transform (AstNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (239/256)</TD><TD>96%  (54/56)</TD></TR><TR><TD CLASS="f"><A HREF="#19">createIncDec (int, boolean, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (36/38)</TD><TD>92%  (11/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">arrayCompTransformHelper (ArrayComprehension, String): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (230/242)</TD><TD>98%  (48.9/50)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">transformScript (ScriptNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (44/46)</TD><TD>98%  (11.8/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">getPropKey (Node): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (47/49)</TD><TD>93%  (14/15)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">createCallOrNew (int, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (51/53)</TD><TD>94%  (15/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">transformXmlLiteral (XmlLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (133/138)</TD><TD>97%  (30/31)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">transformBlock (AstNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>97%  (60/62)</TD><TD>98%  (12.8/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">transformObjectLiteral (ObjectLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>98%  (115/117)</TD><TD>97%  (28/29)</TD></TR><TR><TD CLASS="f"><A HREF="#21">IRFactory (CompilerEnvirons): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">IRFactory (CompilerEnvirons, ErrorReporter): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#23">createCondExpr (Node, Node, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (21/21)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">createFor (Scope, Node, Node, Node, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (38/38)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="f"><A HREF="#25">createIf (Node, Node, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (69/69)</TD><TD>100% (22/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">createLoop (Jump, int, Node, Node, Node, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (124/124)</TD><TD>100% (32/32)</TD></TR><TR><TD CLASS="f"><A HREF="#27">createMemberRefGet (Node, String, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (67/67)</TD><TD>100% (15/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">createString (String): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#29">createTryCatchFinally (Node, Node, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (229/229)</TD><TD>100% (60/60)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">createUnary (int, Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (150/150)</TD><TD>100% (40/40)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">createWith (Node, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (33/33)</TD><TD>100% (7/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">decompileArrayLiteral (ArrayLiteral): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (39/39)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">decompileObjectLiteral (ObjectLiteral): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (56/56)</TD><TD>100% (14/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">decompilePropertyGet (PropertyGet): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (13/13)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">initFunction (FunctionNode, int, Node, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (83/83)</TD><TD>100% (17/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">isAlwaysDefinedBoolean (Node): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#31">isDestructuring (Node): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">makeJump (int, Node): Jump</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#33">makeReference (Node): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">transformArrayLiteral (ArrayLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (100/100)</TD><TD>100% (23/23)</TD></TR><TR><TD CLASS="f"><A HREF="#35">transformAssignment (Assignment): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (36/36)</TD><TD>100% (8/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">transformBreak (BreakStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#37">transformCondExpr (ConditionalExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (29/29)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">transformContinue (ContinueStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#39">transformDefaultXmlNamepace (UnaryExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (26/26)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">transformElementGet (ElementGet): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (25/25)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">transformExprStmt (ExpressionStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (18/18)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">transformForInLoop (ForInLoop): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (83/83)</TD><TD>100% (19/19)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">transformFunctionCall (FunctionCall): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (53/53)</TD><TD>100% (11/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">transformIf (IfStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (60/60)</TD><TD>100% (14/14)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">transformInfix (InfixExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (29/29)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">transformLabeledStatement (LabeledStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (86/86)</TD><TD>100% (19/19)</TD></TR><TR><TD CLASS="f"><A HREF="#41">transformLiteral (AstNode): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">transformName (Name): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#43">transformNewExpr (NewExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (66/66)</TD><TD>100% (14/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">transformNumber (NumberLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#45">transformParenExpr (ParenthesizedExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (43/43)</TD><TD>100% (12/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">transformPropertyGet (PropertyGet): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#47">transformRegExp (RegExpLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (13/13)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">transformReturn (ReturnStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (51/51)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#49">transformString (StringLiteral): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">transformSwitch (SwitchStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (107/107)</TD><TD>100% (26/26)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">transformThrow (ThrowStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (21/21)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">transformTree (AstRoot): ScriptNode</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (38/38)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">transformTry (TryStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (129/129)</TD><TD>100% (30/30)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">transformUnary (UnaryExpression): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (47/47)</TD><TD>100% (11/11)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">transformVariableInitializers (VariableDeclaration): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (92/92)</TD><TD>100% (27/27)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">transformVariables (VariableDeclaration): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#51">transformWith (WithStatement): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (37/37)</TD><TD>100% (8/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">transformXmlMemberGet (XmlMemberGet): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (38/38)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#53">transformXmlRef (Node, XmlRef, int): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (68/68)</TD><TD>100% (15/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">transformXmlRef (XmlRef): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (13/13)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#55">transformYield (Yield): Node</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (31/31)</TD><TD>100% (5/5)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</TD></TR><TR><TD CLASS="l">2</TD><TD> *</TD></TR><TR><TD CLASS="l">3</TD><TD> * This Source Code Form is subject to the terms of the Mozilla Public</TD></TR><TR><TD CLASS="l">4</TD><TD> * License, v. 2.0. If a copy of the MPL was not distributed with this</TD></TR><TR><TD CLASS="l">5</TD><TD> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</TD></TR><TR><TD CLASS="l">6</TD><TD> </TD></TR><TR><TD CLASS="l">7</TD><TD>package org.mozilla.javascript;</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>import org.mozilla.javascript.ast.*;</TD></TR><TR><TD CLASS="l">10</TD><TD> </TD></TR><TR><TD CLASS="l">11</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">12</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">13</TD><TD> </TD></TR><TR><TD CLASS="l">14</TD><TD>/**</TD></TR><TR><TD CLASS="l">15</TD><TD> * This class rewrites the parse tree into an IR suitable for codegen.</TD></TR><TR><TD CLASS="l">16</TD><TD> *</TD></TR><TR><TD CLASS="l">17</TD><TD> * @see Node</TD></TR><TR><TD CLASS="l">18</TD><TD> * @author Mike McCabe</TD></TR><TR><TD CLASS="l">19</TD><TD> * @author Norris Boyd</TD></TR><TR><TD CLASS="l">20</TD><TD> */</TD></TR><TR><TD CLASS="l">21</TD><TD>public final class IRFactory extends Parser</TD></TR><TR><TD CLASS="l">22</TD><TD>{</TD></TR><TR><TD CLASS="l">23</TD><TD>    private static final int LOOP_DO_WHILE = 0;</TD></TR><TR><TD CLASS="l">24</TD><TD>    private static final int LOOP_WHILE    = 1;</TD></TR><TR><TD CLASS="l">25</TD><TD>    private static final int LOOP_FOR      = 2;</TD></TR><TR><TD CLASS="l">26</TD><TD> </TD></TR><TR><TD CLASS="l">27</TD><TD>    private static final int ALWAYS_TRUE_BOOLEAN = 1;</TD></TR><TR><TD CLASS="l">28</TD><TD>    private static final int ALWAYS_FALSE_BOOLEAN = -1;</TD></TR><TR><TD CLASS="l"><A NAME="0">29</A></TD><TD> </TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="56% line coverage (10 out of 18 instructions)">30</TD><TD TITLE="56% line coverage (10 out of 18 instructions)">    private Decompiler decompiler = new Decompiler();</TD></TR><TR><TD CLASS="l">31</TD><TD> </TD></TR><TR><TD CLASS="l">32</TD><TD>    public IRFactory() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="21">33</A></TD><TD>        super();</TD></TR><TR CLASS="z"><TD CLASS="l">34</TD><TD>    }</TD></TR><TR><TD CLASS="l">35</TD><TD> </TD></TR><TR><TD CLASS="l">36</TD><TD>    public IRFactory(CompilerEnvirons env) {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="22">37</A></TD><TD>        this(env, env.getErrorReporter());</TD></TR><TR CLASS="c"><TD CLASS="l">38</TD><TD>    }</TD></TR><TR><TD CLASS="l">39</TD><TD> </TD></TR><TR><TD CLASS="l">40</TD><TD>    public IRFactory(CompilerEnvirons env, ErrorReporter errorReporter) {</TD></TR><TR CLASS="c"><TD CLASS="l">41</TD><TD>        super(env, errorReporter);</TD></TR><TR CLASS="c"><TD CLASS="l">42</TD><TD>    }</TD></TR><TR><TD CLASS="l">43</TD><TD> </TD></TR><TR><TD CLASS="l">44</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="4c">45</A></TD><TD>     * Transforms the tree into a lower-level IR suitable for codegen.</TD></TR><TR><TD CLASS="l">46</TD><TD>     * Optionally generates the encoded source.</TD></TR><TR><TD CLASS="l">47</TD><TD>     */</TD></TR><TR><TD CLASS="l">48</TD><TD>    public ScriptNode transformTree(AstRoot root) {</TD></TR><TR CLASS="c"><TD CLASS="l">49</TD><TD>        currentScriptOrFn = root;</TD></TR><TR CLASS="c"><TD CLASS="l">50</TD><TD>        this.inUseStrictDirective = root.isInStrictMode();</TD></TR><TR CLASS="c"><TD CLASS="l">51</TD><TD>        int sourceStartOffset = decompiler.getCurrentOffset();</TD></TR><TR><TD CLASS="l">52</TD><TD> </TD></TR><TR><TD CLASS="l">53</TD><TD>        if (Token.printTrees) {</TD></TR><TR><TD CLASS="l">54</TD><TD>            System.out.println(&#34;IRFactory.transformTree&#34;);</TD></TR><TR><TD CLASS="l">55</TD><TD>            System.out.println(root.debugPrint());</TD></TR><TR><TD CLASS="l">56</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">57</TD><TD>        ScriptNode script = (ScriptNode)transform(root);</TD></TR><TR><TD CLASS="l">58</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">59</TD><TD>        int sourceEndOffset = decompiler.getCurrentOffset();</TD></TR><TR CLASS="c"><TD CLASS="l">60</TD><TD>        script.setEncodedSourceBounds(sourceStartOffset,</TD></TR><TR><TD CLASS="l">61</TD><TD>                                      sourceEndOffset);</TD></TR><TR><TD CLASS="l">62</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">63</TD><TD>        if (compilerEnv.isGeneratingSource()) {</TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>            script.setEncodedSource(decompiler.getEncodedSource());</TD></TR><TR><TD CLASS="l">65</TD><TD>        }</TD></TR><TR><TD CLASS="l">66</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">67</TD><TD>        decompiler = null;</TD></TR><TR CLASS="c"><TD CLASS="l">68</TD><TD>        return script;</TD></TR><TR><TD CLASS="l">69</TD><TD>    }</TD></TR><TR><TD CLASS="l">70</TD><TD> </TD></TR><TR><TD CLASS="l">71</TD><TD>    // Might want to convert this to polymorphism - move transform*</TD></TR><TR><TD CLASS="l"><A NAME="18">72</A></TD><TD>    // functions into the AstNode subclasses.  OTOH that would make</TD></TR><TR><TD CLASS="l">73</TD><TD>    // IR transformation part of the public AST API - desirable?</TD></TR><TR><TD CLASS="l">74</TD><TD>    // Another possibility:  create AstTransformer interface and adapter.</TD></TR><TR><TD CLASS="l">75</TD><TD>    public Node transform(AstNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">76</TD><TD>        switch (node.getType()) {</TD></TR><TR><TD CLASS="l">77</TD><TD>          case Token.ARRAYCOMP:</TD></TR><TR CLASS="c"><TD CLASS="l">78</TD><TD>              return transformArrayComp((ArrayComprehension)node);</TD></TR><TR><TD CLASS="l">79</TD><TD>          case Token.ARRAYLIT:</TD></TR><TR CLASS="c"><TD CLASS="l">80</TD><TD>              return transformArrayLiteral((ArrayLiteral)node);</TD></TR><TR><TD CLASS="l">81</TD><TD>          case Token.BLOCK:</TD></TR><TR CLASS="c"><TD CLASS="l">82</TD><TD>              return transformBlock(node);</TD></TR><TR><TD CLASS="l">83</TD><TD>          case Token.BREAK:</TD></TR><TR CLASS="c"><TD CLASS="l">84</TD><TD>              return transformBreak((BreakStatement)node);</TD></TR><TR><TD CLASS="l">85</TD><TD>          case Token.CALL:</TD></TR><TR CLASS="c"><TD CLASS="l">86</TD><TD>              return transformFunctionCall((FunctionCall)node);</TD></TR><TR><TD CLASS="l">87</TD><TD>          case Token.CONTINUE:</TD></TR><TR CLASS="c"><TD CLASS="l">88</TD><TD>              return transformContinue((ContinueStatement)node);</TD></TR><TR><TD CLASS="l">89</TD><TD>          case Token.DO:</TD></TR><TR CLASS="c"><TD CLASS="l">90</TD><TD>              return transformDoLoop((DoLoop)node);</TD></TR><TR><TD CLASS="l">91</TD><TD>          case Token.EMPTY:</TD></TR><TR CLASS="c"><TD CLASS="l">92</TD><TD>              return node;</TD></TR><TR><TD CLASS="l">93</TD><TD>          case Token.FOR:</TD></TR><TR CLASS="c"><TD CLASS="l">94</TD><TD>              if (node instanceof ForInLoop) {</TD></TR><TR CLASS="c"><TD CLASS="l">95</TD><TD>                  return transformForInLoop((ForInLoop)node);</TD></TR><TR><TD CLASS="l">96</TD><TD>              } else {</TD></TR><TR CLASS="c"><TD CLASS="l">97</TD><TD>                  return transformForLoop((ForLoop)node);</TD></TR><TR><TD CLASS="l">98</TD><TD>              }</TD></TR><TR><TD CLASS="l">99</TD><TD>          case Token.FUNCTION:</TD></TR><TR CLASS="c"><TD CLASS="l">100</TD><TD>              return transformFunction((FunctionNode)node);</TD></TR><TR><TD CLASS="l">101</TD><TD>          case Token.GENEXPR:</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>              return transformGenExpr((GeneratorExpression)node);</TD></TR><TR><TD CLASS="l">103</TD><TD>          case Token.GETELEM:</TD></TR><TR CLASS="c"><TD CLASS="l">104</TD><TD>              return transformElementGet((ElementGet)node);</TD></TR><TR><TD CLASS="l">105</TD><TD>          case Token.GETPROP:</TD></TR><TR CLASS="c"><TD CLASS="l">106</TD><TD>              return transformPropertyGet((PropertyGet)node);</TD></TR><TR><TD CLASS="l">107</TD><TD>          case Token.HOOK:</TD></TR><TR CLASS="c"><TD CLASS="l">108</TD><TD>              return transformCondExpr((ConditionalExpression)node);</TD></TR><TR><TD CLASS="l">109</TD><TD>          case Token.IF:</TD></TR><TR CLASS="c"><TD CLASS="l">110</TD><TD>              return transformIf((IfStatement)node);</TD></TR><TR><TD CLASS="l">111</TD><TD> </TD></TR><TR><TD CLASS="l">112</TD><TD>          case Token.TRUE:</TD></TR><TR><TD CLASS="l">113</TD><TD>          case Token.FALSE:</TD></TR><TR><TD CLASS="l">114</TD><TD>          case Token.THIS:</TD></TR><TR><TD CLASS="l">115</TD><TD>          case Token.NULL:</TD></TR><TR><TD CLASS="l">116</TD><TD>          case Token.DEBUGGER:</TD></TR><TR CLASS="c"><TD CLASS="l">117</TD><TD>              return transformLiteral(node);</TD></TR><TR><TD CLASS="l">118</TD><TD> </TD></TR><TR><TD CLASS="l">119</TD><TD>          case Token.NAME:</TD></TR><TR CLASS="c"><TD CLASS="l">120</TD><TD>              return transformName((Name)node);</TD></TR><TR><TD CLASS="l">121</TD><TD>          case Token.NUMBER:</TD></TR><TR CLASS="c"><TD CLASS="l">122</TD><TD>              return transformNumber((NumberLiteral)node);</TD></TR><TR><TD CLASS="l">123</TD><TD>          case Token.NEW:</TD></TR><TR CLASS="c"><TD CLASS="l">124</TD><TD>              return transformNewExpr((NewExpression)node);</TD></TR><TR><TD CLASS="l">125</TD><TD>          case Token.OBJECTLIT:</TD></TR><TR CLASS="c"><TD CLASS="l">126</TD><TD>              return transformObjectLiteral((ObjectLiteral)node);</TD></TR><TR><TD CLASS="l">127</TD><TD>          case Token.REGEXP:</TD></TR><TR CLASS="c"><TD CLASS="l">128</TD><TD>              return transformRegExp((RegExpLiteral)node);</TD></TR><TR><TD CLASS="l">129</TD><TD>          case Token.RETURN:</TD></TR><TR CLASS="c"><TD CLASS="l">130</TD><TD>              return transformReturn((ReturnStatement)node);</TD></TR><TR><TD CLASS="l">131</TD><TD>          case Token.SCRIPT:</TD></TR><TR CLASS="c"><TD CLASS="l">132</TD><TD>              return transformScript((ScriptNode)node);</TD></TR><TR><TD CLASS="l">133</TD><TD>          case Token.STRING:</TD></TR><TR CLASS="c"><TD CLASS="l">134</TD><TD>              return transformString((StringLiteral)node);</TD></TR><TR><TD CLASS="l">135</TD><TD>          case Token.SWITCH:</TD></TR><TR CLASS="c"><TD CLASS="l">136</TD><TD>              return transformSwitch((SwitchStatement)node);</TD></TR><TR><TD CLASS="l">137</TD><TD>          case Token.THROW:</TD></TR><TR CLASS="c"><TD CLASS="l">138</TD><TD>              return transformThrow((ThrowStatement)node);</TD></TR><TR><TD CLASS="l">139</TD><TD>          case Token.TRY:</TD></TR><TR CLASS="c"><TD CLASS="l">140</TD><TD>              return transformTry((TryStatement)node);</TD></TR><TR><TD CLASS="l">141</TD><TD>          case Token.WHILE:</TD></TR><TR CLASS="c"><TD CLASS="l">142</TD><TD>              return transformWhileLoop((WhileLoop)node);</TD></TR><TR><TD CLASS="l">143</TD><TD>          case Token.WITH:</TD></TR><TR CLASS="c"><TD CLASS="l">144</TD><TD>              return transformWith((WithStatement)node);</TD></TR><TR><TD CLASS="l">145</TD><TD>          case Token.YIELD:</TD></TR><TR CLASS="c"><TD CLASS="l">146</TD><TD>              return transformYield((Yield)node);</TD></TR><TR><TD CLASS="l">147</TD><TD>          default:</TD></TR><TR CLASS="c"><TD CLASS="l">148</TD><TD>              if (node instanceof ExpressionStatement) {</TD></TR><TR CLASS="c"><TD CLASS="l">149</TD><TD>                  return transformExprStmt((ExpressionStatement)node);</TD></TR><TR><TD CLASS="l">150</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">151</TD><TD>              if (node instanceof Assignment) {</TD></TR><TR CLASS="c"><TD CLASS="l">152</TD><TD>                  return transformAssignment((Assignment)node);</TD></TR><TR><TD CLASS="l">153</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">154</TD><TD>              if (node instanceof UnaryExpression) {</TD></TR><TR CLASS="c"><TD CLASS="l">155</TD><TD>                  return transformUnary((UnaryExpression)node);</TD></TR><TR><TD CLASS="l">156</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">157</TD><TD>              if (node instanceof XmlMemberGet) {</TD></TR><TR CLASS="c"><TD CLASS="l">158</TD><TD>                  return transformXmlMemberGet((XmlMemberGet)node);</TD></TR><TR><TD CLASS="l">159</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">160</TD><TD>              if (node instanceof InfixExpression) {</TD></TR><TR CLASS="c"><TD CLASS="l">161</TD><TD>                  return transformInfix((InfixExpression)node);</TD></TR><TR><TD CLASS="l">162</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">163</TD><TD>              if (node instanceof VariableDeclaration) {</TD></TR><TR CLASS="c"><TD CLASS="l">164</TD><TD>                  return transformVariables((VariableDeclaration)node);</TD></TR><TR><TD CLASS="l">165</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">166</TD><TD>              if (node instanceof ParenthesizedExpression) {</TD></TR><TR CLASS="c"><TD CLASS="l">167</TD><TD>                  return transformParenExpr((ParenthesizedExpression)node);</TD></TR><TR><TD CLASS="l">168</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">169</TD><TD>              if (node instanceof LabeledStatement) {</TD></TR><TR CLASS="c"><TD CLASS="l">170</TD><TD>                  return transformLabeledStatement((LabeledStatement)node);</TD></TR><TR><TD CLASS="l">171</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">172</TD><TD>              if (node instanceof LetNode) {</TD></TR><TR CLASS="c"><TD CLASS="l">173</TD><TD>                  return transformLetNode((LetNode)node);</TD></TR><TR><TD CLASS="l">174</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">175</TD><TD>              if (node instanceof XmlRef) {</TD></TR><TR CLASS="c"><TD CLASS="l">176</TD><TD>                  return transformXmlRef((XmlRef)node);</TD></TR><TR><TD CLASS="l">177</TD><TD>              }</TD></TR><TR CLASS="c"><TD CLASS="l">178</TD><TD>              if (node instanceof XmlLiteral) {</TD></TR><TR CLASS="c"><TD CLASS="l">179</TD><TD>                  return transformXmlLiteral((XmlLiteral)node);</TD></TR><TR><TD CLASS="l">180</TD><TD>              }</TD></TR><TR CLASS="z"><TD CLASS="l">181</TD><TD>              throw new IllegalArgumentException(&#34;Can't transform: &#34; + node);</TD></TR><TR><TD CLASS="l">182</TD><TD>        }</TD></TR><TR><TD CLASS="l">183</TD><TD>    }</TD></TR><TR><TD CLASS="l">184</TD><TD> </TD></TR><TR><TD CLASS="l">185</TD><TD>    private Node transformArrayComp(ArrayComprehension node) {</TD></TR><TR><TD CLASS="l">186</TD><TD>        // An array comprehension expression such as</TD></TR><TR><TD CLASS="l">187</TD><TD>        //</TD></TR><TR><TD CLASS="l">188</TD><TD>        //   [expr for (x in foo) for each ([y, z] in bar) if (cond)]</TD></TR><TR><TD CLASS="l">189</TD><TD>        //</TD></TR><TR><TD CLASS="l">190</TD><TD>        // is rewritten approximately as</TD></TR><TR><TD CLASS="l">191</TD><TD>        //</TD></TR><TR><TD CLASS="l">192</TD><TD>        // new Scope(ARRAYCOMP) {</TD></TR><TR><TD CLASS="l">193</TD><TD>        //   new Node(BLOCK) {</TD></TR><TR><TD CLASS="l">194</TD><TD>        //     let tmp1 = new Array;</TD></TR><TR><TD CLASS="l">195</TD><TD>        //     for (let x in foo) {</TD></TR><TR><TD CLASS="l">196</TD><TD>        //       for each (let tmp2 in bar) {</TD></TR><TR><TD CLASS="l">197</TD><TD>        //         if (cond) {</TD></TR><TR><TD CLASS="l">198</TD><TD>        //           tmp1.push([y, z] = tmp2, expr);</TD></TR><TR><TD CLASS="l">199</TD><TD>        //         }</TD></TR><TR><TD CLASS="l">200</TD><TD>        //       }</TD></TR><TR><TD CLASS="l">201</TD><TD>        //     }</TD></TR><TR><TD CLASS="l"><A NAME="17">202</A></TD><TD>        //   }</TD></TR><TR><TD CLASS="l">203</TD><TD>        //   createName(tmp1)</TD></TR><TR><TD CLASS="l">204</TD><TD>        // }</TD></TR><TR><TD CLASS="l">205</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">206</TD><TD>        int lineno = node.getLineno();</TD></TR><TR CLASS="c"><TD CLASS="l">207</TD><TD>        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">208</TD><TD>        String arrayName = currentScriptOrFn.getNextTempName();</TD></TR><TR CLASS="c"><TD CLASS="l">209</TD><TD>        pushScope(scopeNode);</TD></TR><TR><TD CLASS="l">210</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">211</TD><TD>            defineSymbol(Token.LET, arrayName, false);</TD></TR><TR CLASS="c"><TD CLASS="l">212</TD><TD>            Node block = new Node(Token.BLOCK, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">213</TD><TD>            Node newArray = createCallOrNew(Token.NEW, createName(&#34;Array&#34;));</TD></TR><TR CLASS="c"><TD CLASS="l">214</TD><TD>            Node init = new Node(Token.EXPR_VOID,</TD></TR><TR><TD CLASS="l">215</TD><TD>                                 createAssignment(Token.ASSIGN,</TD></TR><TR><TD CLASS="l">216</TD><TD>                                                  createName(arrayName),</TD></TR><TR><TD CLASS="l">217</TD><TD>                                                  newArray),</TD></TR><TR><TD CLASS="l">218</TD><TD>                                 lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">219</TD><TD>            block.addChildToBack(init);</TD></TR><TR CLASS="c"><TD CLASS="l">220</TD><TD>            block.addChildToBack(arrayCompTransformHelper(node, arrayName));</TD></TR><TR CLASS="c"><TD CLASS="l">221</TD><TD>            scopeNode.addChildToBack(block);</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>            scopeNode.addChildToBack(createName(arrayName));</TD></TR><TR CLASS="c"><TD CLASS="l">223</TD><TD>            return scopeNode;</TD></TR><TR><TD CLASS="l">224</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="93% line coverage (69 out of 74 instructions)">225</TD><TD TITLE="93% line coverage (69 out of 74 instructions)">            popScope();</TD></TR><TR><TD CLASS="l">226</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="1a">227</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">228</TD><TD> </TD></TR><TR><TD CLASS="l">229</TD><TD>    private Node arrayCompTransformHelper(ArrayComprehension node,</TD></TR><TR><TD CLASS="l">230</TD><TD>                                          String arrayName) {</TD></TR><TR CLASS="c"><TD CLASS="l">231</TD><TD>        decompiler.addToken(Token.LB);</TD></TR><TR CLASS="c"><TD CLASS="l">232</TD><TD>        int lineno = node.getLineno();</TD></TR><TR CLASS="c"><TD CLASS="l">233</TD><TD>        Node expr = transform(node.getResult());</TD></TR><TR><TD CLASS="l">234</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">235</TD><TD>        List&lt;ArrayComprehensionLoop&gt; loops = node.getLoops();</TD></TR><TR CLASS="c"><TD CLASS="l">236</TD><TD>        int numLoops = loops.size();</TD></TR><TR><TD CLASS="l">237</TD><TD> </TD></TR><TR><TD CLASS="l">238</TD><TD>        // Walk through loops, collecting and defining their iterator symbols.</TD></TR><TR CLASS="c"><TD CLASS="l">239</TD><TD>        Node[] iterators = new Node[numLoops];</TD></TR><TR CLASS="c"><TD CLASS="l">240</TD><TD>        Node[] iteratedObjs = new Node[numLoops];</TD></TR><TR><TD CLASS="l">241</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">242</TD><TD>        for (int i = 0; i &lt; numLoops; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">243</TD><TD>            ArrayComprehensionLoop acl = loops.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">244</TD><TD>            decompiler.addName(&#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">245</TD><TD>            decompiler.addToken(Token.FOR);</TD></TR><TR CLASS="c"><TD CLASS="l">246</TD><TD>            if (acl.isForEach()) {</TD></TR><TR CLASS="c"><TD CLASS="l">247</TD><TD>                decompiler.addName(&#34;each &#34;);</TD></TR><TR><TD CLASS="l">248</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">249</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR><TD CLASS="l">250</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">251</TD><TD>            AstNode iter = acl.getIterator();</TD></TR><TR CLASS="c"><TD CLASS="l">252</TD><TD>            String name = null;</TD></TR><TR CLASS="c"><TD CLASS="l">253</TD><TD>            if (iter.getType() == Token.NAME) {</TD></TR><TR CLASS="c"><TD CLASS="l">254</TD><TD>                name = iter.getString();</TD></TR><TR CLASS="c"><TD CLASS="l">255</TD><TD>                decompiler.addName(name);</TD></TR><TR><TD CLASS="l">256</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">257</TD><TD>                // destructuring assignment</TD></TR><TR CLASS="c"><TD CLASS="l">258</TD><TD>                decompile(iter);</TD></TR><TR CLASS="c"><TD CLASS="l">259</TD><TD>                name = currentScriptOrFn.getNextTempName();</TD></TR><TR CLASS="c"><TD CLASS="l">260</TD><TD>                defineSymbol(Token.LP, name, false);</TD></TR><TR CLASS="c"><TD CLASS="l">261</TD><TD>                expr = createBinary(Token.COMMA,</TD></TR><TR><TD CLASS="l">262</TD><TD>                                    createAssignment(Token.ASSIGN,</TD></TR><TR><TD CLASS="l">263</TD><TD>                                                     iter,</TD></TR><TR><TD CLASS="l">264</TD><TD>                                                     createName(name)),</TD></TR><TR><TD CLASS="l">265</TD><TD>                                    expr);</TD></TR><TR><TD CLASS="l">266</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">267</TD><TD>            Node init = createName(name);</TD></TR><TR><TD CLASS="l">268</TD><TD>            // Define as a let since we want the scope of the variable to</TD></TR><TR><TD CLASS="l">269</TD><TD>            // be restricted to the array comprehension</TD></TR><TR CLASS="c"><TD CLASS="l">270</TD><TD>            defineSymbol(Token.LET, name, false);</TD></TR><TR CLASS="c"><TD CLASS="l">271</TD><TD>            iterators[i] = init;</TD></TR><TR><TD CLASS="l">272</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">273</TD><TD>            decompiler.addToken(Token.IN);</TD></TR><TR CLASS="c"><TD CLASS="l">274</TD><TD>            iteratedObjs[i] = transform(acl.getIteratedObject());</TD></TR><TR CLASS="c"><TD CLASS="l">275</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">276</TD><TD>        }</TD></TR><TR><TD CLASS="l">277</TD><TD> </TD></TR><TR><TD CLASS="l">278</TD><TD>        // generate code for tmpArray.push(body)</TD></TR><TR CLASS="c"><TD CLASS="l">279</TD><TD>        Node call = createCallOrNew(Token.CALL,</TD></TR><TR><TD CLASS="l">280</TD><TD>                                    createPropertyGet(createName(arrayName),</TD></TR><TR><TD CLASS="l">281</TD><TD>                                                      null,</TD></TR><TR><TD CLASS="l">282</TD><TD>                                                      &#34;push&#34;, 0));</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">284</TD><TD>        Node body = new Node(Token.EXPR_VOID, call, lineno);</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">286</TD><TD>        if (node.getFilter() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>            decompiler.addName(&#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">288</TD><TD>            decompiler.addToken(Token.IF);</TD></TR><TR CLASS="c"><TD CLASS="l">289</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">290</TD><TD>            body = createIf(transform(node.getFilter()), body, null, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">291</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">292</TD><TD>        }</TD></TR><TR><TD CLASS="l">293</TD><TD> </TD></TR><TR><TD CLASS="l">294</TD><TD>        // Now walk loops in reverse to build up the body statement.</TD></TR><TR CLASS="c"><TD CLASS="l">295</TD><TD>        int pushed = 0;</TD></TR><TR><TD CLASS="l">296</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">297</TD><TD>            for (int i = numLoops-1; i &gt;= 0; i--) {</TD></TR><TR CLASS="c"><TD CLASS="l">298</TD><TD>                ArrayComprehensionLoop acl = loops.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">299</TD><TD>                Scope loop = createLoopNode(null,  // no label</TD></TR><TR><TD CLASS="l">300</TD><TD>                                            acl.getLineno());</TD></TR><TR CLASS="c"><TD CLASS="l">301</TD><TD>                pushScope(loop);</TD></TR><TR CLASS="c"><TD CLASS="l">302</TD><TD>                pushed++;</TD></TR><TR CLASS="c"><TD CLASS="l">303</TD><TD>                body = createForIn(Token.LET,</TD></TR><TR><TD CLASS="l">304</TD><TD>                                   loop,</TD></TR><TR><TD CLASS="l">305</TD><TD>                                   iterators[i],</TD></TR><TR><TD CLASS="l">306</TD><TD>                                   iteratedObjs[i],</TD></TR><TR><TD CLASS="l">307</TD><TD>                                   body,</TD></TR><TR><TD CLASS="l">308</TD><TD>                                   acl.isForEach());</TD></TR><TR><TD CLASS="l">309</TD><TD>            }</TD></TR><TR><TD CLASS="l">310</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="43% line coverage (9 out of 21 instructions)">311</TD><TD TITLE="43% line coverage (9 out of 21 instructions)">            for (int i = 0; i &lt; pushed; i++) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="50% line coverage (4 out of 8 instructions)">312</TD><TD TITLE="50% line coverage (4 out of 8 instructions)">                popScope();</TD></TR><TR><TD CLASS="l">313</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>        }</TD></TR><TR><TD CLASS="l">315</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">316</TD><TD>        decompiler.addToken(Token.RB);</TD></TR><TR><TD CLASS="l">317</TD><TD> </TD></TR><TR><TD CLASS="l">318</TD><TD>        // Now that we've accumulated any destructuring forms,</TD></TR><TR><TD CLASS="l">319</TD><TD>        // add expr to the call node; it's pushed on each iteration.</TD></TR><TR CLASS="c"><TD CLASS="l">320</TD><TD>        call.addChildToBack(expr);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="34">321</A></TD><TD>        return body;</TD></TR><TR><TD CLASS="l">322</TD><TD>    }</TD></TR><TR><TD CLASS="l">323</TD><TD> </TD></TR><TR><TD CLASS="l">324</TD><TD>    private Node transformArrayLiteral(ArrayLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">325</TD><TD>        if (node.isDestructuring()) {</TD></TR><TR CLASS="c"><TD CLASS="l">326</TD><TD>            return node;</TD></TR><TR><TD CLASS="l">327</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">328</TD><TD>        decompiler.addToken(Token.LB);</TD></TR><TR CLASS="c"><TD CLASS="l">329</TD><TD>        List&lt;AstNode&gt; elems = node.getElements();</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>        Node array = new Node(Token.ARRAYLIT);</TD></TR><TR CLASS="c"><TD CLASS="l">331</TD><TD>        List&lt;Integer&gt; skipIndexes = null;</TD></TR><TR CLASS="c"><TD CLASS="l">332</TD><TD>        for (int i = 0; i &lt; elems.size(); ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">333</TD><TD>            AstNode elem = elems.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">334</TD><TD>            if (elem.getType() != Token.EMPTY) {</TD></TR><TR CLASS="c"><TD CLASS="l">335</TD><TD>                array.addChildToBack(transform(elem));</TD></TR><TR><TD CLASS="l">336</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">337</TD><TD>                if (skipIndexes == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>                    skipIndexes = new ArrayList&lt;Integer&gt;();</TD></TR><TR><TD CLASS="l">339</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">340</TD><TD>                skipIndexes.add(i);</TD></TR><TR><TD CLASS="l">341</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">342</TD><TD>            if (i &lt; elems.size() - 1)</TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">344</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        decompiler.addToken(Token.RB);</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,</TD></TR><TR><TD CLASS="l">347</TD><TD>                         node.getDestructuringLength());</TD></TR><TR CLASS="c"><TD CLASS="l">348</TD><TD>        if (skipIndexes != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">349</TD><TD>            int[] skips = new int[skipIndexes.size()];</TD></TR><TR CLASS="c"><TD CLASS="l">350</TD><TD>            for (int i = 0; i &lt; skipIndexes.size(); i++)</TD></TR><TR CLASS="c"><TD CLASS="l">351</TD><TD>                skips[i] = skipIndexes.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>            array.putProp(Node.SKIP_INDEXES_PROP, skips);</TD></TR><TR><TD CLASS="l">353</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="35">354</A></TD><TD>        return array;</TD></TR><TR><TD CLASS="l">355</TD><TD>    }</TD></TR><TR><TD CLASS="l">356</TD><TD> </TD></TR><TR><TD CLASS="l">357</TD><TD>    private Node transformAssignment(Assignment node) {</TD></TR><TR CLASS="c"><TD CLASS="l">358</TD><TD>        AstNode left = removeParens(node.getLeft());</TD></TR><TR CLASS="c"><TD CLASS="l">359</TD><TD>        Node target = null;</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        if (isDestructuring(left)) {</TD></TR><TR CLASS="c"><TD CLASS="l">361</TD><TD>            decompile(left);</TD></TR><TR CLASS="c"><TD CLASS="l">362</TD><TD>            target = left;</TD></TR><TR><TD CLASS="l">363</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">364</TD><TD>            target = transform(left);</TD></TR><TR><TD CLASS="l">365</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">366</TD><TD>        decompiler.addToken(node.getType());</TD></TR><TR CLASS="c"><TD CLASS="l">367</TD><TD>        return createAssignment(node.getType(),</TD></TR><TR><TD CLASS="l">368</TD><TD>                                target,</TD></TR><TR><TD CLASS="l"><A NAME="1f">369</A></TD><TD>                                transform(node.getRight()));</TD></TR><TR><TD CLASS="l">370</TD><TD>    }</TD></TR><TR><TD CLASS="l">371</TD><TD> </TD></TR><TR><TD CLASS="l">372</TD><TD>    private Node transformBlock(AstNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">373</TD><TD>        if (node instanceof Scope) {</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>            pushScope((Scope)node);</TD></TR><TR><TD CLASS="l">375</TD><TD>        }</TD></TR><TR><TD CLASS="l">376</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">377</TD><TD>            List&lt;Node&gt; kids = new ArrayList&lt;Node&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">378</TD><TD>            for (Node kid : node) {</TD></TR><TR CLASS="c"><TD CLASS="l">379</TD><TD>                kids.add(transform((AstNode)kid));</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>            node.removeChildren();</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>            for (Node kid : kids) {</TD></TR><TR CLASS="c"><TD CLASS="l">383</TD><TD>                node.addChildToBack(kid);</TD></TR><TR CLASS="c"><TD CLASS="l">384</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>            return node;</TD></TR><TR><TD CLASS="l">386</TD><TD>        } finally {</TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>            if (node instanceof Scope) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (6 out of 8 instructions)">388</TD><TD TITLE="75% line coverage (6 out of 8 instructions)">                popScope();</TD></TR><TR><TD CLASS="l">389</TD><TD>            }</TD></TR><TR><TD CLASS="l"><A NAME="36">390</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">391</TD><TD>    }</TD></TR><TR><TD CLASS="l">392</TD><TD> </TD></TR><TR><TD CLASS="l">393</TD><TD>    private Node transformBreak(BreakStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">394</TD><TD>        decompiler.addToken(Token.BREAK);</TD></TR><TR CLASS="c"><TD CLASS="l">395</TD><TD>        if (node.getBreakLabel() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">396</TD><TD>            decompiler.addName(node.getBreakLabel().getIdentifier());</TD></TR><TR><TD CLASS="l">397</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">398</TD><TD>        decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="37">399</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">400</TD><TD>    }</TD></TR><TR><TD CLASS="l">401</TD><TD> </TD></TR><TR><TD CLASS="l">402</TD><TD>    private Node transformCondExpr(ConditionalExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">403</TD><TD>        Node test = transform(node.getTestExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">404</TD><TD>        decompiler.addToken(Token.HOOK);</TD></TR><TR CLASS="c"><TD CLASS="l">405</TD><TD>        Node ifTrue = transform(node.getTrueExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">406</TD><TD>        decompiler.addToken(Token.COLON);</TD></TR><TR CLASS="c"><TD CLASS="l">407</TD><TD>        Node ifFalse = transform(node.getFalseExpression());</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="38">408</A></TD><TD>        return createCondExpr(test, ifTrue, ifFalse);</TD></TR><TR><TD CLASS="l">409</TD><TD>    }</TD></TR><TR><TD CLASS="l">410</TD><TD> </TD></TR><TR><TD CLASS="l">411</TD><TD>    private Node transformContinue(ContinueStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">412</TD><TD>        decompiler.addToken(Token.CONTINUE);</TD></TR><TR CLASS="c"><TD CLASS="l">413</TD><TD>        if (node.getLabel() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">414</TD><TD>            decompiler.addName(node.getLabel().getIdentifier());</TD></TR><TR><TD CLASS="l">415</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">416</TD><TD>        decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="11">417</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">418</TD><TD>    }</TD></TR><TR><TD CLASS="l">419</TD><TD> </TD></TR><TR><TD CLASS="l">420</TD><TD>    private Node transformDoLoop(DoLoop loop) {</TD></TR><TR CLASS="c"><TD CLASS="l">421</TD><TD>        loop.setType(Token.LOOP);</TD></TR><TR CLASS="c"><TD CLASS="l">422</TD><TD>        pushScope(loop);</TD></TR><TR><TD CLASS="l">423</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>            decompiler.addToken(Token.DO);</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>            Node body = transform(loop.getBody());</TD></TR><TR CLASS="c"><TD CLASS="l">427</TD><TD>            decompiler.addToken(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">428</TD><TD>            decompiler.addToken(Token.WHILE);</TD></TR><TR CLASS="c"><TD CLASS="l">429</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">430</TD><TD>            Node cond = transform(loop.getCondition());</TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">432</TD><TD>            decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l">433</TD><TD>            return createLoop(loop, LOOP_DO_WHILE,</TD></TR><TR><TD CLASS="l">434</TD><TD>                              body, cond, null, null);</TD></TR><TR><TD CLASS="l">435</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="92% line coverage (58 out of 63 instructions)">436</TD><TD TITLE="92% line coverage (58 out of 63 instructions)">            popScope();</TD></TR><TR><TD CLASS="l">437</TD><TD>        }</TD></TR><TR><TD CLASS="l">438</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="3a">439</A></TD><TD> </TD></TR><TR><TD CLASS="l">440</TD><TD>    private Node transformElementGet(ElementGet node) {</TD></TR><TR><TD CLASS="l">441</TD><TD>        // OPT: could optimize to createPropertyGet</TD></TR><TR><TD CLASS="l">442</TD><TD>        // iff elem is string that can not be number</TD></TR><TR CLASS="c"><TD CLASS="l">443</TD><TD>        Node target = transform(node.getTarget());</TD></TR><TR CLASS="c"><TD CLASS="l">444</TD><TD>        decompiler.addToken(Token.LB);</TD></TR><TR CLASS="c"><TD CLASS="l">445</TD><TD>        Node element = transform(node.getElement());</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>        decompiler.addToken(Token.RB);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="3b">447</A></TD><TD>        return new Node(Token.GETELEM, target, element);</TD></TR><TR><TD CLASS="l">448</TD><TD>    }</TD></TR><TR><TD CLASS="l">449</TD><TD> </TD></TR><TR><TD CLASS="l">450</TD><TD>    private Node transformExprStmt(ExpressionStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">451</TD><TD>        Node expr = transform(node.getExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">452</TD><TD>        decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="3c">453</A></TD><TD>        return new Node(node.getType(), expr, node.getLineno());</TD></TR><TR><TD CLASS="l">454</TD><TD>    }</TD></TR><TR><TD CLASS="l">455</TD><TD> </TD></TR><TR><TD CLASS="l">456</TD><TD>    private Node transformForInLoop(ForInLoop loop) {</TD></TR><TR CLASS="c"><TD CLASS="l">457</TD><TD>        decompiler.addToken(Token.FOR);</TD></TR><TR CLASS="c"><TD CLASS="l">458</TD><TD>        if (loop.isForEach())</TD></TR><TR CLASS="c"><TD CLASS="l">459</TD><TD>            decompiler.addName(&#34;each &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">460</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR><TD CLASS="l">461</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">462</TD><TD>        loop.setType(Token.LOOP);</TD></TR><TR CLASS="c"><TD CLASS="l">463</TD><TD>        pushScope(loop);</TD></TR><TR><TD CLASS="l">464</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">465</TD><TD>            int declType = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">466</TD><TD>            AstNode iter = loop.getIterator();</TD></TR><TR CLASS="c"><TD CLASS="l">467</TD><TD>            if (iter instanceof VariableDeclaration) {</TD></TR><TR CLASS="c"><TD CLASS="l">468</TD><TD>                declType = ((VariableDeclaration)iter).getType();</TD></TR><TR><TD CLASS="l">469</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">470</TD><TD>            Node lhs = transform(iter);</TD></TR><TR CLASS="c"><TD CLASS="l">471</TD><TD>            decompiler.addToken(Token.IN);</TD></TR><TR CLASS="c"><TD CLASS="l">472</TD><TD>            Node obj = transform(loop.getIteratedObject());</TD></TR><TR CLASS="c"><TD CLASS="l">473</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">474</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">475</TD><TD>            Node body = transform(loop.getBody());</TD></TR><TR CLASS="c"><TD CLASS="l">476</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">477</TD><TD>            return createForIn(declType, loop, lhs, obj, body,</TD></TR><TR><TD CLASS="l">478</TD><TD>                               loop.isForEach());</TD></TR><TR><TD CLASS="l">479</TD><TD>        } finally {</TD></TR><TR CLASS="c"><TD CLASS="l">480</TD><TD>            popScope();</TD></TR><TR><TD CLASS="l"><A NAME="12">481</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">482</TD><TD>    }</TD></TR><TR><TD CLASS="l">483</TD><TD> </TD></TR><TR><TD CLASS="l">484</TD><TD>    private Node transformForLoop(ForLoop loop) {</TD></TR><TR CLASS="c"><TD CLASS="l">485</TD><TD>        decompiler.addToken(Token.FOR);</TD></TR><TR CLASS="c"><TD CLASS="l">486</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>        loop.setType(Token.LOOP);</TD></TR><TR><TD CLASS="l">488</TD><TD>        // XXX: Can't use pushScope/popScope here since 'createFor' may split</TD></TR><TR><TD CLASS="l">489</TD><TD>        // the scope</TD></TR><TR CLASS="c"><TD CLASS="l">490</TD><TD>        Scope savedScope = currentScope;</TD></TR><TR CLASS="c"><TD CLASS="l">491</TD><TD>        currentScope = loop;</TD></TR><TR><TD CLASS="l">492</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">493</TD><TD>            Node init = transform(loop.getInitializer());</TD></TR><TR CLASS="c"><TD CLASS="l">494</TD><TD>            decompiler.addToken(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l">495</TD><TD>            Node test = transform(loop.getCondition());</TD></TR><TR CLASS="c"><TD CLASS="l">496</TD><TD>            decompiler.addToken(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l">497</TD><TD>            Node incr = transform(loop.getIncrement());</TD></TR><TR CLASS="c"><TD CLASS="l">498</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">499</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">500</TD><TD>            Node body = transform(loop.getBody());</TD></TR><TR CLASS="c"><TD CLASS="l">501</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>            return createFor(loop, init, test, incr, body);</TD></TR><TR><TD CLASS="l">503</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="92% line coverage (71 out of 77 instructions)">504</TD><TD TITLE="92% line coverage (71 out of 77 instructions)">            currentScope = savedScope;</TD></TR><TR><TD CLASS="l"><A NAME="c">505</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">506</TD><TD>    }</TD></TR><TR><TD CLASS="l">507</TD><TD> </TD></TR><TR><TD CLASS="l">508</TD><TD>    private Node transformFunction(FunctionNode fn) {</TD></TR><TR CLASS="c"><TD CLASS="l">509</TD><TD>        int functionType = fn.getFunctionType();</TD></TR><TR CLASS="c"><TD CLASS="l">510</TD><TD>        int start = decompiler.markFunctionStart(functionType);</TD></TR><TR CLASS="c"><TD CLASS="l">511</TD><TD>        Node mexpr = decompileFunctionHeader(fn);</TD></TR><TR CLASS="c"><TD CLASS="l">512</TD><TD>        int index = currentScriptOrFn.addFunction(fn);</TD></TR><TR><TD CLASS="l">513</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">514</TD><TD>        PerFunctionVariables savedVars = new PerFunctionVariables(fn);</TD></TR><TR><TD CLASS="l">515</TD><TD>        try {</TD></TR><TR><TD CLASS="l">516</TD><TD>            // If we start needing to record much more codegen metadata during</TD></TR><TR><TD CLASS="l">517</TD><TD>            // function parsing, we should lump it all into a helper class.</TD></TR><TR CLASS="c"><TD CLASS="l">518</TD><TD>            Node destructuring = (Node)fn.getProp(Node.DESTRUCTURING_PARAMS);</TD></TR><TR CLASS="c"><TD CLASS="l">519</TD><TD>            fn.removeProp(Node.DESTRUCTURING_PARAMS);</TD></TR><TR><TD CLASS="l">520</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">521</TD><TD>            int lineno = fn.getBody().getLineno();</TD></TR><TR CLASS="c"><TD CLASS="l">522</TD><TD>            ++nestingOfFunction;  // only for body, not params</TD></TR><TR CLASS="c"><TD CLASS="l">523</TD><TD>            Node body = transform(fn.getBody());</TD></TR><TR><TD CLASS="l">524</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">525</TD><TD>            if (!fn.isExpressionClosure()) {</TD></TR><TR CLASS="c"><TD CLASS="l">526</TD><TD>                decompiler.addToken(Token.RC);</TD></TR><TR><TD CLASS="l">527</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">528</TD><TD>            fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start));</TD></TR><TR><TD CLASS="l">529</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">530</TD><TD>            if (functionType != FunctionNode.FUNCTION_EXPRESSION &amp;&amp; !fn.isExpressionClosure()) {</TD></TR><TR><TD CLASS="l">531</TD><TD>                // Add EOL only if function is not part of expression</TD></TR><TR><TD CLASS="l">532</TD><TD>                // since it gets SEMI + EOL from Statement in that case</TD></TR><TR CLASS="c"><TD CLASS="l">533</TD><TD>                decompiler.addToken(Token.EOL);</TD></TR><TR><TD CLASS="l">534</TD><TD>            }</TD></TR><TR><TD CLASS="l">535</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">536</TD><TD>            if (destructuring != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">537</TD><TD>                body.addChildToFront(new Node(Token.EXPR_VOID,</TD></TR><TR><TD CLASS="l">538</TD><TD>                                              destructuring, lineno));</TD></TR><TR><TD CLASS="l">539</TD><TD>            }</TD></TR><TR><TD CLASS="l">540</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">541</TD><TD>            int syntheticType = fn.getFunctionType();</TD></TR><TR CLASS="c"><TD CLASS="l">542</TD><TD>            Node pn = initFunction(fn, index, body, syntheticType);</TD></TR><TR CLASS="c"><TD CLASS="l">543</TD><TD>            if (mexpr != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>                pn = createAssignment(Token.ASSIGN, mexpr, pn);</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>                if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                    pn = createExprStatementNoReturn(pn, fn.getLineno());</TD></TR><TR><TD CLASS="l">547</TD><TD>                }</TD></TR><TR><TD CLASS="l">548</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">549</TD><TD>            return pn;</TD></TR><TR><TD CLASS="l">550</TD><TD> </TD></TR><TR><TD CLASS="l">551</TD><TD>        } finally {</TD></TR><TR CLASS="c"><TD CLASS="l">552</TD><TD>            --nestingOfFunction;</TD></TR><TR CLASS="c"><TD CLASS="l">553</TD><TD>            savedVars.restore();</TD></TR><TR><TD CLASS="l"><A NAME="3d">554</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">555</TD><TD>    }</TD></TR><TR><TD CLASS="l">556</TD><TD> </TD></TR><TR><TD CLASS="l">557</TD><TD>    private Node transformFunctionCall(FunctionCall node) {</TD></TR><TR CLASS="c"><TD CLASS="l">558</TD><TD>        Node call = createCallOrNew(Token.CALL, transform(node.getTarget()));</TD></TR><TR CLASS="c"><TD CLASS="l">559</TD><TD>        call.setLineno(node.getLineno());</TD></TR><TR CLASS="c"><TD CLASS="l">560</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">561</TD><TD>        List&lt;AstNode&gt; args = node.getArguments();</TD></TR><TR CLASS="c"><TD CLASS="l">562</TD><TD>        for (int i = 0; i &lt; args.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">563</TD><TD>            AstNode arg = args.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">564</TD><TD>            call.addChildToBack(transform(arg));</TD></TR><TR CLASS="c"><TD CLASS="l">565</TD><TD>            if (i &lt; args.size() - 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">566</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">567</TD><TD>            }</TD></TR><TR><TD CLASS="l">568</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">569</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">570</TD><TD>        return call;</TD></TR><TR><TD CLASS="l">571</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="5">572</A></TD><TD>    </TD></TR><TR><TD CLASS="l">573</TD><TD>    private Node transformGenExpr(GeneratorExpression node) {</TD></TR><TR><TD CLASS="l">574</TD><TD>        Node pn;</TD></TR><TR><TD CLASS="l">575</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>        FunctionNode fn = new FunctionNode();</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>        fn.setSourceName(currentScriptOrFn.getNextTempName());</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>        fn.setIsGenerator();</TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>        fn.setFunctionType(FunctionNode.FUNCTION_EXPRESSION);</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>        fn.setRequiresActivation();</TD></TR><TR><TD CLASS="l">581</TD><TD>      </TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>        int functionType = fn.getFunctionType();</TD></TR><TR CLASS="z"><TD CLASS="l">583</TD><TD>        int start = decompiler.markFunctionStart(functionType);</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>        Node mexpr = decompileFunctionHeader(fn);</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>        int index = currentScriptOrFn.addFunction(fn);</TD></TR><TR><TD CLASS="l">586</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>        PerFunctionVariables savedVars = new PerFunctionVariables(fn);</TD></TR><TR><TD CLASS="l">588</TD><TD>        try {</TD></TR><TR><TD CLASS="l">589</TD><TD>            // If we start needing to record much more codegen metadata during</TD></TR><TR><TD CLASS="l">590</TD><TD>            // function parsing, we should lump it all into a helper class.</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>            Node destructuring = (Node)fn.getProp(Node.DESTRUCTURING_PARAMS);</TD></TR><TR CLASS="z"><TD CLASS="l">592</TD><TD>            fn.removeProp(Node.DESTRUCTURING_PARAMS);</TD></TR><TR><TD CLASS="l">593</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">594</TD><TD>            int lineno = node.lineno;</TD></TR><TR CLASS="z"><TD CLASS="l">595</TD><TD>            ++nestingOfFunction;  // only for body, not params</TD></TR><TR CLASS="z"><TD CLASS="l">596</TD><TD>            Node body = genExprTransformHelper(node);</TD></TR><TR><TD CLASS="l">597</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">598</TD><TD>            if (!fn.isExpressionClosure()) {</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>                decompiler.addToken(Token.RC);</TD></TR><TR><TD CLASS="l">600</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">601</TD><TD>            fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start));</TD></TR><TR><TD CLASS="l">602</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">603</TD><TD>            if (functionType != FunctionNode.FUNCTION_EXPRESSION &amp;&amp; !fn.isExpressionClosure()) {</TD></TR><TR><TD CLASS="l">604</TD><TD>                // Add EOL only if function is not part of expression</TD></TR><TR><TD CLASS="l">605</TD><TD>                // since it gets SEMI + EOL from Statement in that case</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>                decompiler.addToken(Token.EOL);</TD></TR><TR><TD CLASS="l">607</TD><TD>            }</TD></TR><TR><TD CLASS="l">608</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>            if (destructuring != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>                body.addChildToFront(new Node(Token.EXPR_VOID,</TD></TR><TR><TD CLASS="l">611</TD><TD>                                              destructuring, lineno));</TD></TR><TR><TD CLASS="l">612</TD><TD>            }</TD></TR><TR><TD CLASS="l">613</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>            int syntheticType = fn.getFunctionType();</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>            pn = initFunction(fn, index, body, syntheticType);</TD></TR><TR CLASS="z"><TD CLASS="l">616</TD><TD>            if (mexpr != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">617</TD><TD>                pn = createAssignment(Token.ASSIGN, mexpr, pn);</TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>                if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>                    pn = createExprStatementNoReturn(pn, fn.getLineno());</TD></TR><TR><TD CLASS="l">620</TD><TD>                }</TD></TR><TR><TD CLASS="l">621</TD><TD>            }</TD></TR><TR><TD CLASS="l">622</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>            --nestingOfFunction;</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>            savedVars.restore();</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>        }</TD></TR><TR><TD CLASS="l">626</TD><TD>       </TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>        Node call = createCallOrNew(Token.CALL, pn);</TD></TR><TR CLASS="z"><TD CLASS="l">628</TD><TD>        call.setLineno(node.getLineno());</TD></TR><TR CLASS="z"><TD CLASS="l">629</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="z"><TD CLASS="l">630</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4">631</A></TD><TD>        return call;</TD></TR><TR><TD CLASS="l">632</TD><TD>    }</TD></TR><TR><TD CLASS="l">633</TD><TD>    </TD></TR><TR><TD CLASS="l">634</TD><TD>    private Node genExprTransformHelper(GeneratorExpression node) {</TD></TR><TR CLASS="z"><TD CLASS="l">635</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="z"><TD CLASS="l">636</TD><TD>        int lineno = node.getLineno();</TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>        Node expr = transform(node.getResult());</TD></TR><TR><TD CLASS="l">638</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">639</TD><TD>        List&lt;GeneratorExpressionLoop&gt; loops = node.getLoops();</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>        int numLoops = loops.size();</TD></TR><TR><TD CLASS="l">641</TD><TD> </TD></TR><TR><TD CLASS="l">642</TD><TD>        // Walk through loops, collecting and defining their iterator symbols.</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>        Node[] iterators = new Node[numLoops];</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>        Node[] iteratedObjs = new Node[numLoops];</TD></TR><TR><TD CLASS="l">645</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>        for (int i = 0; i &lt; numLoops; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>            GeneratorExpressionLoop acl = loops.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>            decompiler.addName(&#34; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>            decompiler.addToken(Token.FOR);</TD></TR><TR CLASS="z"><TD CLASS="l">650</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR><TD CLASS="l">651</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>            AstNode iter = acl.getIterator();</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>            String name = null;</TD></TR><TR CLASS="z"><TD CLASS="l">654</TD><TD>            if (iter.getType() == Token.NAME) {</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>                name = iter.getString();</TD></TR><TR CLASS="z"><TD CLASS="l">656</TD><TD>                decompiler.addName(name);</TD></TR><TR><TD CLASS="l">657</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">658</TD><TD>                // destructuring assignment</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                decompile(iter);</TD></TR><TR CLASS="z"><TD CLASS="l">660</TD><TD>                name = currentScriptOrFn.getNextTempName();</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>                defineSymbol(Token.LP, name, false);</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                expr = createBinary(Token.COMMA,</TD></TR><TR><TD CLASS="l">663</TD><TD>                                    createAssignment(Token.ASSIGN,</TD></TR><TR><TD CLASS="l">664</TD><TD>                                                     iter,</TD></TR><TR><TD CLASS="l">665</TD><TD>                                                     createName(name)),</TD></TR><TR><TD CLASS="l">666</TD><TD>                                    expr);</TD></TR><TR><TD CLASS="l">667</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>            Node init = createName(name);</TD></TR><TR><TD CLASS="l">669</TD><TD>            // Define as a let since we want the scope of the variable to</TD></TR><TR><TD CLASS="l">670</TD><TD>            // be restricted to the array comprehension</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>            defineSymbol(Token.LET, name, false);</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>            iterators[i] = init;</TD></TR><TR><TD CLASS="l">673</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>            decompiler.addToken(Token.IN);</TD></TR><TR CLASS="z"><TD CLASS="l">675</TD><TD>            iteratedObjs[i] = transform(acl.getIteratedObject());</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">677</TD><TD>        }</TD></TR><TR><TD CLASS="l">678</TD><TD> </TD></TR><TR><TD CLASS="l">679</TD><TD>        // generate code for tmpArray.push(body)</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>        Node yield = new Node(Token.YIELD, expr, node.getLineno());</TD></TR><TR><TD CLASS="l">681</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>        Node body = new Node(Token.EXPR_VOID, yield, lineno);</TD></TR><TR><TD CLASS="l">683</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>        if (node.getFilter() != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>            decompiler.addName(&#34; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">686</TD><TD>            decompiler.addToken(Token.IF);</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="z"><TD CLASS="l">688</TD><TD>            body = createIf(transform(node.getFilter()), body, null, lineno);</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">690</TD><TD>        }</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR><TD CLASS="l">692</TD><TD>        // Now walk loops in reverse to build up the body statement.</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>        int pushed = 0;</TD></TR><TR><TD CLASS="l">694</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">695</TD><TD>            for (int i = numLoops-1; i &gt;= 0; i--) {</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>                GeneratorExpressionLoop acl = loops.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>                Scope loop = createLoopNode(null,  // no label</TD></TR><TR><TD CLASS="l">698</TD><TD>                                            acl.getLineno());</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                pushScope(loop);</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                pushed++;</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>                body = createForIn(Token.LET,</TD></TR><TR><TD CLASS="l">702</TD><TD>                                   loop,</TD></TR><TR><TD CLASS="l">703</TD><TD>                                   iterators[i],</TD></TR><TR><TD CLASS="l">704</TD><TD>                                   iteratedObjs[i],</TD></TR><TR><TD CLASS="l">705</TD><TD>                                   body,</TD></TR><TR><TD CLASS="l">706</TD><TD>                                   acl.isForEach());</TD></TR><TR><TD CLASS="l">707</TD><TD>            }</TD></TR><TR><TD CLASS="l">708</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>            for (int i = 0; i &lt; pushed; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>                popScope();</TD></TR><TR><TD CLASS="l">711</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>        }</TD></TR><TR><TD CLASS="l">713</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">715</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3e">716</A></TD><TD>        return body;</TD></TR><TR><TD CLASS="l">717</TD><TD>    }</TD></TR><TR><TD CLASS="l">718</TD><TD> </TD></TR><TR><TD CLASS="l">719</TD><TD>    private Node transformIf(IfStatement n) {</TD></TR><TR CLASS="c"><TD CLASS="l">720</TD><TD>        decompiler.addToken(Token.IF);</TD></TR><TR CLASS="c"><TD CLASS="l">721</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">722</TD><TD>        Node cond = transform(n.getCondition());</TD></TR><TR CLASS="c"><TD CLASS="l">723</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">724</TD><TD>        decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">725</TD><TD>        Node ifTrue = transform(n.getThenPart());</TD></TR><TR CLASS="c"><TD CLASS="l">726</TD><TD>        Node ifFalse = null;</TD></TR><TR CLASS="c"><TD CLASS="l">727</TD><TD>        if (n.getElsePart() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">728</TD><TD>            decompiler.addToken(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">729</TD><TD>            decompiler.addToken(Token.ELSE);</TD></TR><TR CLASS="c"><TD CLASS="l">730</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">731</TD><TD>            ifFalse = transform(n.getElsePart());</TD></TR><TR><TD CLASS="l">732</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">733</TD><TD>        decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="3f">734</A></TD><TD>        return createIf(cond, ifTrue, ifFalse, n.getLineno());</TD></TR><TR><TD CLASS="l">735</TD><TD>    }</TD></TR><TR><TD CLASS="l">736</TD><TD> </TD></TR><TR><TD CLASS="l">737</TD><TD>    private Node transformInfix(InfixExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">738</TD><TD>        Node left = transform(node.getLeft());</TD></TR><TR CLASS="c"><TD CLASS="l">739</TD><TD>        decompiler.addToken(node.getType());</TD></TR><TR CLASS="c"><TD CLASS="l">740</TD><TD>        Node right = transform(node.getRight());</TD></TR><TR CLASS="c"><TD CLASS="l">741</TD><TD>        if (node instanceof XmlDotQuery) {</TD></TR><TR CLASS="c"><TD CLASS="l">742</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">743</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="40">744</A></TD><TD>        return createBinary(node.getType(), left, right);</TD></TR><TR><TD CLASS="l">745</TD><TD>    }</TD></TR><TR><TD CLASS="l">746</TD><TD> </TD></TR><TR><TD CLASS="l">747</TD><TD>    private Node transformLabeledStatement(LabeledStatement ls) {</TD></TR><TR CLASS="c"><TD CLASS="l">748</TD><TD>        Label label = ls.getFirstLabel();</TD></TR><TR CLASS="c"><TD CLASS="l">749</TD><TD>        List&lt;Label&gt; labels = ls.getLabels();</TD></TR><TR CLASS="c"><TD CLASS="l">750</TD><TD>        decompiler.addName(label.getName());</TD></TR><TR CLASS="c"><TD CLASS="l">751</TD><TD>        if (labels.size() &gt; 1) {</TD></TR><TR><TD CLASS="l">752</TD><TD>            // more than one label</TD></TR><TR CLASS="c"><TD CLASS="l">753</TD><TD>            for (Label lb : labels.subList(1, labels.size())) {</TD></TR><TR CLASS="c"><TD CLASS="l">754</TD><TD>                decompiler.addEOL(Token.COLON);</TD></TR><TR CLASS="c"><TD CLASS="l">755</TD><TD>                decompiler.addName(lb.getName());</TD></TR><TR CLASS="c"><TD CLASS="l">756</TD><TD>            }</TD></TR><TR><TD CLASS="l">757</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">758</TD><TD>        if (ls.getStatement().getType() == Token.BLOCK) {</TD></TR><TR><TD CLASS="l">759</TD><TD>            // reuse OBJECTLIT for ':' workaround, cf. transformObjectLiteral()</TD></TR><TR CLASS="c"><TD CLASS="l">760</TD><TD>            decompiler.addToken(Token.OBJECTLIT);</TD></TR><TR CLASS="c"><TD CLASS="l">761</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR><TD CLASS="l">762</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">763</TD><TD>            decompiler.addEOL(Token.COLON);</TD></TR><TR><TD CLASS="l">764</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">765</TD><TD>        Node statement = transform(ls.getStatement());</TD></TR><TR CLASS="c"><TD CLASS="l">766</TD><TD>        if (ls.getStatement().getType() == Token.BLOCK) {</TD></TR><TR CLASS="c"><TD CLASS="l">767</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR><TD CLASS="l">768</TD><TD>        }</TD></TR><TR><TD CLASS="l">769</TD><TD> </TD></TR><TR><TD CLASS="l">770</TD><TD>        // Make a target and put it _after_ the statement node.  Add in the</TD></TR><TR><TD CLASS="l">771</TD><TD>        // LABEL node, so breaks get the right target.</TD></TR><TR CLASS="c"><TD CLASS="l">772</TD><TD>        Node breakTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">773</TD><TD>        Node block = new Node(Token.BLOCK, label, statement, breakTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">774</TD><TD>        label.target = breakTarget;</TD></TR><TR><TD CLASS="l">775</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="13">776</A></TD><TD>        return block;</TD></TR><TR><TD CLASS="l">777</TD><TD>    }</TD></TR><TR><TD CLASS="l">778</TD><TD> </TD></TR><TR><TD CLASS="l">779</TD><TD>    private Node transformLetNode(LetNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">780</TD><TD>        pushScope(node);</TD></TR><TR><TD CLASS="l">781</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">782</TD><TD>            decompiler.addToken(Token.LET);</TD></TR><TR CLASS="c"><TD CLASS="l">783</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">784</TD><TD>            Node vars = transformVariableInitializers(node.getVariables());</TD></TR><TR CLASS="c"><TD CLASS="l">785</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">786</TD><TD>            node.addChildToBack(vars);</TD></TR><TR CLASS="c"><TD CLASS="l">787</TD><TD>            boolean letExpr = node.getType() == Token.LETEXPR;</TD></TR><TR CLASS="c"><TD CLASS="l">788</TD><TD>            if (node.getBody() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">789</TD><TD>                if (letExpr) {</TD></TR><TR CLASS="c"><TD CLASS="l">790</TD><TD>                    decompiler.addName(&#34; &#34;);</TD></TR><TR><TD CLASS="l">791</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">792</TD><TD>                    decompiler.addEOL(Token.LC);</TD></TR><TR><TD CLASS="l">793</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">794</TD><TD>                node.addChildToBack(transform(node.getBody()));</TD></TR><TR CLASS="c"><TD CLASS="l">795</TD><TD>                if (!letExpr) {</TD></TR><TR CLASS="c"><TD CLASS="l">796</TD><TD>                    decompiler.addEOL(Token.RC);</TD></TR><TR><TD CLASS="l">797</TD><TD>                }</TD></TR><TR><TD CLASS="l">798</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">799</TD><TD>            return node;</TD></TR><TR><TD CLASS="l">800</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="55% line coverage (6 out of 11 instructions)">801</TD><TD TITLE="55% line coverage (6 out of 11 instructions)">            popScope();</TD></TR><TR><TD CLASS="l"><A NAME="41">802</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">803</TD><TD>    }</TD></TR><TR><TD CLASS="l">804</TD><TD> </TD></TR><TR><TD CLASS="l">805</TD><TD>    private Node transformLiteral(AstNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">806</TD><TD>        decompiler.addToken(node.getType());</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="42">807</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">808</TD><TD>    }</TD></TR><TR><TD CLASS="l">809</TD><TD> </TD></TR><TR><TD CLASS="l">810</TD><TD>    private Node transformName(Name node) {</TD></TR><TR CLASS="c"><TD CLASS="l">811</TD><TD>        decompiler.addName(node.getIdentifier());</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="43">812</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">813</TD><TD>    }</TD></TR><TR><TD CLASS="l">814</TD><TD> </TD></TR><TR><TD CLASS="l">815</TD><TD>    private Node transformNewExpr(NewExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">816</TD><TD>        decompiler.addToken(Token.NEW);</TD></TR><TR CLASS="c"><TD CLASS="l">817</TD><TD>        Node nx = createCallOrNew(Token.NEW, transform(node.getTarget()));</TD></TR><TR CLASS="c"><TD CLASS="l">818</TD><TD>        nx.setLineno(node.getLineno());</TD></TR><TR CLASS="c"><TD CLASS="l">819</TD><TD>        List&lt;AstNode&gt; args = node.getArguments();</TD></TR><TR CLASS="c"><TD CLASS="l">820</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">821</TD><TD>        for (int i = 0; i &lt; args.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">822</TD><TD>            AstNode arg = args.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">823</TD><TD>            nx.addChildToBack(transform(arg));</TD></TR><TR CLASS="c"><TD CLASS="l">824</TD><TD>            if (i &lt; args.size() - 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">825</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">826</TD><TD>            }</TD></TR><TR><TD CLASS="l">827</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">828</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">829</TD><TD>        if (node.getInitializer() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">830</TD><TD>            nx.addChildToBack(transformObjectLiteral(node.getInitializer()));</TD></TR><TR><TD CLASS="l">831</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="44">832</A></TD><TD>        return nx;</TD></TR><TR><TD CLASS="l">833</TD><TD>    }</TD></TR><TR><TD CLASS="l">834</TD><TD> </TD></TR><TR><TD CLASS="l">835</TD><TD>    private Node transformNumber(NumberLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">836</TD><TD>        decompiler.addNumber(node.getNumber());</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="20">837</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">838</TD><TD>    }</TD></TR><TR><TD CLASS="l">839</TD><TD> </TD></TR><TR><TD CLASS="l">840</TD><TD>    private Node transformObjectLiteral(ObjectLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">841</TD><TD>        if (node.isDestructuring()) {</TD></TR><TR CLASS="z"><TD CLASS="l">842</TD><TD>            return node;</TD></TR><TR><TD CLASS="l">843</TD><TD>        }</TD></TR><TR><TD CLASS="l">844</TD><TD>        // createObjectLiteral rewrites its argument as object</TD></TR><TR><TD CLASS="l">845</TD><TD>        // creation plus object property entries, so later compiler</TD></TR><TR><TD CLASS="l">846</TD><TD>        // stages don't need to know about object literals.</TD></TR><TR CLASS="c"><TD CLASS="l">847</TD><TD>        decompiler.addToken(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">848</TD><TD>        List&lt;ObjectProperty&gt; elems = node.getElements();</TD></TR><TR CLASS="c"><TD CLASS="l">849</TD><TD>        Node object = new Node(Token.OBJECTLIT);</TD></TR><TR><TD CLASS="l">850</TD><TD>        Object[] properties;</TD></TR><TR CLASS="c"><TD CLASS="l">851</TD><TD>        if (elems.isEmpty()) {</TD></TR><TR CLASS="c"><TD CLASS="l">852</TD><TD>            properties = ScriptRuntime.emptyArgs;</TD></TR><TR><TD CLASS="l">853</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">854</TD><TD>            int size = elems.size(), i = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">855</TD><TD>            properties = new Object[size];</TD></TR><TR CLASS="c"><TD CLASS="l">856</TD><TD>            for (ObjectProperty prop : elems) {</TD></TR><TR CLASS="c"><TD CLASS="l">857</TD><TD>                if (prop.isGetter()) {</TD></TR><TR CLASS="c"><TD CLASS="l">858</TD><TD>                    decompiler.addToken(Token.GET);</TD></TR><TR CLASS="c"><TD CLASS="l">859</TD><TD>                } else if (prop.isSetter()) {</TD></TR><TR CLASS="c"><TD CLASS="l">860</TD><TD>                    decompiler.addToken(Token.SET);</TD></TR><TR><TD CLASS="l">861</TD><TD>                }</TD></TR><TR><TD CLASS="l">862</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">863</TD><TD>                properties[i++] = getPropKey(prop.getLeft());</TD></TR><TR><TD CLASS="l">864</TD><TD> </TD></TR><TR><TD CLASS="l">865</TD><TD>                // OBJECTLIT is used as ':' in object literal for</TD></TR><TR><TD CLASS="l">866</TD><TD>                // decompilation to solve spacing ambiguity.</TD></TR><TR CLASS="c"><TD CLASS="l">867</TD><TD>                if (!(prop.isGetter() || prop.isSetter())) {</TD></TR><TR CLASS="c"><TD CLASS="l">868</TD><TD>                    decompiler.addToken(Token.OBJECTLIT);</TD></TR><TR><TD CLASS="l">869</TD><TD>                }</TD></TR><TR><TD CLASS="l">870</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">871</TD><TD>                Node right = transform(prop.getRight());</TD></TR><TR CLASS="c"><TD CLASS="l">872</TD><TD>                if (prop.isGetter()) {</TD></TR><TR CLASS="c"><TD CLASS="l">873</TD><TD>                    right = createUnary(Token.GET, right);</TD></TR><TR CLASS="c"><TD CLASS="l">874</TD><TD>                } else if (prop.isSetter()) {</TD></TR><TR CLASS="c"><TD CLASS="l">875</TD><TD>                    right = createUnary(Token.SET, right);</TD></TR><TR><TD CLASS="l">876</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">877</TD><TD>                object.addChildToBack(right);</TD></TR><TR><TD CLASS="l">878</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">879</TD><TD>                if (i &lt; size) {</TD></TR><TR CLASS="c"><TD CLASS="l">880</TD><TD>                    decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">881</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">882</TD><TD>            }</TD></TR><TR><TD CLASS="l">883</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">884</TD><TD>        decompiler.addToken(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">885</TD><TD>        object.putProp(Node.OBJECT_IDS_PROP, properties);</TD></TR><TR CLASS="c"><TD CLASS="l">886</TD><TD>        return object;</TD></TR><TR><TD CLASS="l"><A NAME="1c">887</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">888</TD><TD> </TD></TR><TR><TD CLASS="l">889</TD><TD>    private Object getPropKey(Node id) {</TD></TR><TR><TD CLASS="l">890</TD><TD>        Object key;</TD></TR><TR CLASS="c"><TD CLASS="l">891</TD><TD>        if (id instanceof Name) {</TD></TR><TR CLASS="c"><TD CLASS="l">892</TD><TD>            String s = ((Name)id).getIdentifier();</TD></TR><TR CLASS="c"><TD CLASS="l">893</TD><TD>            decompiler.addName(s);</TD></TR><TR CLASS="c"><TD CLASS="l">894</TD><TD>            key = ScriptRuntime.getIndexObject(s);</TD></TR><TR CLASS="c"><TD CLASS="l">895</TD><TD>        } else if (id instanceof StringLiteral) {</TD></TR><TR CLASS="c"><TD CLASS="l">896</TD><TD>            String s = ((StringLiteral)id).getValue();</TD></TR><TR CLASS="c"><TD CLASS="l">897</TD><TD>            decompiler.addString(s);</TD></TR><TR CLASS="c"><TD CLASS="l">898</TD><TD>            key = ScriptRuntime.getIndexObject(s);</TD></TR><TR CLASS="c"><TD CLASS="l">899</TD><TD>        } else if (id instanceof NumberLiteral) {</TD></TR><TR CLASS="c"><TD CLASS="l">900</TD><TD>            double n = ((NumberLiteral)id).getNumber();</TD></TR><TR CLASS="c"><TD CLASS="l">901</TD><TD>            decompiler.addNumber(n);</TD></TR><TR CLASS="c"><TD CLASS="l">902</TD><TD>            key = ScriptRuntime.getIndexObject(n);</TD></TR><TR CLASS="c"><TD CLASS="l">903</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">904</TD><TD>            throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">905</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="45">906</A></TD><TD>        return key;</TD></TR><TR><TD CLASS="l">907</TD><TD>    }</TD></TR><TR><TD CLASS="l">908</TD><TD> </TD></TR><TR><TD CLASS="l">909</TD><TD>    private Node transformParenExpr(ParenthesizedExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">910</TD><TD>        AstNode expr = node.getExpression();</TD></TR><TR CLASS="c"><TD CLASS="l">911</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">912</TD><TD>        int count = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">913</TD><TD>        while (expr instanceof ParenthesizedExpression) {</TD></TR><TR CLASS="c"><TD CLASS="l">914</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">915</TD><TD>            count++;</TD></TR><TR CLASS="c"><TD CLASS="l">916</TD><TD>            expr = ((ParenthesizedExpression)expr).getExpression();</TD></TR><TR><TD CLASS="l">917</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">918</TD><TD>        Node result = transform(expr);</TD></TR><TR CLASS="c"><TD CLASS="l">919</TD><TD>        for (int i = 0; i &lt; count; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">920</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR><TD CLASS="l">921</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">922</TD><TD>        result.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="46">923</A></TD><TD>        return result;</TD></TR><TR><TD CLASS="l">924</TD><TD>    }</TD></TR><TR><TD CLASS="l">925</TD><TD> </TD></TR><TR><TD CLASS="l">926</TD><TD>    private Node transformPropertyGet(PropertyGet node) {</TD></TR><TR CLASS="c"><TD CLASS="l">927</TD><TD>        Node target = transform(node.getTarget());</TD></TR><TR CLASS="c"><TD CLASS="l">928</TD><TD>        String name = node.getProperty().getIdentifier();</TD></TR><TR CLASS="c"><TD CLASS="l">929</TD><TD>        decompiler.addToken(Token.DOT);</TD></TR><TR CLASS="c"><TD CLASS="l">930</TD><TD>        decompiler.addName(name);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="47">931</A></TD><TD>        return createPropertyGet(target, null, name, 0);</TD></TR><TR><TD CLASS="l">932</TD><TD>    }</TD></TR><TR><TD CLASS="l">933</TD><TD> </TD></TR><TR><TD CLASS="l">934</TD><TD>    private Node transformRegExp(RegExpLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">935</TD><TD>        decompiler.addRegexp(node.getValue(), node.getFlags());</TD></TR><TR CLASS="c"><TD CLASS="l">936</TD><TD>        currentScriptOrFn.addRegExp(node);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="48">937</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">938</TD><TD>    }</TD></TR><TR><TD CLASS="l">939</TD><TD> </TD></TR><TR><TD CLASS="l">940</TD><TD>    private Node transformReturn(ReturnStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">941</TD><TD>        boolean expClosure = Boolean.TRUE.equals(node.getProp(Node.EXPRESSION_CLOSURE_PROP));</TD></TR><TR CLASS="c"><TD CLASS="l">942</TD><TD>        if (expClosure) {</TD></TR><TR CLASS="c"><TD CLASS="l">943</TD><TD>            decompiler.addName(&#34; &#34;);</TD></TR><TR><TD CLASS="l">944</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">945</TD><TD>            decompiler.addToken(Token.RETURN);</TD></TR><TR><TD CLASS="l">946</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">947</TD><TD>        AstNode rv = node.getReturnValue();</TD></TR><TR CLASS="c"><TD CLASS="l">948</TD><TD>        Node value = rv == null ? null : transform(rv);</TD></TR><TR CLASS="c"><TD CLASS="l">949</TD><TD>        if (!expClosure) decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l">950</TD><TD>        return rv == null</TD></TR><TR><TD CLASS="l">951</TD><TD>            ? new Node(Token.RETURN, node.getLineno())</TD></TR><TR><TD CLASS="l"><A NAME="1b">952</A></TD><TD>            : new Node(Token.RETURN, value, node.getLineno());</TD></TR><TR><TD CLASS="l">953</TD><TD>    }</TD></TR><TR><TD CLASS="l">954</TD><TD> </TD></TR><TR><TD CLASS="l">955</TD><TD>    private Node transformScript(ScriptNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">956</TD><TD>        decompiler.addToken(Token.SCRIPT);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="78% line coverage (7 out of 9 instructions)">957</TD><TD TITLE="78% line coverage (7 out of 9 instructions)">        if (currentScope != null) Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">958</TD><TD>        currentScope = node;</TD></TR><TR CLASS="c"><TD CLASS="l">959</TD><TD>        Node body = new Node(Token.BLOCK);</TD></TR><TR CLASS="c"><TD CLASS="l">960</TD><TD>        for (Node kid : node) {</TD></TR><TR CLASS="c"><TD CLASS="l">961</TD><TD>            body.addChildToBack(transform((AstNode)kid));</TD></TR><TR CLASS="c"><TD CLASS="l">962</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">963</TD><TD>        node.removeChildren();</TD></TR><TR CLASS="c"><TD CLASS="l">964</TD><TD>        Node children = body.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">965</TD><TD>        if (children != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">966</TD><TD>            node.addChildrenToBack(children);</TD></TR><TR><TD CLASS="l">967</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="49">968</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">969</TD><TD>    }</TD></TR><TR><TD CLASS="l">970</TD><TD> </TD></TR><TR><TD CLASS="l">971</TD><TD>    private Node transformString(StringLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">972</TD><TD>        decompiler.addString(node.getValue());</TD></TR><TR CLASS="c"><TD CLASS="l">973</TD><TD>        return Node.newString(node.getValue());</TD></TR><TR><TD CLASS="l">974</TD><TD>    }</TD></TR><TR><TD CLASS="l">975</TD><TD> </TD></TR><TR><TD CLASS="l">976</TD><TD>    private Node transformSwitch(SwitchStatement node) {</TD></TR><TR><TD CLASS="l">977</TD><TD>        // The switch will be rewritten from:</TD></TR><TR><TD CLASS="l">978</TD><TD>        //</TD></TR><TR><TD CLASS="l">979</TD><TD>        // switch (expr) {</TD></TR><TR><TD CLASS="l">980</TD><TD>        //   case test1: statements1;</TD></TR><TR><TD CLASS="l">981</TD><TD>        //   ...</TD></TR><TR><TD CLASS="l">982</TD><TD>        //   default: statementsDefault;</TD></TR><TR><TD CLASS="l">983</TD><TD>        //   ...</TD></TR><TR><TD CLASS="l">984</TD><TD>        //   case testN: statementsN;</TD></TR><TR><TD CLASS="l">985</TD><TD>        // }</TD></TR><TR><TD CLASS="l">986</TD><TD>        //</TD></TR><TR><TD CLASS="l">987</TD><TD>        // to:</TD></TR><TR><TD CLASS="l">988</TD><TD>        //</TD></TR><TR><TD CLASS="l">989</TD><TD>        // {</TD></TR><TR><TD CLASS="l">990</TD><TD>        //     switch (expr) {</TD></TR><TR><TD CLASS="l">991</TD><TD>        //       case test1: goto label1;</TD></TR><TR><TD CLASS="l">992</TD><TD>        //       ...</TD></TR><TR><TD CLASS="l">993</TD><TD>        //       case testN: goto labelN;</TD></TR><TR><TD CLASS="l">994</TD><TD>        //     }</TD></TR><TR><TD CLASS="l">995</TD><TD>        //     goto labelDefault;</TD></TR><TR><TD CLASS="l">996</TD><TD>        //   label1:</TD></TR><TR><TD CLASS="l">997</TD><TD>        //     statements1;</TD></TR><TR><TD CLASS="l">998</TD><TD>        //   ...</TD></TR><TR><TD CLASS="l">999</TD><TD>        //   labelDefault:</TD></TR><TR><TD CLASS="l">1000</TD><TD>        //     statementsDefault;</TD></TR><TR><TD CLASS="l">1001</TD><TD>        //   ...</TD></TR><TR><TD CLASS="l">1002</TD><TD>        //   labelN:</TD></TR><TR><TD CLASS="l">1003</TD><TD>        //     statementsN;</TD></TR><TR><TD CLASS="l">1004</TD><TD>        //   breakLabel:</TD></TR><TR><TD CLASS="l">1005</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1006</TD><TD>        //</TD></TR><TR><TD CLASS="l">1007</TD><TD>        // where inside switch each &#34;break;&#34; without label will be replaced</TD></TR><TR><TD CLASS="l">1008</TD><TD>        // by &#34;goto breakLabel&#34;.</TD></TR><TR><TD CLASS="l">1009</TD><TD>        //</TD></TR><TR><TD CLASS="l">1010</TD><TD>        // If the original switch does not have the default label, then</TD></TR><TR><TD CLASS="l">1011</TD><TD>        // after the switch he transformed code would contain this goto:</TD></TR><TR><TD CLASS="l"><A NAME="4a">1012</A></TD><TD>        //     goto breakLabel;</TD></TR><TR><TD CLASS="l">1013</TD><TD>        // instead of:</TD></TR><TR><TD CLASS="l">1014</TD><TD>        //     goto labelDefault;</TD></TR><TR><TD CLASS="l">1015</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1016</TD><TD>        decompiler.addToken(Token.SWITCH);</TD></TR><TR CLASS="c"><TD CLASS="l">1017</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">1018</TD><TD>        Node switchExpr = transform(node.getExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">1019</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">1020</TD><TD>        node.addChildToBack(switchExpr);</TD></TR><TR><TD CLASS="l">1021</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1022</TD><TD>        Node block = new Node(Token.BLOCK, node, node.getLineno());</TD></TR><TR CLASS="c"><TD CLASS="l">1023</TD><TD>        decompiler.addEOL(Token.LC);</TD></TR><TR><TD CLASS="l">1024</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1025</TD><TD>        for (SwitchCase sc : node.getCases()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1026</TD><TD>            AstNode expr = sc.getExpression();</TD></TR><TR CLASS="c"><TD CLASS="l">1027</TD><TD>            Node caseExpr = null;</TD></TR><TR><TD CLASS="l">1028</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1029</TD><TD>            if (expr != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1030</TD><TD>                decompiler.addToken(Token.CASE);</TD></TR><TR CLASS="c"><TD CLASS="l">1031</TD><TD>                caseExpr = transform(expr);</TD></TR><TR><TD CLASS="l">1032</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1033</TD><TD>                decompiler.addToken(Token.DEFAULT);</TD></TR><TR><TD CLASS="l">1034</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1035</TD><TD>            decompiler.addEOL(Token.COLON);</TD></TR><TR><TD CLASS="l">1036</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1037</TD><TD>            List&lt;AstNode&gt; stmts = sc.getStatements();</TD></TR><TR CLASS="c"><TD CLASS="l">1038</TD><TD>            Node body = new Block();</TD></TR><TR CLASS="c"><TD CLASS="l">1039</TD><TD>            if (stmts != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1040</TD><TD>                for (AstNode kid : stmts) {</TD></TR><TR CLASS="c"><TD CLASS="l">1041</TD><TD>                    body.addChildToBack(transform(kid));</TD></TR><TR CLASS="c"><TD CLASS="l">1042</TD><TD>                }</TD></TR><TR><TD CLASS="l">1043</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1044</TD><TD>            addSwitchCase(block, caseExpr, body);</TD></TR><TR CLASS="c"><TD CLASS="l">1045</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1046</TD><TD>        decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">1047</TD><TD>        closeSwitch(block);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="4b">1048</A></TD><TD>        return block;</TD></TR><TR><TD CLASS="l">1049</TD><TD>    }</TD></TR><TR><TD CLASS="l">1050</TD><TD> </TD></TR><TR><TD CLASS="l">1051</TD><TD>    private Node transformThrow(ThrowStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1052</TD><TD>        decompiler.addToken(Token.THROW);</TD></TR><TR CLASS="c"><TD CLASS="l">1053</TD><TD>        Node value = transform(node.getExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">1054</TD><TD>        decompiler.addEOL(Token.SEMI);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="4d">1055</A></TD><TD>        return new Node(Token.THROW, value, node.getLineno());</TD></TR><TR><TD CLASS="l">1056</TD><TD>    }</TD></TR><TR><TD CLASS="l">1057</TD><TD> </TD></TR><TR><TD CLASS="l">1058</TD><TD>    private Node transformTry(TryStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1059</TD><TD>        decompiler.addToken(Token.TRY);</TD></TR><TR CLASS="c"><TD CLASS="l">1060</TD><TD>        decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">1061</TD><TD>        Node tryBlock = transform(node.getTryBlock());</TD></TR><TR CLASS="c"><TD CLASS="l">1062</TD><TD>        decompiler.addEOL(Token.RC);</TD></TR><TR><TD CLASS="l">1063</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1064</TD><TD>        Node catchBlocks = new Block();</TD></TR><TR CLASS="c"><TD CLASS="l">1065</TD><TD>        for (CatchClause cc : node.getCatchClauses()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1066</TD><TD>            decompiler.addToken(Token.CATCH);</TD></TR><TR CLASS="c"><TD CLASS="l">1067</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR><TD CLASS="l">1068</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1069</TD><TD>            String varName = cc.getVarName().getIdentifier();</TD></TR><TR CLASS="c"><TD CLASS="l">1070</TD><TD>            decompiler.addName(varName);</TD></TR><TR><TD CLASS="l">1071</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1072</TD><TD>            Node catchCond = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1073</TD><TD>            AstNode ccc = cc.getCatchCondition();</TD></TR><TR CLASS="c"><TD CLASS="l">1074</TD><TD>            if (ccc != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1075</TD><TD>                decompiler.addName(&#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1076</TD><TD>                decompiler.addToken(Token.IF);</TD></TR><TR CLASS="c"><TD CLASS="l">1077</TD><TD>                catchCond = transform(ccc);</TD></TR><TR><TD CLASS="l">1078</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1079</TD><TD>                catchCond = new EmptyExpression();</TD></TR><TR><TD CLASS="l">1080</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1081</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">1082</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR><TD CLASS="l">1083</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1084</TD><TD>            Node body = transform(cc.getBody());</TD></TR><TR CLASS="c"><TD CLASS="l">1085</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR><TD CLASS="l">1086</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1087</TD><TD>            catchBlocks.addChildToBack(createCatch(varName, catchCond,</TD></TR><TR><TD CLASS="l">1088</TD><TD>                                                   body, cc.getLineno()));</TD></TR><TR CLASS="c"><TD CLASS="l">1089</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1090</TD><TD>        Node finallyBlock = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1091</TD><TD>        if (node.getFinallyBlock() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1092</TD><TD>            decompiler.addToken(Token.FINALLY);</TD></TR><TR CLASS="c"><TD CLASS="l">1093</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">1094</TD><TD>            finallyBlock = transform(node.getFinallyBlock());</TD></TR><TR CLASS="c"><TD CLASS="l">1095</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR><TD CLASS="l">1096</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1097</TD><TD>        return createTryCatchFinally(tryBlock, catchBlocks,</TD></TR><TR><TD CLASS="l"><A NAME="4e">1098</A></TD><TD>                                     finallyBlock, node.getLineno());</TD></TR><TR><TD CLASS="l">1099</TD><TD>    }</TD></TR><TR><TD CLASS="l">1100</TD><TD> </TD></TR><TR><TD CLASS="l">1101</TD><TD>    private Node transformUnary(UnaryExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1102</TD><TD>        int type = node.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">1103</TD><TD>        if (type == Token.DEFAULTNAMESPACE) {</TD></TR><TR CLASS="c"><TD CLASS="l">1104</TD><TD>            return transformDefaultXmlNamepace(node);</TD></TR><TR><TD CLASS="l">1105</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1106</TD><TD>        if (node.isPrefix()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1107</TD><TD>            decompiler.addToken(type);</TD></TR><TR><TD CLASS="l">1108</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1109</TD><TD>        Node child = transform(node.getOperand());</TD></TR><TR CLASS="c"><TD CLASS="l">1110</TD><TD>        if (node.isPostfix()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1111</TD><TD>            decompiler.addToken(type);</TD></TR><TR><TD CLASS="l">1112</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1113</TD><TD>        if (type == Token.INC || type == Token.DEC) {</TD></TR><TR CLASS="c"><TD CLASS="l">1114</TD><TD>            return createIncDec(type, node.isPostfix(), child);</TD></TR><TR><TD CLASS="l">1115</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="50">1116</A></TD><TD>        return createUnary(type, child);</TD></TR><TR><TD CLASS="l">1117</TD><TD>    }</TD></TR><TR><TD CLASS="l">1118</TD><TD> </TD></TR><TR><TD CLASS="l">1119</TD><TD>    private Node transformVariables(VariableDeclaration node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1120</TD><TD>        decompiler.addToken(node.getType());</TD></TR><TR CLASS="c"><TD CLASS="l">1121</TD><TD>        transformVariableInitializers(node);</TD></TR><TR><TD CLASS="l">1122</TD><TD> </TD></TR><TR><TD CLASS="l">1123</TD><TD>        // Might be most robust to have parser record whether it was</TD></TR><TR><TD CLASS="l">1124</TD><TD>        // a variable declaration statement, possibly as a node property.</TD></TR><TR CLASS="c"><TD CLASS="l">1125</TD><TD>        AstNode parent = node.getParent();</TD></TR><TR CLASS="c"><TD CLASS="l">1126</TD><TD>        if (!(parent instanceof Loop)</TD></TR><TR><TD CLASS="l">1127</TD><TD>            &amp;&amp; !(parent instanceof LetNode)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1128</TD><TD>            decompiler.addEOL(Token.SEMI);</TD></TR><TR><TD CLASS="l">1129</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="4f">1130</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">1131</TD><TD>    }</TD></TR><TR><TD CLASS="l">1132</TD><TD> </TD></TR><TR><TD CLASS="l">1133</TD><TD>    private Node transformVariableInitializers(VariableDeclaration node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1134</TD><TD>        List&lt;VariableInitializer&gt; vars = node.getVariables();</TD></TR><TR CLASS="c"><TD CLASS="l">1135</TD><TD>        int size = vars.size(), i = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1136</TD><TD>        for (VariableInitializer var : vars) {</TD></TR><TR CLASS="c"><TD CLASS="l">1137</TD><TD>            AstNode target = var.getTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1138</TD><TD>            AstNode init = var.getInitializer();</TD></TR><TR><TD CLASS="l">1139</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1140</TD><TD>            Node left = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1141</TD><TD>            if (var.isDestructuring()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1142</TD><TD>                decompile(target);  // decompile but don't transform</TD></TR><TR CLASS="c"><TD CLASS="l">1143</TD><TD>                left = target;</TD></TR><TR><TD CLASS="l">1144</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1145</TD><TD>                left = transform(target);</TD></TR><TR><TD CLASS="l">1146</TD><TD>            }</TD></TR><TR><TD CLASS="l">1147</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1148</TD><TD>            Node right = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1149</TD><TD>            if (init != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1150</TD><TD>                decompiler.addToken(Token.ASSIGN);</TD></TR><TR CLASS="c"><TD CLASS="l">1151</TD><TD>                right = transform(init);</TD></TR><TR><TD CLASS="l">1152</TD><TD>            }</TD></TR><TR><TD CLASS="l">1153</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1154</TD><TD>            if (var.isDestructuring()) {</TD></TR><TR CLASS="c"><TD CLASS="l">1155</TD><TD>                if (right == null) {  // TODO:  should this ever happen?</TD></TR><TR CLASS="c"><TD CLASS="l">1156</TD><TD>                    node.addChildToBack(left);</TD></TR><TR><TD CLASS="l">1157</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1158</TD><TD>                    Node d = createDestructuringAssignment(node.getType(),</TD></TR><TR><TD CLASS="l">1159</TD><TD>                                                           left, right);</TD></TR><TR CLASS="c"><TD CLASS="l">1160</TD><TD>                    node.addChildToBack(d);</TD></TR><TR CLASS="c"><TD CLASS="l">1161</TD><TD>                }</TD></TR><TR><TD CLASS="l">1162</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1163</TD><TD>                if (right != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1164</TD><TD>                    left.addChildToBack(right);</TD></TR><TR><TD CLASS="l">1165</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1166</TD><TD>                node.addChildToBack(left);</TD></TR><TR><TD CLASS="l">1167</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1168</TD><TD>            if (i++ &lt; size-1) {</TD></TR><TR CLASS="c"><TD CLASS="l">1169</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">1170</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1171</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="f">1172</A></TD><TD>        return node;</TD></TR><TR><TD CLASS="l">1173</TD><TD>    }</TD></TR><TR><TD CLASS="l">1174</TD><TD> </TD></TR><TR><TD CLASS="l">1175</TD><TD>    private Node transformWhileLoop(WhileLoop loop) {</TD></TR><TR CLASS="c"><TD CLASS="l">1176</TD><TD>        decompiler.addToken(Token.WHILE);</TD></TR><TR CLASS="c"><TD CLASS="l">1177</TD><TD>        loop.setType(Token.LOOP);</TD></TR><TR CLASS="c"><TD CLASS="l">1178</TD><TD>        pushScope(loop);</TD></TR><TR><TD CLASS="l">1179</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">1180</TD><TD>            decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">1181</TD><TD>            Node cond = transform(loop.getCondition());</TD></TR><TR CLASS="c"><TD CLASS="l">1182</TD><TD>            decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">1183</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">1184</TD><TD>            Node body = transform(loop.getBody());</TD></TR><TR CLASS="c"><TD CLASS="l">1185</TD><TD>            decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">1186</TD><TD>            return createLoop(loop, LOOP_WHILE, body, cond, null, null);</TD></TR><TR><TD CLASS="l">1187</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="91% line coverage (50 out of 55 instructions)">1188</TD><TD TITLE="91% line coverage (50 out of 55 instructions)">            popScope();</TD></TR><TR><TD CLASS="l"><A NAME="51">1189</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1190</TD><TD>    }</TD></TR><TR><TD CLASS="l">1191</TD><TD> </TD></TR><TR><TD CLASS="l">1192</TD><TD>    private Node transformWith(WithStatement node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1193</TD><TD>        decompiler.addToken(Token.WITH);</TD></TR><TR CLASS="c"><TD CLASS="l">1194</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">1195</TD><TD>        Node expr = transform(node.getExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">1196</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">1197</TD><TD>        decompiler.addEOL(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">1198</TD><TD>        Node stmt = transform(node.getStatement());</TD></TR><TR CLASS="c"><TD CLASS="l">1199</TD><TD>        decompiler.addEOL(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="55">1200</A></TD><TD>        return createWith(expr, stmt, node.getLineno());</TD></TR><TR><TD CLASS="l">1201</TD><TD>    }</TD></TR><TR><TD CLASS="l">1202</TD><TD> </TD></TR><TR><TD CLASS="l">1203</TD><TD>    private Node transformYield(Yield node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1204</TD><TD>        decompiler.addToken(Token.YIELD);</TD></TR><TR CLASS="c"><TD CLASS="l">1205</TD><TD>        Node kid = node.getValue() == null ? null : transform(node.getValue());</TD></TR><TR CLASS="c"><TD CLASS="l">1206</TD><TD>        if (kid != null)</TD></TR><TR CLASS="c"><TD CLASS="l">1207</TD><TD>            return new Node(Token.YIELD, kid, node.getLineno());</TD></TR><TR><TD CLASS="l">1208</TD><TD>        else</TD></TR><TR CLASS="c"><TD CLASS="l">1209</TD><TD>            return new Node(Token.YIELD, node.getLineno());</TD></TR><TR><TD CLASS="l">1210</TD><TD>    }</TD></TR><TR><TD CLASS="l">1211</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="1e">1212</A></TD><TD>    private Node transformXmlLiteral(XmlLiteral node) {</TD></TR><TR><TD CLASS="l">1213</TD><TD>        // a literal like &lt;foo&gt;{bar}&lt;/foo&gt; is rewritten as</TD></TR><TR><TD CLASS="l">1214</TD><TD>        //   new XML(&#34;&lt;foo&gt;&#34; + bar + &#34;&lt;/foo&gt;&#34;);</TD></TR><TR><TD CLASS="l">1215</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1216</TD><TD>        Node pnXML = new Node(Token.NEW, node.getLineno());</TD></TR><TR CLASS="c"><TD CLASS="l">1217</TD><TD>        List&lt;XmlFragment&gt; frags = node.getFragments();</TD></TR><TR><TD CLASS="l">1218</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1219</TD><TD>        XmlString first = (XmlString)frags.get(0);</TD></TR><TR CLASS="c"><TD CLASS="l">1220</TD><TD>        boolean anon = first.getXml().trim().startsWith(&#34;&lt;&gt;&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1221</TD><TD>        pnXML.addChildToBack(createName(anon ? &#34;XMLList&#34; : &#34;XML&#34;));</TD></TR><TR><TD CLASS="l">1222</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1223</TD><TD>        Node pn = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1224</TD><TD>        for (XmlFragment frag : frags) {</TD></TR><TR CLASS="c"><TD CLASS="l">1225</TD><TD>            if (frag instanceof XmlString) {</TD></TR><TR CLASS="c"><TD CLASS="l">1226</TD><TD>                String xml = ((XmlString)frag).getXml();</TD></TR><TR CLASS="c"><TD CLASS="l">1227</TD><TD>                decompiler.addName(xml);</TD></TR><TR CLASS="c"><TD CLASS="l">1228</TD><TD>                if (pn == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1229</TD><TD>                    pn = createString(xml);</TD></TR><TR><TD CLASS="l">1230</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1231</TD><TD>                    pn = createBinary(Token.ADD, pn, createString(xml));</TD></TR><TR><TD CLASS="l">1232</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1233</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1234</TD><TD>                XmlExpression xexpr = (XmlExpression)frag;</TD></TR><TR CLASS="c"><TD CLASS="l">1235</TD><TD>                boolean isXmlAttr = xexpr.isXmlAttribute();</TD></TR><TR><TD CLASS="l">1236</TD><TD>                Node expr;</TD></TR><TR CLASS="c"><TD CLASS="l">1237</TD><TD>                decompiler.addToken(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">1238</TD><TD>                if (xexpr.getExpression() instanceof EmptyExpression) {</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>                    expr = createString(&#34;&#34;);</TD></TR><TR><TD CLASS="l">1240</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1241</TD><TD>                    expr = transform(xexpr.getExpression());</TD></TR><TR><TD CLASS="l">1242</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1243</TD><TD>                decompiler.addToken(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l">1244</TD><TD>                if (isXmlAttr) {</TD></TR><TR><TD CLASS="l">1245</TD><TD>                    // Need to put the result in double quotes</TD></TR><TR CLASS="c"><TD CLASS="l">1246</TD><TD>                    expr = createUnary(Token.ESCXMLATTR, expr);</TD></TR><TR CLASS="c"><TD CLASS="l">1247</TD><TD>                    Node prepend = createBinary(Token.ADD,</TD></TR><TR><TD CLASS="l">1248</TD><TD>                                                createString(&#34;\&#34;&#34;),</TD></TR><TR><TD CLASS="l">1249</TD><TD>                                                expr);</TD></TR><TR CLASS="c"><TD CLASS="l">1250</TD><TD>                    expr = createBinary(Token.ADD,</TD></TR><TR><TD CLASS="l">1251</TD><TD>                                        prepend,</TD></TR><TR><TD CLASS="l">1252</TD><TD>                                        createString(&#34;\&#34;&#34;));</TD></TR><TR CLASS="c"><TD CLASS="l">1253</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1254</TD><TD>                    expr = createUnary(Token.ESCXMLTEXT, expr);</TD></TR><TR><TD CLASS="l">1255</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1256</TD><TD>                pn = createBinary(Token.ADD, pn, expr);</TD></TR><TR><TD CLASS="l">1257</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1258</TD><TD>        }</TD></TR><TR><TD CLASS="l">1259</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1260</TD><TD>        pnXML.addChildToBack(pn);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="52">1261</A></TD><TD>        return pnXML;</TD></TR><TR><TD CLASS="l">1262</TD><TD>    }</TD></TR><TR><TD CLASS="l">1263</TD><TD> </TD></TR><TR><TD CLASS="l">1264</TD><TD>    private Node transformXmlMemberGet(XmlMemberGet node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1265</TD><TD>        XmlRef ref = node.getMemberRef();</TD></TR><TR CLASS="c"><TD CLASS="l">1266</TD><TD>        Node pn = transform(node.getLeft());</TD></TR><TR CLASS="c"><TD CLASS="l">1267</TD><TD>        int flags = ref.isAttributeAccess() ? Node.ATTRIBUTE_FLAG : 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1268</TD><TD>        if (node.getType() == Token.DOTDOT) {</TD></TR><TR CLASS="c"><TD CLASS="l">1269</TD><TD>            flags |= Node.DESCENDANTS_FLAG;</TD></TR><TR CLASS="c"><TD CLASS="l">1270</TD><TD>            decompiler.addToken(Token.DOTDOT);</TD></TR><TR><TD CLASS="l">1271</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1272</TD><TD>            decompiler.addToken(Token.DOT);</TD></TR><TR><TD CLASS="l">1273</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1274</TD><TD>        return transformXmlRef(pn, ref, flags);</TD></TR><TR><TD CLASS="l"><A NAME="54">1275</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1276</TD><TD> </TD></TR><TR><TD CLASS="l">1277</TD><TD>    // We get here if we weren't a child of a . or .. infix node</TD></TR><TR><TD CLASS="l">1278</TD><TD>    private Node transformXmlRef(XmlRef node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1279</TD><TD>        int memberTypeFlags = node.isAttributeAccess()</TD></TR><TR><TD CLASS="l">1280</TD><TD>            ? Node.ATTRIBUTE_FLAG : 0;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="53">1281</A></TD><TD>        return transformXmlRef(null, node, memberTypeFlags);</TD></TR><TR><TD CLASS="l">1282</TD><TD>    }</TD></TR><TR><TD CLASS="l">1283</TD><TD> </TD></TR><TR><TD CLASS="l">1284</TD><TD>    private Node transformXmlRef(Node pn, XmlRef node, int memberTypeFlags) {</TD></TR><TR CLASS="c"><TD CLASS="l">1285</TD><TD>        if ((memberTypeFlags &amp; Node.ATTRIBUTE_FLAG) != 0)</TD></TR><TR CLASS="c"><TD CLASS="l">1286</TD><TD>            decompiler.addToken(Token.XMLATTR);</TD></TR><TR CLASS="c"><TD CLASS="l">1287</TD><TD>        Name namespace = node.getNamespace();</TD></TR><TR CLASS="c"><TD CLASS="l">1288</TD><TD>        String ns = namespace != null ? namespace.getIdentifier() : null;</TD></TR><TR CLASS="c"><TD CLASS="l">1289</TD><TD>        if (ns != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1290</TD><TD>            decompiler.addName(ns);</TD></TR><TR CLASS="c"><TD CLASS="l">1291</TD><TD>            decompiler.addToken(Token.COLONCOLON);</TD></TR><TR><TD CLASS="l">1292</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1293</TD><TD>        if (node instanceof XmlPropRef) {</TD></TR><TR CLASS="c"><TD CLASS="l">1294</TD><TD>            String name = ((XmlPropRef)node).getPropName().getIdentifier();</TD></TR><TR CLASS="c"><TD CLASS="l">1295</TD><TD>            decompiler.addName(name);</TD></TR><TR CLASS="c"><TD CLASS="l">1296</TD><TD>            return createPropertyGet(pn, ns, name, memberTypeFlags);</TD></TR><TR><TD CLASS="l">1297</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1298</TD><TD>            decompiler.addToken(Token.LB);</TD></TR><TR CLASS="c"><TD CLASS="l">1299</TD><TD>            Node expr = transform(((XmlElemRef)node).getExpression());</TD></TR><TR CLASS="c"><TD CLASS="l">1300</TD><TD>            decompiler.addToken(Token.RB);</TD></TR><TR CLASS="c"><TD CLASS="l">1301</TD><TD>            return createElementGet(pn, ns, expr, memberTypeFlags);</TD></TR><TR><TD CLASS="l"><A NAME="39">1302</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1303</TD><TD>    }</TD></TR><TR><TD CLASS="l">1304</TD><TD> </TD></TR><TR><TD CLASS="l">1305</TD><TD>    private Node transformDefaultXmlNamepace(UnaryExpression node) {</TD></TR><TR CLASS="c"><TD CLASS="l">1306</TD><TD>        decompiler.addToken(Token.DEFAULT);</TD></TR><TR CLASS="c"><TD CLASS="l">1307</TD><TD>        decompiler.addName(&#34; xml&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1308</TD><TD>        decompiler.addName(&#34; namespace&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1309</TD><TD>        decompiler.addToken(Token.ASSIGN);</TD></TR><TR CLASS="c"><TD CLASS="l">1310</TD><TD>        Node child = transform(node.getOperand());</TD></TR><TR CLASS="c"><TD CLASS="l">1311</TD><TD>        return createUnary(Token.DEFAULTNAMESPACE, child);</TD></TR><TR><TD CLASS="l">1312</TD><TD>    }</TD></TR><TR><TD CLASS="l">1313</TD><TD> </TD></TR><TR><TD CLASS="l">1314</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1315</TD><TD>     * If caseExpression argument is null it indicates a default label.</TD></TR><TR><TD CLASS="l"><A NAME="e">1316</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1317</TD><TD>    private void addSwitchCase(Node switchBlock, Node caseExpression,</TD></TR><TR><TD CLASS="l">1318</TD><TD>                               Node statements)</TD></TR><TR><TD CLASS="l">1319</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (4 out of 6 instructions)">1320</TD><TD TITLE="67% line coverage (4 out of 6 instructions)">        if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">1321</TD><TD>        Jump switchNode = (Jump)switchBlock.getFirstChild();</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="80% line coverage (8 out of 10 instructions)">1322</TD><TD TITLE="80% line coverage (8 out of 10 instructions)">        if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">1323</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1324</TD><TD>        Node gotoTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1325</TD><TD>        if (caseExpression != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1326</TD><TD>            Jump caseNode = new Jump(Token.CASE, caseExpression);</TD></TR><TR CLASS="c"><TD CLASS="l">1327</TD><TD>            caseNode.target = gotoTarget;</TD></TR><TR CLASS="c"><TD CLASS="l">1328</TD><TD>            switchNode.addChildToBack(caseNode);</TD></TR><TR CLASS="c"><TD CLASS="l">1329</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1330</TD><TD>            switchNode.setDefault(gotoTarget);</TD></TR><TR><TD CLASS="l">1331</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1332</TD><TD>        switchBlock.addChildToBack(gotoTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1333</TD><TD>        switchBlock.addChildToBack(statements);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="d">1334</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1335</TD><TD> </TD></TR><TR><TD CLASS="l">1336</TD><TD>    private void closeSwitch(Node switchBlock)</TD></TR><TR><TD CLASS="l">1337</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (4 out of 6 instructions)">1338</TD><TD TITLE="67% line coverage (4 out of 6 instructions)">        if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">1339</TD><TD>        Jump switchNode = (Jump)switchBlock.getFirstChild();</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="80% line coverage (8 out of 10 instructions)">1340</TD><TD TITLE="80% line coverage (8 out of 10 instructions)">        if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">1341</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1342</TD><TD>        Node switchBreakTarget = Node.newTarget();</TD></TR><TR><TD CLASS="l">1343</TD><TD>        // switchNode.target is only used by NodeTransformer</TD></TR><TR><TD CLASS="l">1344</TD><TD>        // to detect switch end</TD></TR><TR CLASS="c"><TD CLASS="l">1345</TD><TD>        switchNode.target = switchBreakTarget;</TD></TR><TR><TD CLASS="l">1346</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1347</TD><TD>        Node defaultTarget = switchNode.getDefault();</TD></TR><TR CLASS="c"><TD CLASS="l">1348</TD><TD>        if (defaultTarget == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1349</TD><TD>            defaultTarget = switchBreakTarget;</TD></TR><TR><TD CLASS="l">1350</TD><TD>        }</TD></TR><TR><TD CLASS="l">1351</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1352</TD><TD>        switchBlock.addChildAfter(makeJump(Token.GOTO, defaultTarget),</TD></TR><TR><TD CLASS="l">1353</TD><TD>                                  switchNode);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2">1354</A></TD><TD>        switchBlock.addChildToBack(switchBreakTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1355</TD><TD>    }</TD></TR><TR><TD CLASS="l">1356</TD><TD> </TD></TR><TR><TD CLASS="l">1357</TD><TD>    private Node createExprStatementNoReturn(Node expr, int lineno) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="28">1358</A></TD><TD>        return new Node(Token.EXPR_VOID, expr, lineno);</TD></TR><TR><TD CLASS="l">1359</TD><TD>    }</TD></TR><TR><TD CLASS="l">1360</TD><TD> </TD></TR><TR><TD CLASS="l">1361</TD><TD>    private Node createString(String string) {</TD></TR><TR CLASS="c"><TD CLASS="l">1362</TD><TD>        return Node.newString(string);</TD></TR><TR><TD CLASS="l">1363</TD><TD>    }</TD></TR><TR><TD CLASS="l">1364</TD><TD> </TD></TR><TR><TD CLASS="l">1365</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1366</TD><TD>     * Catch clause of try/catch/finally</TD></TR><TR><TD CLASS="l">1367</TD><TD>     * @param varName the name of the variable to bind to the exception</TD></TR><TR><TD CLASS="l">1368</TD><TD>     * @param catchCond the condition under which to catch the exception.</TD></TR><TR><TD CLASS="l">1369</TD><TD>     *                  May be null if no condition is given.</TD></TR><TR><TD CLASS="l">1370</TD><TD>     * @param stmts the statements in the catch clause</TD></TR><TR><TD CLASS="l"><A NAME="9">1371</A></TD><TD>     * @param lineno the starting line number of the catch clause</TD></TR><TR><TD CLASS="l">1372</TD><TD>     */</TD></TR><TR><TD CLASS="l">1373</TD><TD>    private Node createCatch(String varName, Node catchCond, Node stmts,</TD></TR><TR><TD CLASS="l">1374</TD><TD>                             int lineno) {</TD></TR><TR CLASS="c"><TD CLASS="l">1375</TD><TD>        if (catchCond == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1376</TD><TD>            catchCond = new Node(Token.EMPTY);</TD></TR><TR><TD CLASS="l">1377</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1378</TD><TD>        return new Node(Token.CATCH, createName(varName),</TD></TR><TR><TD CLASS="l">1379</TD><TD>                        catchCond, stmts, lineno);</TD></TR><TR><TD CLASS="l"><A NAME="2f">1380</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1381</TD><TD> </TD></TR><TR><TD CLASS="l">1382</TD><TD>    private Node initFunction(FunctionNode fnNode, int functionIndex,</TD></TR><TR><TD CLASS="l">1383</TD><TD>                              Node statements, int functionType) {</TD></TR><TR CLASS="c"><TD CLASS="l">1384</TD><TD>        fnNode.setFunctionType(functionType);</TD></TR><TR CLASS="c"><TD CLASS="l">1385</TD><TD>        fnNode.addChildToBack(statements);</TD></TR><TR><TD CLASS="l">1386</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1387</TD><TD>        int functionCount = fnNode.getFunctionCount();</TD></TR><TR CLASS="c"><TD CLASS="l">1388</TD><TD>        if (functionCount != 0) {</TD></TR><TR><TD CLASS="l">1389</TD><TD>            // Functions containing other functions require activation objects</TD></TR><TR CLASS="c"><TD CLASS="l">1390</TD><TD>            fnNode.setRequiresActivation();</TD></TR><TR><TD CLASS="l">1391</TD><TD>        }</TD></TR><TR><TD CLASS="l">1392</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1393</TD><TD>        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {</TD></TR><TR CLASS="c"><TD CLASS="l">1394</TD><TD>            Name name = fnNode.getFunctionName();</TD></TR><TR CLASS="c"><TD CLASS="l">1395</TD><TD>            if (name != null &amp;&amp; name.length() != 0</TD></TR><TR><TD CLASS="l">1396</TD><TD>                    &amp;&amp; fnNode.getSymbol(name.getIdentifier()) == null) {</TD></TR><TR><TD CLASS="l">1397</TD><TD>                // A function expression needs to have its name as a</TD></TR><TR><TD CLASS="l">1398</TD><TD>                // variable (if it isn't already allocated as a variable).</TD></TR><TR><TD CLASS="l">1399</TD><TD>                // See ECMA Ch. 13.  We add code to the beginning of the</TD></TR><TR><TD CLASS="l">1400</TD><TD>                // function to initialize a local variable of the</TD></TR><TR><TD CLASS="l">1401</TD><TD>                // function's name to the function value, but only if the</TD></TR><TR><TD CLASS="l">1402</TD><TD>                // function doesn't already define a formal parameter, var,</TD></TR><TR><TD CLASS="l">1403</TD><TD>                // or nested function with the same name.</TD></TR><TR CLASS="c"><TD CLASS="l">1404</TD><TD>                fnNode.putSymbol(new Symbol(Token.FUNCTION, name.getIdentifier()));</TD></TR><TR CLASS="c"><TD CLASS="l">1405</TD><TD>                Node setFn = new Node(Token.EXPR_VOID,</TD></TR><TR><TD CLASS="l">1406</TD><TD>                                 new Node(Token.SETNAME,</TD></TR><TR><TD CLASS="l">1407</TD><TD>                                          Node.newString(Token.BINDNAME,</TD></TR><TR><TD CLASS="l">1408</TD><TD>                                                         name.getIdentifier()),</TD></TR><TR><TD CLASS="l">1409</TD><TD>                                     new Node(Token.THISFN)));</TD></TR><TR CLASS="c"><TD CLASS="l">1410</TD><TD>                statements.addChildrenToFront(setFn);</TD></TR><TR><TD CLASS="l">1411</TD><TD>            }</TD></TR><TR><TD CLASS="l">1412</TD><TD>        }</TD></TR><TR><TD CLASS="l">1413</TD><TD> </TD></TR><TR><TD CLASS="l">1414</TD><TD>        // Add return to end if needed.</TD></TR><TR CLASS="c"><TD CLASS="l">1415</TD><TD>        Node lastStmt = statements.getLastChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1416</TD><TD>        if (lastStmt == null || lastStmt.getType() != Token.RETURN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1417</TD><TD>            statements.addChildToBack(new Node(Token.RETURN));</TD></TR><TR><TD CLASS="l">1418</TD><TD>        }</TD></TR><TR><TD CLASS="l">1419</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1420</TD><TD>        Node result = Node.newString(Token.FUNCTION, fnNode.getName());</TD></TR><TR CLASS="c"><TD CLASS="l">1421</TD><TD>        result.putIntProp(Node.FUNCTION_PROP, functionIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">1422</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1423</TD><TD>    }</TD></TR><TR><TD CLASS="l">1424</TD><TD> </TD></TR><TR><TD CLASS="l">1425</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1426</TD><TD>     * Create loop node. The code generator will later call</TD></TR><TR><TD CLASS="l"><A NAME="8">1427</A></TD><TD>     * createWhile|createDoWhile|createFor|createForIn</TD></TR><TR><TD CLASS="l">1428</TD><TD>     * to finish loop generation.</TD></TR><TR><TD CLASS="l">1429</TD><TD>     */</TD></TR><TR><TD CLASS="l">1430</TD><TD>    private Scope createLoopNode(Node loopLabel, int lineno) {</TD></TR><TR CLASS="c"><TD CLASS="l">1431</TD><TD>        Scope result = createScopeNode(Token.LOOP, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">1432</TD><TD>        if (loopLabel != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1433</TD><TD>            ((Jump)loopLabel).setLoop(result);</TD></TR><TR><TD CLASS="l">1434</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1435</TD><TD>        return result;</TD></TR><TR><TD CLASS="l"><A NAME="24">1436</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1437</TD><TD> </TD></TR><TR><TD CLASS="l">1438</TD><TD>    private Node createFor(Scope loop, Node init,</TD></TR><TR><TD CLASS="l">1439</TD><TD>                           Node test, Node incr, Node body) {</TD></TR><TR CLASS="c"><TD CLASS="l">1440</TD><TD>        if (init.getType() == Token.LET) {</TD></TR><TR><TD CLASS="l">1441</TD><TD>            // rewrite &#34;for (let i=s; i &lt; N; i++)...&#34; as</TD></TR><TR><TD CLASS="l">1442</TD><TD>            // &#34;let (i=s) { for (; i &lt; N; i++)...&#34; so that &#34;s&#34; is evaluated</TD></TR><TR><TD CLASS="l">1443</TD><TD>            // outside the scope of the for.</TD></TR><TR CLASS="c"><TD CLASS="l">1444</TD><TD>            Scope let = Scope.splitScope(loop);</TD></TR><TR CLASS="c"><TD CLASS="l">1445</TD><TD>            let.setType(Token.LET);</TD></TR><TR CLASS="c"><TD CLASS="l">1446</TD><TD>            let.addChildrenToBack(init);</TD></TR><TR CLASS="c"><TD CLASS="l">1447</TD><TD>            let.addChildToBack(createLoop(loop, LOOP_FOR, body, test,</TD></TR><TR><TD CLASS="l">1448</TD><TD>                new Node(Token.EMPTY), incr));</TD></TR><TR CLASS="c"><TD CLASS="l">1449</TD><TD>            return let;</TD></TR><TR><TD CLASS="l">1450</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1451</TD><TD>        return createLoop(loop, LOOP_FOR, body, test, init, incr);</TD></TR><TR><TD CLASS="l">1452</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="26">1453</A></TD><TD> </TD></TR><TR><TD CLASS="l">1454</TD><TD>    private Node createLoop(Jump loop, int loopType, Node body,</TD></TR><TR><TD CLASS="l">1455</TD><TD>                            Node cond, Node init, Node incr)</TD></TR><TR><TD CLASS="l">1456</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1457</TD><TD>        Node bodyTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1458</TD><TD>        Node condTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1459</TD><TD>        if (loopType == LOOP_FOR &amp;&amp; cond.getType() == Token.EMPTY) {</TD></TR><TR CLASS="c"><TD CLASS="l">1460</TD><TD>            cond = new Node(Token.TRUE);</TD></TR><TR><TD CLASS="l">1461</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1462</TD><TD>        Jump IFEQ = new Jump(Token.IFEQ, cond);</TD></TR><TR CLASS="c"><TD CLASS="l">1463</TD><TD>        IFEQ.target = bodyTarget;</TD></TR><TR CLASS="c"><TD CLASS="l">1464</TD><TD>        Node breakTarget = Node.newTarget();</TD></TR><TR><TD CLASS="l">1465</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1466</TD><TD>        loop.addChildToBack(bodyTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1467</TD><TD>        loop.addChildrenToBack(body);</TD></TR><TR CLASS="c"><TD CLASS="l">1468</TD><TD>        if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {</TD></TR><TR><TD CLASS="l">1469</TD><TD>            // propagate lineno to condition</TD></TR><TR CLASS="c"><TD CLASS="l">1470</TD><TD>            loop.addChildrenToBack(new Node(Token.EMPTY, loop.getLineno()));</TD></TR><TR><TD CLASS="l">1471</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1472</TD><TD>        loop.addChildToBack(condTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1473</TD><TD>        loop.addChildToBack(IFEQ);</TD></TR><TR CLASS="c"><TD CLASS="l">1474</TD><TD>        loop.addChildToBack(breakTarget);</TD></TR><TR><TD CLASS="l">1475</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1476</TD><TD>        loop.target = breakTarget;</TD></TR><TR CLASS="c"><TD CLASS="l">1477</TD><TD>        Node continueTarget = condTarget;</TD></TR><TR><TD CLASS="l">1478</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1479</TD><TD>        if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {</TD></TR><TR><TD CLASS="l">1480</TD><TD>            // Just add a GOTO to the condition in the do..while</TD></TR><TR CLASS="c"><TD CLASS="l">1481</TD><TD>            loop.addChildToFront(makeJump(Token.GOTO, condTarget));</TD></TR><TR><TD CLASS="l">1482</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1483</TD><TD>            if (loopType == LOOP_FOR) {</TD></TR><TR CLASS="c"><TD CLASS="l">1484</TD><TD>                int initType = init.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">1485</TD><TD>                if (initType != Token.EMPTY) {</TD></TR><TR CLASS="c"><TD CLASS="l">1486</TD><TD>                    if (initType != Token.VAR &amp;&amp; initType != Token.LET) {</TD></TR><TR CLASS="c"><TD CLASS="l">1487</TD><TD>                        init = new Node(Token.EXPR_VOID, init);</TD></TR><TR><TD CLASS="l">1488</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">1489</TD><TD>                    loop.addChildToFront(init);</TD></TR><TR><TD CLASS="l">1490</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1491</TD><TD>                Node incrTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1492</TD><TD>                loop.addChildAfter(incrTarget, body);</TD></TR><TR CLASS="c"><TD CLASS="l">1493</TD><TD>                if (incr.getType() != Token.EMPTY) {</TD></TR><TR CLASS="c"><TD CLASS="l">1494</TD><TD>                    incr = new Node(Token.EXPR_VOID, incr);</TD></TR><TR CLASS="c"><TD CLASS="l">1495</TD><TD>                    loop.addChildAfter(incr, incrTarget);</TD></TR><TR><TD CLASS="l">1496</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1497</TD><TD>                continueTarget = incrTarget;</TD></TR><TR><TD CLASS="l">1498</TD><TD>            }</TD></TR><TR><TD CLASS="l">1499</TD><TD>        }</TD></TR><TR><TD CLASS="l">1500</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1501</TD><TD>        loop.setContinue(continueTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1502</TD><TD>        return loop;</TD></TR><TR><TD CLASS="l">1503</TD><TD>    }</TD></TR><TR><TD CLASS="l">1504</TD><TD> </TD></TR><TR><TD CLASS="l">1505</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1506</TD><TD>     * Generate IR for a for..in loop.</TD></TR><TR><TD CLASS="l"><A NAME="16">1507</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1508</TD><TD>    private Node createForIn(int declType, Node loop, Node lhs,</TD></TR><TR><TD CLASS="l">1509</TD><TD>                             Node obj, Node body, boolean isForEach)</TD></TR><TR><TD CLASS="l">1510</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1511</TD><TD>        int destructuring = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">1512</TD><TD>        int destructuringLen = 0;</TD></TR><TR><TD CLASS="l">1513</TD><TD>        Node lvalue;</TD></TR><TR CLASS="c"><TD CLASS="l">1514</TD><TD>        int type = lhs.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">1515</TD><TD>        if (type == Token.VAR || type == Token.LET) {</TD></TR><TR CLASS="c"><TD CLASS="l">1516</TD><TD>            Node kid = lhs.getLastChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1517</TD><TD>            int kidType = kid.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">1518</TD><TD>            if (kidType == Token.ARRAYLIT || kidType == Token.OBJECTLIT)</TD></TR><TR><TD CLASS="l">1519</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1520</TD><TD>                type = destructuring = kidType;</TD></TR><TR CLASS="c"><TD CLASS="l">1521</TD><TD>                lvalue = kid;</TD></TR><TR CLASS="c"><TD CLASS="l">1522</TD><TD>                destructuringLen = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1523</TD><TD>                if (kid instanceof ArrayLiteral)</TD></TR><TR CLASS="c"><TD CLASS="l">1524</TD><TD>                    destructuringLen = ((ArrayLiteral) kid).getDestructuringLength();</TD></TR><TR CLASS="c"><TD CLASS="l">1525</TD><TD>            } else if (kidType == Token.NAME) {</TD></TR><TR CLASS="c"><TD CLASS="l">1526</TD><TD>                lvalue = Node.newString(Token.NAME, kid.getString());</TD></TR><TR><TD CLASS="l">1527</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1528</TD><TD>                reportError(&#34;msg.bad.for.in.lhs&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1529</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">1530</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1531</TD><TD>        } else if (type == Token.ARRAYLIT || type == Token.OBJECTLIT) {</TD></TR><TR CLASS="c"><TD CLASS="l">1532</TD><TD>            destructuring = type;</TD></TR><TR CLASS="c"><TD CLASS="l">1533</TD><TD>            lvalue = lhs;</TD></TR><TR CLASS="c"><TD CLASS="l">1534</TD><TD>            destructuringLen = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1535</TD><TD>            if (lhs instanceof ArrayLiteral)</TD></TR><TR CLASS="c"><TD CLASS="l">1536</TD><TD>                destructuringLen = ((ArrayLiteral) lhs).getDestructuringLength();</TD></TR><TR><TD CLASS="l">1537</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1538</TD><TD>            lvalue = makeReference(lhs);</TD></TR><TR CLASS="c"><TD CLASS="l">1539</TD><TD>            if (lvalue == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1540</TD><TD>                reportError(&#34;msg.bad.for.in.lhs&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">1542</TD><TD>            }</TD></TR><TR><TD CLASS="l">1543</TD><TD>        }</TD></TR><TR><TD CLASS="l">1544</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1545</TD><TD>        Node localBlock = new Node(Token.LOCAL_BLOCK);</TD></TR><TR CLASS="c"><TD CLASS="l">1546</TD><TD>        int initType = isForEach ? Token.ENUM_INIT_VALUES</TD></TR><TR><TD CLASS="l">1547</TD><TD>                                 : (destructuring != -1</TD></TR><TR><TD CLASS="l">1548</TD><TD>                                    ? Token.ENUM_INIT_ARRAY</TD></TR><TR><TD CLASS="l">1549</TD><TD>                                    : Token.ENUM_INIT_KEYS);</TD></TR><TR CLASS="c"><TD CLASS="l">1550</TD><TD>        Node init = new Node(initType, obj);</TD></TR><TR CLASS="c"><TD CLASS="l">1551</TD><TD>        init.putProp(Node.LOCAL_BLOCK_PROP, localBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1552</TD><TD>        Node cond = new Node(Token.ENUM_NEXT);</TD></TR><TR CLASS="c"><TD CLASS="l">1553</TD><TD>        cond.putProp(Node.LOCAL_BLOCK_PROP, localBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1554</TD><TD>        Node id = new Node(Token.ENUM_ID);</TD></TR><TR CLASS="c"><TD CLASS="l">1555</TD><TD>        id.putProp(Node.LOCAL_BLOCK_PROP, localBlock);</TD></TR><TR><TD CLASS="l">1556</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1557</TD><TD>        Node newBody = new Node(Token.BLOCK);</TD></TR><TR><TD CLASS="l">1558</TD><TD>        Node assign;</TD></TR><TR CLASS="c"><TD CLASS="l">1559</TD><TD>        if (destructuring != -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">1560</TD><TD>            assign = createDestructuringAssignment(declType, lvalue, id);</TD></TR><TR CLASS="c"><TD CLASS="l">1561</TD><TD>            if (!isForEach &amp;&amp; (destructuring == Token.OBJECTLIT ||</TD></TR><TR><TD CLASS="l">1562</TD><TD>                               destructuringLen != 2))</TD></TR><TR><TD CLASS="l">1563</TD><TD>            {</TD></TR><TR><TD CLASS="l">1564</TD><TD>                // destructuring assignment is only allowed in for..each or</TD></TR><TR><TD CLASS="l">1565</TD><TD>                // with an array type of length 2 (to hold key and value)</TD></TR><TR CLASS="z"><TD CLASS="l">1566</TD><TD>                reportError(&#34;msg.bad.for.in.destruct&#34;);</TD></TR><TR><TD CLASS="l">1567</TD><TD>            }</TD></TR><TR><TD CLASS="l">1568</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1569</TD><TD>            assign = simpleAssignment(lvalue, id);</TD></TR><TR><TD CLASS="l">1570</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1571</TD><TD>        newBody.addChildToBack(new Node(Token.EXPR_VOID, assign));</TD></TR><TR CLASS="c"><TD CLASS="l">1572</TD><TD>        newBody.addChildToBack(body);</TD></TR><TR><TD CLASS="l">1573</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1574</TD><TD>        loop = createLoop((Jump)loop, LOOP_WHILE, newBody, cond, null, null);</TD></TR><TR CLASS="c"><TD CLASS="l">1575</TD><TD>        loop.addChildToFront(init);</TD></TR><TR CLASS="c"><TD CLASS="l">1576</TD><TD>        if (type == Token.VAR || type == Token.LET)</TD></TR><TR CLASS="c"><TD CLASS="l">1577</TD><TD>            loop.addChildToFront(lhs);</TD></TR><TR CLASS="c"><TD CLASS="l">1578</TD><TD>        localBlock.addChildToBack(loop);</TD></TR><TR><TD CLASS="l">1579</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1580</TD><TD>        return localBlock;</TD></TR><TR><TD CLASS="l">1581</TD><TD>    }</TD></TR><TR><TD CLASS="l">1582</TD><TD> </TD></TR><TR><TD CLASS="l">1583</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1584</TD><TD>     * Try/Catch/Finally</TD></TR><TR><TD CLASS="l">1585</TD><TD>     *</TD></TR><TR><TD CLASS="l">1586</TD><TD>     * The IRFactory tries to express as much as possible in the tree;</TD></TR><TR><TD CLASS="l">1587</TD><TD>     * the responsibilities remaining for Codegen are to add the Java</TD></TR><TR><TD CLASS="l">1588</TD><TD>     * handlers: (Either (but not both) of TARGET and FINALLY might not</TD></TR><TR><TD CLASS="l">1589</TD><TD>     * be defined)</TD></TR><TR><TD CLASS="l">1590</TD><TD>     *</TD></TR><TR><TD CLASS="l">1591</TD><TD>     * - a catch handler for javascript exceptions that unwraps the</TD></TR><TR><TD CLASS="l">1592</TD><TD>     * exception onto the stack and GOTOes to the catch target</TD></TR><TR><TD CLASS="l">1593</TD><TD>     *</TD></TR><TR><TD CLASS="l">1594</TD><TD>     * - a finally handler</TD></TR><TR><TD CLASS="l">1595</TD><TD>     *</TD></TR><TR><TD CLASS="l">1596</TD><TD>     * ... and a goto to GOTO around these handlers.</TD></TR><TR><TD CLASS="l"><A NAME="29">1597</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1598</TD><TD>    private Node createTryCatchFinally(Node tryBlock, Node catchBlocks,</TD></TR><TR><TD CLASS="l">1599</TD><TD>                                       Node finallyBlock, int lineno)</TD></TR><TR><TD CLASS="l">1600</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1601</TD><TD>        boolean hasFinally = (finallyBlock != null)</TD></TR><TR><TD CLASS="l">1602</TD><TD>                             &amp;&amp; (finallyBlock.getType() != Token.BLOCK</TD></TR><TR><TD CLASS="l">1603</TD><TD>                                 || finallyBlock.hasChildren());</TD></TR><TR><TD CLASS="l">1604</TD><TD> </TD></TR><TR><TD CLASS="l">1605</TD><TD>        // short circuit</TD></TR><TR CLASS="c"><TD CLASS="l">1606</TD><TD>        if (tryBlock.getType() == Token.BLOCK &amp;&amp; !tryBlock.hasChildren()</TD></TR><TR><TD CLASS="l">1607</TD><TD>            &amp;&amp; !hasFinally)</TD></TR><TR><TD CLASS="l">1608</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1609</TD><TD>            return tryBlock;</TD></TR><TR><TD CLASS="l">1610</TD><TD>        }</TD></TR><TR><TD CLASS="l">1611</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1612</TD><TD>        boolean hasCatch = catchBlocks.hasChildren();</TD></TR><TR><TD CLASS="l">1613</TD><TD> </TD></TR><TR><TD CLASS="l">1614</TD><TD>        // short circuit</TD></TR><TR CLASS="c"><TD CLASS="l">1615</TD><TD>        if (!hasFinally &amp;&amp; !hasCatch)  {</TD></TR><TR><TD CLASS="l">1616</TD><TD>            // bc finally might be an empty block...</TD></TR><TR CLASS="c"><TD CLASS="l">1617</TD><TD>            return tryBlock;</TD></TR><TR><TD CLASS="l">1618</TD><TD>        }</TD></TR><TR><TD CLASS="l">1619</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1620</TD><TD>        Node handlerBlock  = new Node(Token.LOCAL_BLOCK);</TD></TR><TR CLASS="c"><TD CLASS="l">1621</TD><TD>        Jump pn = new Jump(Token.TRY, tryBlock, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">1622</TD><TD>        pn.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);</TD></TR><TR><TD CLASS="l">1623</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1624</TD><TD>        if (hasCatch) {</TD></TR><TR><TD CLASS="l">1625</TD><TD>            // jump around catch code</TD></TR><TR CLASS="c"><TD CLASS="l">1626</TD><TD>            Node endCatch = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1627</TD><TD>            pn.addChildToBack(makeJump(Token.GOTO, endCatch));</TD></TR><TR><TD CLASS="l">1628</TD><TD> </TD></TR><TR><TD CLASS="l">1629</TD><TD>            // make a TARGET for the catch that the tcf node knows about</TD></TR><TR CLASS="c"><TD CLASS="l">1630</TD><TD>            Node catchTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1631</TD><TD>            pn.target = catchTarget;</TD></TR><TR><TD CLASS="l">1632</TD><TD>            // mark it</TD></TR><TR CLASS="c"><TD CLASS="l">1633</TD><TD>            pn.addChildToBack(catchTarget);</TD></TR><TR><TD CLASS="l">1634</TD><TD> </TD></TR><TR><TD CLASS="l">1635</TD><TD>            //</TD></TR><TR><TD CLASS="l">1636</TD><TD>            //  Given</TD></TR><TR><TD CLASS="l">1637</TD><TD>            //</TD></TR><TR><TD CLASS="l">1638</TD><TD>            //   try {</TD></TR><TR><TD CLASS="l">1639</TD><TD>            //       tryBlock;</TD></TR><TR><TD CLASS="l">1640</TD><TD>            //   } catch (e if condition1) {</TD></TR><TR><TD CLASS="l">1641</TD><TD>            //       something1;</TD></TR><TR><TD CLASS="l">1642</TD><TD>            //   ...</TD></TR><TR><TD CLASS="l">1643</TD><TD>            //</TD></TR><TR><TD CLASS="l">1644</TD><TD>            //   } catch (e if conditionN) {</TD></TR><TR><TD CLASS="l">1645</TD><TD>            //       somethingN;</TD></TR><TR><TD CLASS="l">1646</TD><TD>            //   } catch (e) {</TD></TR><TR><TD CLASS="l">1647</TD><TD>            //       somethingDefault;</TD></TR><TR><TD CLASS="l">1648</TD><TD>            //   }</TD></TR><TR><TD CLASS="l">1649</TD><TD>            //</TD></TR><TR><TD CLASS="l">1650</TD><TD>            //  rewrite as</TD></TR><TR><TD CLASS="l">1651</TD><TD>            //</TD></TR><TR><TD CLASS="l">1652</TD><TD>            //   try {</TD></TR><TR><TD CLASS="l">1653</TD><TD>            //       tryBlock;</TD></TR><TR><TD CLASS="l">1654</TD><TD>            //       goto after_catch:</TD></TR><TR><TD CLASS="l">1655</TD><TD>            //   } catch (x) {</TD></TR><TR><TD CLASS="l">1656</TD><TD>            //       with (newCatchScope(e, x)) {</TD></TR><TR><TD CLASS="l">1657</TD><TD>            //           if (condition1) {</TD></TR><TR><TD CLASS="l">1658</TD><TD>            //               something1;</TD></TR><TR><TD CLASS="l">1659</TD><TD>            //               goto after_catch;</TD></TR><TR><TD CLASS="l">1660</TD><TD>            //           }</TD></TR><TR><TD CLASS="l">1661</TD><TD>            //       }</TD></TR><TR><TD CLASS="l">1662</TD><TD>            //   ...</TD></TR><TR><TD CLASS="l">1663</TD><TD>            //       with (newCatchScope(e, x)) {</TD></TR><TR><TD CLASS="l">1664</TD><TD>            //           if (conditionN) {</TD></TR><TR><TD CLASS="l">1665</TD><TD>            //               somethingN;</TD></TR><TR><TD CLASS="l">1666</TD><TD>            //               goto after_catch;</TD></TR><TR><TD CLASS="l">1667</TD><TD>            //           }</TD></TR><TR><TD CLASS="l">1668</TD><TD>            //       }</TD></TR><TR><TD CLASS="l">1669</TD><TD>            //       with (newCatchScope(e, x)) {</TD></TR><TR><TD CLASS="l">1670</TD><TD>            //           somethingDefault;</TD></TR><TR><TD CLASS="l">1671</TD><TD>            //           goto after_catch;</TD></TR><TR><TD CLASS="l">1672</TD><TD>            //       }</TD></TR><TR><TD CLASS="l">1673</TD><TD>            //   }</TD></TR><TR><TD CLASS="l">1674</TD><TD>            // after_catch:</TD></TR><TR><TD CLASS="l">1675</TD><TD>            //</TD></TR><TR><TD CLASS="l">1676</TD><TD>            // If there is no default catch, then the last with block</TD></TR><TR><TD CLASS="l">1677</TD><TD>            // arround  &#34;somethingDefault;&#34; is replaced by &#34;rethrow;&#34;</TD></TR><TR><TD CLASS="l">1678</TD><TD> </TD></TR><TR><TD CLASS="l">1679</TD><TD>            // It is assumed that catch handler generation will store</TD></TR><TR><TD CLASS="l">1680</TD><TD>            // exeception object in handlerBlock register</TD></TR><TR><TD CLASS="l">1681</TD><TD> </TD></TR><TR><TD CLASS="l">1682</TD><TD>            // Block with local for exception scope objects</TD></TR><TR CLASS="c"><TD CLASS="l">1683</TD><TD>            Node catchScopeBlock = new Node(Token.LOCAL_BLOCK);</TD></TR><TR><TD CLASS="l">1684</TD><TD> </TD></TR><TR><TD CLASS="l">1685</TD><TD>            // expects catchblocks children to be (cond block) pairs.</TD></TR><TR CLASS="c"><TD CLASS="l">1686</TD><TD>            Node cb = catchBlocks.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1687</TD><TD>            boolean hasDefault = false;</TD></TR><TR CLASS="c"><TD CLASS="l">1688</TD><TD>            int scopeIndex = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1689</TD><TD>            while (cb != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1690</TD><TD>                int catchLineNo = cb.getLineno();</TD></TR><TR><TD CLASS="l">1691</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1692</TD><TD>                Node name = cb.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1693</TD><TD>                Node cond = name.getNext();</TD></TR><TR CLASS="c"><TD CLASS="l">1694</TD><TD>                Node catchStatement = cond.getNext();</TD></TR><TR CLASS="c"><TD CLASS="l">1695</TD><TD>                cb.removeChild(name);</TD></TR><TR CLASS="c"><TD CLASS="l">1696</TD><TD>                cb.removeChild(cond);</TD></TR><TR CLASS="c"><TD CLASS="l">1697</TD><TD>                cb.removeChild(catchStatement);</TD></TR><TR><TD CLASS="l">1698</TD><TD> </TD></TR><TR><TD CLASS="l">1699</TD><TD>                // Add goto to the catch statement to jump out of catch</TD></TR><TR><TD CLASS="l">1700</TD><TD>                // but prefix it with LEAVEWITH since try..catch produces</TD></TR><TR><TD CLASS="l">1701</TD><TD>                // &#34;with&#34;code in order to limit the scope of the exception</TD></TR><TR><TD CLASS="l">1702</TD><TD>                // object.</TD></TR><TR CLASS="c"><TD CLASS="l">1703</TD><TD>                catchStatement.addChildToBack(new Node(Token.LEAVEWITH));</TD></TR><TR CLASS="c"><TD CLASS="l">1704</TD><TD>                catchStatement.addChildToBack(makeJump(Token.GOTO, endCatch));</TD></TR><TR><TD CLASS="l">1705</TD><TD> </TD></TR><TR><TD CLASS="l">1706</TD><TD>                // Create condition &#34;if&#34; when present</TD></TR><TR><TD CLASS="l">1707</TD><TD>                Node condStmt;</TD></TR><TR CLASS="c"><TD CLASS="l">1708</TD><TD>                if (cond.getType() == Token.EMPTY) {</TD></TR><TR CLASS="c"><TD CLASS="l">1709</TD><TD>                    condStmt = catchStatement;</TD></TR><TR CLASS="c"><TD CLASS="l">1710</TD><TD>                    hasDefault = true;</TD></TR><TR><TD CLASS="l">1711</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1712</TD><TD>                    condStmt = createIf(cond, catchStatement, null,</TD></TR><TR><TD CLASS="l">1713</TD><TD>                                        catchLineNo);</TD></TR><TR><TD CLASS="l">1714</TD><TD>                }</TD></TR><TR><TD CLASS="l">1715</TD><TD> </TD></TR><TR><TD CLASS="l">1716</TD><TD>                // Generate code to create the scope object and store</TD></TR><TR><TD CLASS="l">1717</TD><TD>                // it in catchScopeBlock register</TD></TR><TR CLASS="c"><TD CLASS="l">1718</TD><TD>                Node catchScope = new Node(Token.CATCH_SCOPE, name,</TD></TR><TR><TD CLASS="l">1719</TD><TD>                                           createUseLocal(handlerBlock));</TD></TR><TR CLASS="c"><TD CLASS="l">1720</TD><TD>                catchScope.putProp(Node.LOCAL_BLOCK_PROP, catchScopeBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1721</TD><TD>                catchScope.putIntProp(Node.CATCH_SCOPE_PROP, scopeIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">1722</TD><TD>                catchScopeBlock.addChildToBack(catchScope);</TD></TR><TR><TD CLASS="l">1723</TD><TD> </TD></TR><TR><TD CLASS="l">1724</TD><TD>                // Add with statement based on catch scope object</TD></TR><TR CLASS="c"><TD CLASS="l">1725</TD><TD>                catchScopeBlock.addChildToBack(</TD></TR><TR><TD CLASS="l">1726</TD><TD>                    createWith(createUseLocal(catchScopeBlock), condStmt,</TD></TR><TR><TD CLASS="l">1727</TD><TD>                               catchLineNo));</TD></TR><TR><TD CLASS="l">1728</TD><TD> </TD></TR><TR><TD CLASS="l">1729</TD><TD>                // move to next cb</TD></TR><TR CLASS="c"><TD CLASS="l">1730</TD><TD>                cb = cb.getNext();</TD></TR><TR CLASS="c"><TD CLASS="l">1731</TD><TD>                ++scopeIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">1732</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1733</TD><TD>            pn.addChildToBack(catchScopeBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1734</TD><TD>            if (!hasDefault) {</TD></TR><TR><TD CLASS="l">1735</TD><TD>                // Generate code to rethrow if no catch clause was executed</TD></TR><TR CLASS="c"><TD CLASS="l">1736</TD><TD>                Node rethrow = new Node(Token.RETHROW);</TD></TR><TR CLASS="c"><TD CLASS="l">1737</TD><TD>                rethrow.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1738</TD><TD>                pn.addChildToBack(rethrow);</TD></TR><TR><TD CLASS="l">1739</TD><TD>            }</TD></TR><TR><TD CLASS="l">1740</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1741</TD><TD>            pn.addChildToBack(endCatch);</TD></TR><TR><TD CLASS="l">1742</TD><TD>        }</TD></TR><TR><TD CLASS="l">1743</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1744</TD><TD>        if (hasFinally) {</TD></TR><TR CLASS="c"><TD CLASS="l">1745</TD><TD>            Node finallyTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1746</TD><TD>            pn.setFinally(finallyTarget);</TD></TR><TR><TD CLASS="l">1747</TD><TD> </TD></TR><TR><TD CLASS="l">1748</TD><TD>            // add jsr finally to the try block</TD></TR><TR CLASS="c"><TD CLASS="l">1749</TD><TD>            pn.addChildToBack(makeJump(Token.JSR, finallyTarget));</TD></TR><TR><TD CLASS="l">1750</TD><TD> </TD></TR><TR><TD CLASS="l">1751</TD><TD>            // jump around finally code</TD></TR><TR CLASS="c"><TD CLASS="l">1752</TD><TD>            Node finallyEnd = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1753</TD><TD>            pn.addChildToBack(makeJump(Token.GOTO, finallyEnd));</TD></TR><TR><TD CLASS="l">1754</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1755</TD><TD>            pn.addChildToBack(finallyTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1756</TD><TD>            Node fBlock = new Node(Token.FINALLY, finallyBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1757</TD><TD>            fBlock.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);</TD></TR><TR CLASS="c"><TD CLASS="l">1758</TD><TD>            pn.addChildToBack(fBlock);</TD></TR><TR><TD CLASS="l">1759</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1760</TD><TD>            pn.addChildToBack(finallyEnd);</TD></TR><TR><TD CLASS="l">1761</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1762</TD><TD>        handlerBlock.addChildToBack(pn);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2b">1763</A></TD><TD>        return handlerBlock;</TD></TR><TR><TD CLASS="l">1764</TD><TD>    }</TD></TR><TR><TD CLASS="l">1765</TD><TD> </TD></TR><TR><TD CLASS="l">1766</TD><TD>    private Node createWith(Node obj, Node body, int lineno) {</TD></TR><TR CLASS="c"><TD CLASS="l">1767</TD><TD>        setRequiresActivation();</TD></TR><TR CLASS="c"><TD CLASS="l">1768</TD><TD>        Node result = new Node(Token.BLOCK, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">1769</TD><TD>        result.addChildToBack(new Node(Token.ENTERWITH, obj));</TD></TR><TR CLASS="c"><TD CLASS="l">1770</TD><TD>        Node bodyNode = new Node(Token.WITH, body, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">1771</TD><TD>        result.addChildrenToBack(bodyNode);</TD></TR><TR CLASS="c"><TD CLASS="l">1772</TD><TD>        result.addChildToBack(new Node(Token.LEAVEWITH));</TD></TR><TR CLASS="c"><TD CLASS="l">1773</TD><TD>        return result;</TD></TR><TR><TD CLASS="l"><A NAME="25">1774</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1775</TD><TD> </TD></TR><TR><TD CLASS="l">1776</TD><TD>    private Node createIf(Node cond, Node ifTrue, Node ifFalse, int lineno)</TD></TR><TR><TD CLASS="l">1777</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1778</TD><TD>        int condStatus = isAlwaysDefinedBoolean(cond);</TD></TR><TR CLASS="c"><TD CLASS="l">1779</TD><TD>        if (condStatus == ALWAYS_TRUE_BOOLEAN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1780</TD><TD>            return ifTrue;</TD></TR><TR CLASS="c"><TD CLASS="l">1781</TD><TD>        } else if (condStatus == ALWAYS_FALSE_BOOLEAN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1782</TD><TD>            if (ifFalse != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1783</TD><TD>                return ifFalse;</TD></TR><TR><TD CLASS="l">1784</TD><TD>            }</TD></TR><TR><TD CLASS="l">1785</TD><TD>            // Replace if (false) xxx by empty block</TD></TR><TR CLASS="c"><TD CLASS="l">1786</TD><TD>            return new Node(Token.BLOCK, lineno);</TD></TR><TR><TD CLASS="l">1787</TD><TD>        }</TD></TR><TR><TD CLASS="l">1788</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1789</TD><TD>        Node result = new Node(Token.BLOCK, lineno);</TD></TR><TR CLASS="c"><TD CLASS="l">1790</TD><TD>        Node ifNotTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1791</TD><TD>        Jump IFNE = new Jump(Token.IFNE, cond);</TD></TR><TR CLASS="c"><TD CLASS="l">1792</TD><TD>        IFNE.target = ifNotTarget;</TD></TR><TR><TD CLASS="l">1793</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1794</TD><TD>        result.addChildToBack(IFNE);</TD></TR><TR CLASS="c"><TD CLASS="l">1795</TD><TD>        result.addChildrenToBack(ifTrue);</TD></TR><TR><TD CLASS="l">1796</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1797</TD><TD>        if (ifFalse != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1798</TD><TD>            Node endTarget = Node.newTarget();</TD></TR><TR CLASS="c"><TD CLASS="l">1799</TD><TD>            result.addChildToBack(makeJump(Token.GOTO, endTarget));</TD></TR><TR CLASS="c"><TD CLASS="l">1800</TD><TD>            result.addChildToBack(ifNotTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1801</TD><TD>            result.addChildrenToBack(ifFalse);</TD></TR><TR CLASS="c"><TD CLASS="l">1802</TD><TD>            result.addChildToBack(endTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1803</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1804</TD><TD>            result.addChildToBack(ifNotTarget);</TD></TR><TR><TD CLASS="l">1805</TD><TD>        }</TD></TR><TR><TD CLASS="l">1806</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="23">1807</A></TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1808</TD><TD>    }</TD></TR><TR><TD CLASS="l">1809</TD><TD> </TD></TR><TR><TD CLASS="l">1810</TD><TD>    private Node createCondExpr(Node cond, Node ifTrue, Node ifFalse) {</TD></TR><TR CLASS="c"><TD CLASS="l">1811</TD><TD>        int condStatus = isAlwaysDefinedBoolean(cond);</TD></TR><TR CLASS="c"><TD CLASS="l">1812</TD><TD>        if (condStatus == ALWAYS_TRUE_BOOLEAN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1813</TD><TD>            return ifTrue;</TD></TR><TR CLASS="c"><TD CLASS="l">1814</TD><TD>        } else if (condStatus == ALWAYS_FALSE_BOOLEAN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1815</TD><TD>            return ifFalse;</TD></TR><TR><TD CLASS="l">1816</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1817</TD><TD>        return new Node(Token.HOOK, cond, ifTrue, ifFalse);</TD></TR><TR><TD CLASS="l"><A NAME="2a">1818</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1819</TD><TD> </TD></TR><TR><TD CLASS="l">1820</TD><TD>    private Node createUnary(int nodeType, Node child)</TD></TR><TR><TD CLASS="l">1821</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1822</TD><TD>        int childType = child.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">1823</TD><TD>        switch (nodeType) {</TD></TR><TR><TD CLASS="l">1824</TD><TD>          case Token.DELPROP: {</TD></TR><TR><TD CLASS="l">1825</TD><TD>            Node n;</TD></TR><TR CLASS="c"><TD CLASS="l">1826</TD><TD>            if (childType == Token.NAME) {</TD></TR><TR><TD CLASS="l">1827</TD><TD>                // Transform Delete(Name &#34;a&#34;)</TD></TR><TR><TD CLASS="l">1828</TD><TD>                //  to Delete(Bind(&#34;a&#34;), String(&#34;a&#34;))</TD></TR><TR CLASS="c"><TD CLASS="l">1829</TD><TD>                child.setType(Token.BINDNAME);</TD></TR><TR CLASS="c"><TD CLASS="l">1830</TD><TD>                Node left = child;</TD></TR><TR CLASS="c"><TD CLASS="l">1831</TD><TD>                Node right = Node.newString(child.getString());</TD></TR><TR CLASS="c"><TD CLASS="l">1832</TD><TD>                n = new Node(nodeType, left, right);</TD></TR><TR CLASS="c"><TD CLASS="l">1833</TD><TD>            } else if (childType == Token.GETPROP ||</TD></TR><TR><TD CLASS="l">1834</TD><TD>                       childType == Token.GETELEM)</TD></TR><TR><TD CLASS="l">1835</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1836</TD><TD>                Node left = child.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1837</TD><TD>                Node right = child.getLastChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1838</TD><TD>                child.removeChild(left);</TD></TR><TR CLASS="c"><TD CLASS="l">1839</TD><TD>                child.removeChild(right);</TD></TR><TR CLASS="c"><TD CLASS="l">1840</TD><TD>                n = new Node(nodeType, left, right);</TD></TR><TR CLASS="c"><TD CLASS="l">1841</TD><TD>            } else if (childType == Token.GET_REF) {</TD></TR><TR CLASS="c"><TD CLASS="l">1842</TD><TD>                Node ref = child.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">1843</TD><TD>                child.removeChild(ref);</TD></TR><TR CLASS="c"><TD CLASS="l">1844</TD><TD>                n = new Node(Token.DEL_REF, ref);</TD></TR><TR CLASS="c"><TD CLASS="l">1845</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">1846</TD><TD>                // Always evaluate delete operand, see ES5 11.4.1 &amp; bug #726121</TD></TR><TR CLASS="c"><TD CLASS="l">1847</TD><TD>                n = new Node(nodeType, new Node(Token.TRUE), child);</TD></TR><TR><TD CLASS="l">1848</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1849</TD><TD>            return n;</TD></TR><TR><TD CLASS="l">1850</TD><TD>          }</TD></TR><TR><TD CLASS="l">1851</TD><TD>          case Token.TYPEOF:</TD></TR><TR CLASS="c"><TD CLASS="l">1852</TD><TD>            if (childType == Token.NAME) {</TD></TR><TR CLASS="c"><TD CLASS="l">1853</TD><TD>                child.setType(Token.TYPEOFNAME);</TD></TR><TR CLASS="c"><TD CLASS="l">1854</TD><TD>                return child;</TD></TR><TR><TD CLASS="l">1855</TD><TD>            }</TD></TR><TR><TD CLASS="l">1856</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1857</TD><TD>          case Token.BITNOT:</TD></TR><TR CLASS="c"><TD CLASS="l">1858</TD><TD>            if (childType == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">1859</TD><TD>                int value = ScriptRuntime.toInt32(child.getDouble());</TD></TR><TR CLASS="c"><TD CLASS="l">1860</TD><TD>                child.setDouble(~value);</TD></TR><TR CLASS="c"><TD CLASS="l">1861</TD><TD>                return child;</TD></TR><TR><TD CLASS="l">1862</TD><TD>            }</TD></TR><TR><TD CLASS="l">1863</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1864</TD><TD>          case Token.NEG:</TD></TR><TR CLASS="c"><TD CLASS="l">1865</TD><TD>            if (childType == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">1866</TD><TD>                child.setDouble(-child.getDouble());</TD></TR><TR CLASS="c"><TD CLASS="l">1867</TD><TD>                return child;</TD></TR><TR><TD CLASS="l">1868</TD><TD>            }</TD></TR><TR><TD CLASS="l">1869</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1870</TD><TD>          case Token.NOT: {</TD></TR><TR CLASS="c"><TD CLASS="l">1871</TD><TD>            int status = isAlwaysDefinedBoolean(child);</TD></TR><TR CLASS="c"><TD CLASS="l">1872</TD><TD>            if (status != 0) {</TD></TR><TR><TD CLASS="l">1873</TD><TD>                int type;</TD></TR><TR CLASS="c"><TD CLASS="l">1874</TD><TD>                if (status == ALWAYS_TRUE_BOOLEAN) {</TD></TR><TR CLASS="c"><TD CLASS="l">1875</TD><TD>                    type = Token.FALSE;</TD></TR><TR><TD CLASS="l">1876</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1877</TD><TD>                    type = Token.TRUE;</TD></TR><TR><TD CLASS="l">1878</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1879</TD><TD>                if (childType == Token.TRUE || childType == Token.FALSE) {</TD></TR><TR CLASS="c"><TD CLASS="l">1880</TD><TD>                    child.setType(type);</TD></TR><TR CLASS="c"><TD CLASS="l">1881</TD><TD>                    return child;</TD></TR><TR><TD CLASS="l">1882</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1883</TD><TD>                return new Node(type);</TD></TR><TR><TD CLASS="l">1884</TD><TD>            }</TD></TR><TR><TD CLASS="l">1885</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1886</TD><TD>          }</TD></TR><TR><TD CLASS="l">1887</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="1d">1888</A></TD><TD>        return new Node(nodeType, child);</TD></TR><TR><TD CLASS="l">1889</TD><TD>    }</TD></TR><TR><TD CLASS="l">1890</TD><TD> </TD></TR><TR><TD CLASS="l">1891</TD><TD>    private Node createCallOrNew(int nodeType, Node child) {</TD></TR><TR CLASS="c"><TD CLASS="l">1892</TD><TD>        int type = Node.NON_SPECIALCALL;</TD></TR><TR CLASS="c"><TD CLASS="l">1893</TD><TD>        if (child.getType() == Token.NAME) {</TD></TR><TR CLASS="c"><TD CLASS="l">1894</TD><TD>            String name = child.getString();</TD></TR><TR CLASS="c"><TD CLASS="l">1895</TD><TD>            if (name.equals(&#34;eval&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1896</TD><TD>                type = Node.SPECIALCALL_EVAL;</TD></TR><TR CLASS="c"><TD CLASS="l">1897</TD><TD>            } else if (name.equals(&#34;With&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1898</TD><TD>                type = Node.SPECIALCALL_WITH;</TD></TR><TR><TD CLASS="l">1899</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1900</TD><TD>        } else if (child.getType() == Token.GETPROP) {</TD></TR><TR CLASS="c"><TD CLASS="l">1901</TD><TD>            String name = child.getLastChild().getString();</TD></TR><TR CLASS="c"><TD CLASS="l">1902</TD><TD>            if (name.equals(&#34;eval&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1903</TD><TD>                type = Node.SPECIALCALL_EVAL;</TD></TR><TR><TD CLASS="l">1904</TD><TD>            }</TD></TR><TR><TD CLASS="l">1905</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1906</TD><TD>        Node node = new Node(nodeType, child);</TD></TR><TR CLASS="c"><TD CLASS="l">1907</TD><TD>        if (type != Node.NON_SPECIALCALL) {</TD></TR><TR><TD CLASS="l">1908</TD><TD>            // Calls to these functions require activation objects.</TD></TR><TR CLASS="c"><TD CLASS="l">1909</TD><TD>            setRequiresActivation();</TD></TR><TR CLASS="c"><TD CLASS="l">1910</TD><TD>            node.putIntProp(Node.SPECIALCALL_PROP, type);</TD></TR><TR><TD CLASS="l">1911</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1912</TD><TD>        return node;</TD></TR><TR><TD CLASS="l"><A NAME="19">1913</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1914</TD><TD> </TD></TR><TR><TD CLASS="l">1915</TD><TD>    private Node createIncDec(int nodeType, boolean post, Node child)</TD></TR><TR><TD CLASS="l">1916</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1917</TD><TD>        child = makeReference(child);</TD></TR><TR CLASS="c"><TD CLASS="l">1918</TD><TD>        int childType = child.getType();</TD></TR><TR><TD CLASS="l">1919</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1920</TD><TD>        switch (childType) {</TD></TR><TR><TD CLASS="l">1921</TD><TD>          case Token.NAME:</TD></TR><TR><TD CLASS="l">1922</TD><TD>          case Token.GETPROP:</TD></TR><TR><TD CLASS="l">1923</TD><TD>          case Token.GETELEM:</TD></TR><TR><TD CLASS="l">1924</TD><TD>          case Token.GET_REF: {</TD></TR><TR CLASS="c"><TD CLASS="l">1925</TD><TD>            Node n = new Node(nodeType, child);</TD></TR><TR CLASS="c"><TD CLASS="l">1926</TD><TD>            int incrDecrMask = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1927</TD><TD>            if (nodeType == Token.DEC) {</TD></TR><TR CLASS="c"><TD CLASS="l">1928</TD><TD>                incrDecrMask |= Node.DECR_FLAG;</TD></TR><TR><TD CLASS="l">1929</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1930</TD><TD>            if (post) {</TD></TR><TR CLASS="c"><TD CLASS="l">1931</TD><TD>                incrDecrMask |= Node.POST_FLAG;</TD></TR><TR><TD CLASS="l">1932</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1933</TD><TD>            n.putIntProp(Node.INCRDECR_PROP, incrDecrMask);</TD></TR><TR CLASS="c"><TD CLASS="l">1934</TD><TD>            return n;</TD></TR><TR><TD CLASS="l">1935</TD><TD>          }</TD></TR><TR><TD CLASS="l">1936</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1937</TD><TD>        throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">1938</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="14">1939</A></TD><TD> </TD></TR><TR><TD CLASS="l">1940</TD><TD>    private Node createPropertyGet(Node target, String namespace, String name,</TD></TR><TR><TD CLASS="l">1941</TD><TD>                                   int memberTypeFlags)</TD></TR><TR><TD CLASS="l">1942</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1943</TD><TD>        if (namespace == null &amp;&amp; memberTypeFlags == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">1944</TD><TD>            if (target == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1945</TD><TD>                return createName(name);</TD></TR><TR><TD CLASS="l">1946</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1947</TD><TD>            checkActivationName(name, Token.GETPROP);</TD></TR><TR CLASS="c"><TD CLASS="l">1948</TD><TD>            if (ScriptRuntime.isSpecialProperty(name)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1949</TD><TD>                Node ref = new Node(Token.REF_SPECIAL, target);</TD></TR><TR CLASS="c"><TD CLASS="l">1950</TD><TD>                ref.putProp(Node.NAME_PROP, name);</TD></TR><TR CLASS="c"><TD CLASS="l">1951</TD><TD>                return new Node(Token.GET_REF, ref);</TD></TR><TR><TD CLASS="l">1952</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1953</TD><TD>            return new Node(Token.GETPROP, target, Node.newString(name));</TD></TR><TR><TD CLASS="l">1954</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1955</TD><TD>        Node elem = Node.newString(name);</TD></TR><TR CLASS="c"><TD CLASS="l">1956</TD><TD>        memberTypeFlags |= Node.PROPERTY_FLAG;</TD></TR><TR CLASS="c"><TD CLASS="l">1957</TD><TD>        return createMemberRefGet(target, namespace, elem, memberTypeFlags);</TD></TR><TR><TD CLASS="l">1958</TD><TD>    }</TD></TR><TR><TD CLASS="l">1959</TD><TD> </TD></TR><TR><TD CLASS="l">1960</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1961</TD><TD>     * @param target the node before the LB</TD></TR><TR><TD CLASS="l">1962</TD><TD>     * @param namespace optional namespace</TD></TR><TR><TD CLASS="l">1963</TD><TD>     * @param elem the node in the brackets</TD></TR><TR><TD CLASS="l">1964</TD><TD>     * @param memberTypeFlags E4X flags</TD></TR><TR><TD CLASS="l">1965</TD><TD>     */</TD></TR><TR><TD CLASS="l">1966</TD><TD>    private Node createElementGet(Node target, String namespace, Node elem,</TD></TR><TR><TD CLASS="l"><A NAME="6">1967</A></TD><TD>                                  int memberTypeFlags)</TD></TR><TR><TD CLASS="l">1968</TD><TD>    {</TD></TR><TR><TD CLASS="l">1969</TD><TD>        // OPT: could optimize to createPropertyGet</TD></TR><TR><TD CLASS="l">1970</TD><TD>        // iff elem is string that can not be number</TD></TR><TR CLASS="c"><TD CLASS="l">1971</TD><TD>        if (namespace == null &amp;&amp; memberTypeFlags == 0) {</TD></TR><TR><TD CLASS="l">1972</TD><TD>            // stand-alone [aaa] as primary expression is array literal</TD></TR><TR><TD CLASS="l">1973</TD><TD>            // declaration and should not come here!</TD></TR><TR CLASS="z"><TD CLASS="l">1974</TD><TD>            if (target == null) throw Kit.codeBug();</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>            return new Node(Token.GETELEM, target, elem);</TD></TR><TR><TD CLASS="l">1976</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1977</TD><TD>        return createMemberRefGet(target, namespace, elem, memberTypeFlags);</TD></TR><TR><TD CLASS="l">1978</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="27">1979</A></TD><TD> </TD></TR><TR><TD CLASS="l">1980</TD><TD>    private Node createMemberRefGet(Node target, String namespace, Node elem,</TD></TR><TR><TD CLASS="l">1981</TD><TD>                                    int memberTypeFlags)</TD></TR><TR><TD CLASS="l">1982</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1983</TD><TD>        Node nsNode = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1984</TD><TD>        if (namespace != null) {</TD></TR><TR><TD CLASS="l">1985</TD><TD>            // See 11.1.2 in ECMA 357</TD></TR><TR CLASS="c"><TD CLASS="l">1986</TD><TD>            if (namespace.equals(&#34;*&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1987</TD><TD>                nsNode = new Node(Token.NULL);</TD></TR><TR><TD CLASS="l">1988</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1989</TD><TD>                nsNode = createName(namespace);</TD></TR><TR><TD CLASS="l">1990</TD><TD>            }</TD></TR><TR><TD CLASS="l">1991</TD><TD>        }</TD></TR><TR><TD CLASS="l">1992</TD><TD>        Node ref;</TD></TR><TR CLASS="c"><TD CLASS="l">1993</TD><TD>        if (target == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1994</TD><TD>            if (namespace == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1995</TD><TD>                ref = new Node(Token.REF_NAME, elem);</TD></TR><TR><TD CLASS="l">1996</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1997</TD><TD>                ref = new Node(Token.REF_NS_NAME, nsNode, elem);</TD></TR><TR><TD CLASS="l">1998</TD><TD>            }</TD></TR><TR><TD CLASS="l">1999</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2000</TD><TD>            if (namespace == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2001</TD><TD>                ref = new Node(Token.REF_MEMBER, target, elem);</TD></TR><TR><TD CLASS="l">2002</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2003</TD><TD>                ref = new Node(Token.REF_NS_MEMBER, target, nsNode, elem);</TD></TR><TR><TD CLASS="l">2004</TD><TD>            }</TD></TR><TR><TD CLASS="l">2005</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2006</TD><TD>        if (memberTypeFlags != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2007</TD><TD>            ref.putIntProp(Node.MEMBER_TYPE_PROP, memberTypeFlags);</TD></TR><TR><TD CLASS="l">2008</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="15">2009</A></TD><TD>        return new Node(Token.GET_REF, ref);</TD></TR><TR><TD CLASS="l">2010</TD><TD>    }</TD></TR><TR><TD CLASS="l">2011</TD><TD> </TD></TR><TR><TD CLASS="l">2012</TD><TD>    private Node createBinary(int nodeType, Node left, Node right) {</TD></TR><TR CLASS="c"><TD CLASS="l">2013</TD><TD>        switch (nodeType) {</TD></TR><TR><TD CLASS="l">2014</TD><TD> </TD></TR><TR><TD CLASS="l">2015</TD><TD>          case Token.ADD:</TD></TR><TR><TD CLASS="l">2016</TD><TD>            // numerical addition and string concatenation</TD></TR><TR CLASS="c"><TD CLASS="l">2017</TD><TD>            if (left.type == Token.STRING) {</TD></TR><TR><TD CLASS="l">2018</TD><TD>                String s2;</TD></TR><TR CLASS="c"><TD CLASS="l">2019</TD><TD>                if (right.type == Token.STRING) {</TD></TR><TR CLASS="c"><TD CLASS="l">2020</TD><TD>                    s2 = right.getString();</TD></TR><TR CLASS="c"><TD CLASS="l">2021</TD><TD>                } else if (right.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2022</TD><TD>                    s2 = ScriptRuntime.numberToString(right.getDouble(), 10);</TD></TR><TR><TD CLASS="l">2023</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">2024</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2025</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2026</TD><TD>                String s1 = left.getString();</TD></TR><TR CLASS="c"><TD CLASS="l">2027</TD><TD>                left.setString(s1.concat(s2));</TD></TR><TR CLASS="c"><TD CLASS="l">2028</TD><TD>                return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2029</TD><TD>            } else if (left.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2030</TD><TD>                if (right.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2031</TD><TD>                    left.setDouble(left.getDouble() + right.getDouble());</TD></TR><TR CLASS="c"><TD CLASS="l">2032</TD><TD>                    return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2033</TD><TD>                } else if (right.type == Token.STRING) {</TD></TR><TR><TD CLASS="l">2034</TD><TD>                    String s1, s2;</TD></TR><TR CLASS="c"><TD CLASS="l">2035</TD><TD>                    s1 = ScriptRuntime.numberToString(left.getDouble(), 10);</TD></TR><TR CLASS="c"><TD CLASS="l">2036</TD><TD>                    s2 = right.getString();</TD></TR><TR CLASS="c"><TD CLASS="l">2037</TD><TD>                    right.setString(s1.concat(s2));</TD></TR><TR CLASS="c"><TD CLASS="l">2038</TD><TD>                    return right;</TD></TR><TR><TD CLASS="l">2039</TD><TD>                }</TD></TR><TR><TD CLASS="l">2040</TD><TD>            }</TD></TR><TR><TD CLASS="l">2041</TD><TD>            // can't do anything if we don't know  both types - since</TD></TR><TR><TD CLASS="l">2042</TD><TD>            // 0 + object is supposed to call toString on the object and do</TD></TR><TR><TD CLASS="l">2043</TD><TD>            // string concantenation rather than addition</TD></TR><TR><TD CLASS="l">2044</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2045</TD><TD> </TD></TR><TR><TD CLASS="l">2046</TD><TD>          case Token.SUB:</TD></TR><TR><TD CLASS="l">2047</TD><TD>            // numerical subtraction</TD></TR><TR CLASS="c"><TD CLASS="l">2048</TD><TD>            if (left.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2049</TD><TD>                double ld = left.getDouble();</TD></TR><TR CLASS="c"><TD CLASS="l">2050</TD><TD>                if (right.type == Token.NUMBER) {</TD></TR><TR><TD CLASS="l">2051</TD><TD>                    //both numbers</TD></TR><TR CLASS="c"><TD CLASS="l">2052</TD><TD>                    left.setDouble(ld - right.getDouble());</TD></TR><TR CLASS="c"><TD CLASS="l">2053</TD><TD>                    return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2054</TD><TD>                } else if (ld == 0.0) {</TD></TR><TR><TD CLASS="l">2055</TD><TD>                    // first 0: 0-x -&gt; -x</TD></TR><TR CLASS="z"><TD CLASS="l">2056</TD><TD>                    return new Node(Token.NEG, right);</TD></TR><TR><TD CLASS="l">2057</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2058</TD><TD>            } else if (right.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2059</TD><TD>                if (right.getDouble() == 0.0) {</TD></TR><TR><TD CLASS="l">2060</TD><TD>                    //second 0: x - 0 -&gt; +x</TD></TR><TR><TD CLASS="l">2061</TD><TD>                    // can not make simply x because x - 0 must be number</TD></TR><TR CLASS="z"><TD CLASS="l">2062</TD><TD>                    return new Node(Token.POS, left);</TD></TR><TR><TD CLASS="l">2063</TD><TD>                }</TD></TR><TR><TD CLASS="l">2064</TD><TD>            }</TD></TR><TR><TD CLASS="l">2065</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2066</TD><TD> </TD></TR><TR><TD CLASS="l">2067</TD><TD>          case Token.MUL:</TD></TR><TR><TD CLASS="l">2068</TD><TD>            // numerical multiplication</TD></TR><TR CLASS="c"><TD CLASS="l">2069</TD><TD>            if (left.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2070</TD><TD>                double ld = left.getDouble();</TD></TR><TR CLASS="c"><TD CLASS="l">2071</TD><TD>                if (right.type == Token.NUMBER) {</TD></TR><TR><TD CLASS="l">2072</TD><TD>                    //both numbers</TD></TR><TR CLASS="c"><TD CLASS="l">2073</TD><TD>                    left.setDouble(ld * right.getDouble());</TD></TR><TR CLASS="c"><TD CLASS="l">2074</TD><TD>                    return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2075</TD><TD>                } else if (ld == 1.0) {</TD></TR><TR><TD CLASS="l">2076</TD><TD>                    // first 1: 1 *  x -&gt; +x</TD></TR><TR CLASS="c"><TD CLASS="l">2077</TD><TD>                    return new Node(Token.POS, right);</TD></TR><TR><TD CLASS="l">2078</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2079</TD><TD>            } else if (right.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2080</TD><TD>                if (right.getDouble() == 1.0) {</TD></TR><TR><TD CLASS="l">2081</TD><TD>                    //second 1: x * 1 -&gt; +x</TD></TR><TR><TD CLASS="l">2082</TD><TD>                    // can not make simply x because x - 0 must be number</TD></TR><TR CLASS="c"><TD CLASS="l">2083</TD><TD>                    return new Node(Token.POS, left);</TD></TR><TR><TD CLASS="l">2084</TD><TD>                }</TD></TR><TR><TD CLASS="l">2085</TD><TD>            }</TD></TR><TR><TD CLASS="l">2086</TD><TD>            // can't do x*0: Infinity * 0 gives NaN, not 0</TD></TR><TR><TD CLASS="l">2087</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2088</TD><TD> </TD></TR><TR><TD CLASS="l">2089</TD><TD>          case Token.DIV:</TD></TR><TR><TD CLASS="l">2090</TD><TD>            // number division</TD></TR><TR CLASS="c"><TD CLASS="l">2091</TD><TD>            if (right.type == Token.NUMBER) {</TD></TR><TR CLASS="c"><TD CLASS="l">2092</TD><TD>                double rd = right.getDouble();</TD></TR><TR CLASS="c"><TD CLASS="l">2093</TD><TD>                if (left.type == Token.NUMBER) {</TD></TR><TR><TD CLASS="l">2094</TD><TD>                    // both constants -- just divide, trust Java to handle x/0</TD></TR><TR CLASS="c"><TD CLASS="l">2095</TD><TD>                    left.setDouble(left.getDouble() / rd);</TD></TR><TR CLASS="c"><TD CLASS="l">2096</TD><TD>                    return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2097</TD><TD>               } else if (rd == 1.0) {</TD></TR><TR><TD CLASS="l">2098</TD><TD>                    // second 1: x/1 -&gt; +x</TD></TR><TR><TD CLASS="l">2099</TD><TD>                    // not simply x to force number convertion</TD></TR><TR CLASS="c"><TD CLASS="l">2100</TD><TD>                    return new Node(Token.POS, left);</TD></TR><TR><TD CLASS="l">2101</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2102</TD><TD>            }</TD></TR><TR><TD CLASS="l">2103</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2104</TD><TD> </TD></TR><TR><TD CLASS="l">2105</TD><TD>          case Token.AND: {</TD></TR><TR><TD CLASS="l">2106</TD><TD>            // Since x &amp;&amp; y gives x, not false, when Boolean(x) is false,</TD></TR><TR><TD CLASS="l">2107</TD><TD>            // and y, not Boolean(y), when Boolean(x) is true, x &amp;&amp; y</TD></TR><TR><TD CLASS="l">2108</TD><TD>            // can only be simplified if x is defined. See bug 309957.</TD></TR><TR><TD CLASS="l">2109</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2110</TD><TD>            int leftStatus = isAlwaysDefinedBoolean(left);</TD></TR><TR CLASS="c"><TD CLASS="l">2111</TD><TD>            if (leftStatus == ALWAYS_FALSE_BOOLEAN) {</TD></TR><TR><TD CLASS="l">2112</TD><TD>                // if the first one is false, just return it</TD></TR><TR CLASS="z"><TD CLASS="l">2113</TD><TD>                return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2114</TD><TD>            } else if (leftStatus == ALWAYS_TRUE_BOOLEAN) {</TD></TR><TR><TD CLASS="l">2115</TD><TD>                // if first is true, set to second</TD></TR><TR CLASS="c"><TD CLASS="l">2116</TD><TD>                return right;</TD></TR><TR><TD CLASS="l">2117</TD><TD>            }</TD></TR><TR><TD CLASS="l">2118</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2119</TD><TD>          }</TD></TR><TR><TD CLASS="l">2120</TD><TD> </TD></TR><TR><TD CLASS="l">2121</TD><TD>          case Token.OR: {</TD></TR><TR><TD CLASS="l">2122</TD><TD>            // Since x || y gives x, not true, when Boolean(x) is true,</TD></TR><TR><TD CLASS="l">2123</TD><TD>            // and y, not Boolean(y), when Boolean(x) is false, x || y</TD></TR><TR><TD CLASS="l">2124</TD><TD>            // can only be simplified if x is defined. See bug 309957.</TD></TR><TR><TD CLASS="l">2125</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2126</TD><TD>            int leftStatus = isAlwaysDefinedBoolean(left);</TD></TR><TR CLASS="c"><TD CLASS="l">2127</TD><TD>            if (leftStatus == ALWAYS_TRUE_BOOLEAN) {</TD></TR><TR><TD CLASS="l">2128</TD><TD>                // if the first one is true, just return it</TD></TR><TR CLASS="c"><TD CLASS="l">2129</TD><TD>                return left;</TD></TR><TR CLASS="c"><TD CLASS="l">2130</TD><TD>            } else if (leftStatus == ALWAYS_FALSE_BOOLEAN) {</TD></TR><TR><TD CLASS="l">2131</TD><TD>                // if first is false, set to second</TD></TR><TR CLASS="z"><TD CLASS="l">2132</TD><TD>                return right;</TD></TR><TR><TD CLASS="l">2133</TD><TD>            }</TD></TR><TR><TD CLASS="l">2134</TD><TD>            break;</TD></TR><TR><TD CLASS="l">2135</TD><TD>          }</TD></TR><TR><TD CLASS="l">2136</TD><TD>        }</TD></TR><TR><TD CLASS="l">2137</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2138</TD><TD>        return new Node(nodeType, left, right);</TD></TR><TR><TD CLASS="l"><A NAME="a">2139</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2140</TD><TD> </TD></TR><TR><TD CLASS="l">2141</TD><TD>    private Node createAssignment(int assignType, Node left, Node right)</TD></TR><TR><TD CLASS="l">2142</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2143</TD><TD>        Node ref = makeReference(left);</TD></TR><TR CLASS="c"><TD CLASS="l">2144</TD><TD>        if (ref == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2145</TD><TD>            if (left.getType() == Token.ARRAYLIT ||</TD></TR><TR><TD CLASS="l">2146</TD><TD>                left.getType() == Token.OBJECTLIT)</TD></TR><TR><TD CLASS="l">2147</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">2148</TD><TD>                if (assignType != Token.ASSIGN) {</TD></TR><TR CLASS="z"><TD CLASS="l">2149</TD><TD>                    reportError(&#34;msg.bad.destruct.op&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2150</TD><TD>                    return right;</TD></TR><TR><TD CLASS="l">2151</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2152</TD><TD>                return createDestructuringAssignment(-1, left, right);</TD></TR><TR><TD CLASS="l">2153</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2154</TD><TD>            reportError(&#34;msg.bad.assign.left&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2155</TD><TD>            return right;</TD></TR><TR><TD CLASS="l">2156</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2157</TD><TD>        left = ref;</TD></TR><TR><TD CLASS="l">2158</TD><TD> </TD></TR><TR><TD CLASS="l">2159</TD><TD>        int assignOp;</TD></TR><TR CLASS="c"><TD CLASS="l">2160</TD><TD>        switch (assignType) {</TD></TR><TR><TD CLASS="l">2161</TD><TD>          case Token.ASSIGN:</TD></TR><TR CLASS="c"><TD CLASS="l">2162</TD><TD>            return simpleAssignment(left, right);</TD></TR><TR CLASS="c"><TD CLASS="l">2163</TD><TD>          case Token.ASSIGN_BITOR:  assignOp = Token.BITOR;  break;</TD></TR><TR CLASS="c"><TD CLASS="l">2164</TD><TD>          case Token.ASSIGN_BITXOR: assignOp = Token.BITXOR; break;</TD></TR><TR CLASS="c"><TD CLASS="l">2165</TD><TD>          case Token.ASSIGN_BITAND: assignOp = Token.BITAND; break;</TD></TR><TR CLASS="c"><TD CLASS="l">2166</TD><TD>          case Token.ASSIGN_LSH:    assignOp = Token.LSH;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2167</TD><TD>          case Token.ASSIGN_RSH:    assignOp = Token.RSH;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2168</TD><TD>          case Token.ASSIGN_URSH:   assignOp = Token.URSH;   break;</TD></TR><TR CLASS="c"><TD CLASS="l">2169</TD><TD>          case Token.ASSIGN_ADD:    assignOp = Token.ADD;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2170</TD><TD>          case Token.ASSIGN_SUB:    assignOp = Token.SUB;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2171</TD><TD>          case Token.ASSIGN_MUL:    assignOp = Token.MUL;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2172</TD><TD>          case Token.ASSIGN_DIV:    assignOp = Token.DIV;    break;</TD></TR><TR CLASS="c"><TD CLASS="l">2173</TD><TD>          case Token.ASSIGN_MOD:    assignOp = Token.MOD;    break;</TD></TR><TR CLASS="z"><TD CLASS="l">2174</TD><TD>          default: throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">2175</TD><TD>        }</TD></TR><TR><TD CLASS="l">2176</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2177</TD><TD>        int nodeType = left.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">2178</TD><TD>        switch (nodeType) {</TD></TR><TR><TD CLASS="l">2179</TD><TD>          case Token.NAME: {</TD></TR><TR CLASS="c"><TD CLASS="l">2180</TD><TD>            Node op = new Node(assignOp, left, right);</TD></TR><TR CLASS="c"><TD CLASS="l">2181</TD><TD>            Node lvalueLeft = Node.newString(Token.BINDNAME, left.getString());</TD></TR><TR CLASS="c"><TD CLASS="l">2182</TD><TD>            return new Node(Token.SETNAME, lvalueLeft, op);</TD></TR><TR><TD CLASS="l">2183</TD><TD>          }</TD></TR><TR><TD CLASS="l">2184</TD><TD>          case Token.GETPROP:</TD></TR><TR><TD CLASS="l">2185</TD><TD>          case Token.GETELEM: {</TD></TR><TR CLASS="c"><TD CLASS="l">2186</TD><TD>            Node obj = left.getFirstChild();</TD></TR><TR CLASS="c"><TD CLASS="l">2187</TD><TD>            Node id = left.getLastChild();</TD></TR><TR><TD CLASS="l">2188</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2189</TD><TD>            int type = nodeType == Token.GETPROP</TD></TR><TR><TD CLASS="l">2190</TD><TD>                       ? Token.SETPROP_OP</TD></TR><TR><TD CLASS="l">2191</TD><TD>                       : Token.SETELEM_OP;</TD></TR><TR><TD CLASS="l">2192</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2193</TD><TD>            Node opLeft = new Node(Token.USE_STACK);</TD></TR><TR CLASS="c"><TD CLASS="l">2194</TD><TD>            Node op = new Node(assignOp, opLeft, right);</TD></TR><TR CLASS="c"><TD CLASS="l">2195</TD><TD>            return new Node(type, obj, id, op);</TD></TR><TR><TD CLASS="l">2196</TD><TD>          }</TD></TR><TR><TD CLASS="l">2197</TD><TD>          case Token.GET_REF: {</TD></TR><TR CLASS="z"><TD CLASS="l">2198</TD><TD>            ref = left.getFirstChild();</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>            checkMutableReference(ref);</TD></TR><TR CLASS="z"><TD CLASS="l">2200</TD><TD>            Node opLeft = new Node(Token.USE_STACK);</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>            Node op = new Node(assignOp, opLeft, right);</TD></TR><TR CLASS="z"><TD CLASS="l">2202</TD><TD>            return new Node(Token.SET_REF_OP, ref, op);</TD></TR><TR><TD CLASS="l">2203</TD><TD>          }</TD></TR><TR><TD CLASS="l">2204</TD><TD>        }</TD></TR><TR><TD CLASS="l">2205</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="b">2206</A></TD><TD>        throw Kit.codeBug();</TD></TR><TR><TD CLASS="l">2207</TD><TD>    }</TD></TR><TR><TD CLASS="l">2208</TD><TD> </TD></TR><TR><TD CLASS="l">2209</TD><TD>    private Node createUseLocal(Node localBlock) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (4 out of 6 instructions)">2210</TD><TD TITLE="67% line coverage (4 out of 6 instructions)">        if (Token.LOCAL_BLOCK != localBlock.getType()) throw Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">2211</TD><TD>        Node result = new Node(Token.LOCAL_LOAD);</TD></TR><TR CLASS="c"><TD CLASS="l">2212</TD><TD>        result.putProp(Node.LOCAL_BLOCK_PROP, localBlock);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="32">2213</A></TD><TD>        return result;</TD></TR><TR><TD CLASS="l">2214</TD><TD>    }</TD></TR><TR><TD CLASS="l">2215</TD><TD> </TD></TR><TR><TD CLASS="l">2216</TD><TD>    private Jump makeJump(int type, Node target) {</TD></TR><TR CLASS="c"><TD CLASS="l">2217</TD><TD>        Jump n = new Jump(type);</TD></TR><TR CLASS="c"><TD CLASS="l">2218</TD><TD>        n.target = target;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="33">2219</A></TD><TD>        return n;</TD></TR><TR><TD CLASS="l">2220</TD><TD>    }</TD></TR><TR><TD CLASS="l">2221</TD><TD> </TD></TR><TR><TD CLASS="l">2222</TD><TD>    private Node makeReference(Node node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2223</TD><TD>        int type = node.getType();</TD></TR><TR CLASS="c"><TD CLASS="l">2224</TD><TD>        switch (type) {</TD></TR><TR><TD CLASS="l">2225</TD><TD>          case Token.NAME:</TD></TR><TR><TD CLASS="l">2226</TD><TD>          case Token.GETPROP:</TD></TR><TR><TD CLASS="l">2227</TD><TD>          case Token.GETELEM:</TD></TR><TR><TD CLASS="l">2228</TD><TD>          case Token.GET_REF:</TD></TR><TR CLASS="c"><TD CLASS="l">2229</TD><TD>            return node;</TD></TR><TR><TD CLASS="l">2230</TD><TD>          case Token.CALL:</TD></TR><TR CLASS="c"><TD CLASS="l">2231</TD><TD>            node.setType(Token.REF_CALL);</TD></TR><TR CLASS="c"><TD CLASS="l">2232</TD><TD>            return new Node(Token.GET_REF, node);</TD></TR><TR><TD CLASS="l">2233</TD><TD>        }</TD></TR><TR><TD CLASS="l">2234</TD><TD>        // Signal caller to report error</TD></TR><TR CLASS="c"><TD CLASS="l">2235</TD><TD>        return null;</TD></TR><TR><TD CLASS="l"><A NAME="30">2236</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2237</TD><TD> </TD></TR><TR><TD CLASS="l">2238</TD><TD>    // Check if Node always mean true or false in boolean context</TD></TR><TR><TD CLASS="l">2239</TD><TD>    private static int isAlwaysDefinedBoolean(Node node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2240</TD><TD>        switch (node.getType()) {</TD></TR><TR><TD CLASS="l">2241</TD><TD>          case Token.FALSE:</TD></TR><TR><TD CLASS="l">2242</TD><TD>          case Token.NULL:</TD></TR><TR CLASS="c"><TD CLASS="l">2243</TD><TD>            return ALWAYS_FALSE_BOOLEAN;</TD></TR><TR><TD CLASS="l">2244</TD><TD>          case Token.TRUE:</TD></TR><TR CLASS="c"><TD CLASS="l">2245</TD><TD>            return ALWAYS_TRUE_BOOLEAN;</TD></TR><TR><TD CLASS="l">2246</TD><TD>          case Token.NUMBER: {</TD></TR><TR CLASS="c"><TD CLASS="l">2247</TD><TD>            double num = node.getDouble();</TD></TR><TR CLASS="c"><TD CLASS="l">2248</TD><TD>            if (num == num &amp;&amp; num != 0.0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2249</TD><TD>                return ALWAYS_TRUE_BOOLEAN;</TD></TR><TR><TD CLASS="l">2250</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2251</TD><TD>                return ALWAYS_FALSE_BOOLEAN;</TD></TR><TR><TD CLASS="l">2252</TD><TD>            }</TD></TR><TR><TD CLASS="l">2253</TD><TD>          }</TD></TR><TR><TD CLASS="l">2254</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2255</TD><TD>        return 0;</TD></TR><TR><TD CLASS="l"><A NAME="31">2256</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2257</TD><TD> </TD></TR><TR><TD CLASS="l">2258</TD><TD>    // Check if node is the target of a destructuring bind.</TD></TR><TR><TD CLASS="l">2259</TD><TD>    boolean isDestructuring(Node n) {</TD></TR><TR CLASS="c"><TD CLASS="l">2260</TD><TD>        return n instanceof DestructuringForm</TD></TR><TR><TD CLASS="l"><A NAME="10">2261</A></TD><TD>            &amp;&amp; ((DestructuringForm)n).isDestructuring();</TD></TR><TR><TD CLASS="l">2262</TD><TD>    }</TD></TR><TR><TD CLASS="l">2263</TD><TD> </TD></TR><TR><TD CLASS="l">2264</TD><TD>    Node decompileFunctionHeader(FunctionNode fn) {</TD></TR><TR CLASS="c"><TD CLASS="l">2265</TD><TD>        Node mexpr = null;</TD></TR><TR CLASS="c"><TD CLASS="l">2266</TD><TD>        if (fn.getFunctionName() != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2267</TD><TD>            decompiler.addName(fn.getName());</TD></TR><TR CLASS="c"><TD CLASS="l">2268</TD><TD>        } else if (fn.getMemberExprNode() != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2269</TD><TD>            mexpr = transform(fn.getMemberExprNode());</TD></TR><TR><TD CLASS="l">2270</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2271</TD><TD>        decompiler.addToken(Token.LP);</TD></TR><TR CLASS="c"><TD CLASS="l">2272</TD><TD>        List&lt;AstNode&gt; params = fn.getParams();</TD></TR><TR CLASS="c"><TD CLASS="l">2273</TD><TD>        for (int i = 0; i &lt; params.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2274</TD><TD>            decompile(params.get(i));</TD></TR><TR CLASS="c"><TD CLASS="l">2275</TD><TD>            if (i &lt; params.size() - 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">2276</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">2277</TD><TD>            }</TD></TR><TR><TD CLASS="l">2278</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2279</TD><TD>        decompiler.addToken(Token.RP);</TD></TR><TR CLASS="c"><TD CLASS="l">2280</TD><TD>        if (!fn.isExpressionClosure()) {</TD></TR><TR CLASS="c"><TD CLASS="l">2281</TD><TD>            decompiler.addEOL(Token.LC);</TD></TR><TR><TD CLASS="l">2282</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="7">2283</A></TD><TD>        return mexpr;</TD></TR><TR><TD CLASS="l">2284</TD><TD>    }</TD></TR><TR><TD CLASS="l">2285</TD><TD> </TD></TR><TR><TD CLASS="l">2286</TD><TD>    void decompile(AstNode node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2287</TD><TD>        switch (node.getType()) {</TD></TR><TR><TD CLASS="l">2288</TD><TD>          case Token.ARRAYLIT:</TD></TR><TR CLASS="c"><TD CLASS="l">2289</TD><TD>              decompileArrayLiteral((ArrayLiteral)node);</TD></TR><TR CLASS="c"><TD CLASS="l">2290</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2291</TD><TD>          case Token.OBJECTLIT:</TD></TR><TR CLASS="c"><TD CLASS="l">2292</TD><TD>              decompileObjectLiteral((ObjectLiteral)node);</TD></TR><TR CLASS="c"><TD CLASS="l">2293</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2294</TD><TD>          case Token.STRING:</TD></TR><TR CLASS="z"><TD CLASS="l">2295</TD><TD>              decompiler.addString(((StringLiteral)node).getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">2296</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2297</TD><TD>          case Token.NAME:</TD></TR><TR CLASS="c"><TD CLASS="l">2298</TD><TD>              decompiler.addName(((Name)node).getIdentifier());</TD></TR><TR CLASS="c"><TD CLASS="l">2299</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2300</TD><TD>          case Token.NUMBER:</TD></TR><TR CLASS="z"><TD CLASS="l">2301</TD><TD>              decompiler.addNumber(((NumberLiteral)node).getNumber());</TD></TR><TR CLASS="z"><TD CLASS="l">2302</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2303</TD><TD>          case Token.GETPROP:</TD></TR><TR CLASS="c"><TD CLASS="l">2304</TD><TD>              decompilePropertyGet((PropertyGet)node);</TD></TR><TR CLASS="c"><TD CLASS="l">2305</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2306</TD><TD>          case Token.EMPTY:</TD></TR><TR CLASS="c"><TD CLASS="l">2307</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2308</TD><TD>          case Token.GETELEM:</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>              decompileElementGet((ElementGet) node);</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2311</TD><TD>          case Token.THIS:</TD></TR><TR CLASS="c"><TD CLASS="l">2312</TD><TD>              decompiler.addToken(node.getType());</TD></TR><TR CLASS="c"><TD CLASS="l">2313</TD><TD>              break;</TD></TR><TR><TD CLASS="l">2314</TD><TD>          default:</TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>              Kit.codeBug(&#34;unexpected token: &#34;</TD></TR><TR><TD CLASS="l">2316</TD><TD>                          + Token.typeToName(node.getType()));</TD></TR><TR><TD CLASS="l">2317</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2c">2318</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2319</TD><TD> </TD></TR><TR><TD CLASS="l">2320</TD><TD>    // used for destructuring forms, since we don't transform() them</TD></TR><TR><TD CLASS="l">2321</TD><TD>    void decompileArrayLiteral(ArrayLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2322</TD><TD>        decompiler.addToken(Token.LB);</TD></TR><TR CLASS="c"><TD CLASS="l">2323</TD><TD>        List&lt;AstNode&gt; elems = node.getElements();</TD></TR><TR CLASS="c"><TD CLASS="l">2324</TD><TD>        int size = elems.size();</TD></TR><TR CLASS="c"><TD CLASS="l">2325</TD><TD>        for (int i = 0; i &lt; size; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2326</TD><TD>            AstNode elem = elems.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">2327</TD><TD>            decompile(elem);</TD></TR><TR CLASS="c"><TD CLASS="l">2328</TD><TD>            if (i &lt; size - 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">2329</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">2330</TD><TD>            }</TD></TR><TR><TD CLASS="l">2331</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2332</TD><TD>        decompiler.addToken(Token.RB);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2d">2333</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2334</TD><TD> </TD></TR><TR><TD CLASS="l">2335</TD><TD>    // only used for destructuring forms</TD></TR><TR><TD CLASS="l">2336</TD><TD>    void decompileObjectLiteral(ObjectLiteral node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2337</TD><TD>        decompiler.addToken(Token.LC);</TD></TR><TR CLASS="c"><TD CLASS="l">2338</TD><TD>        List&lt;ObjectProperty&gt; props = node.getElements();</TD></TR><TR CLASS="c"><TD CLASS="l">2339</TD><TD>        int size = props.size();</TD></TR><TR CLASS="c"><TD CLASS="l">2340</TD><TD>        for (int i = 0; i &lt; size; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2341</TD><TD>            ObjectProperty prop = props.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">2342</TD><TD>            boolean destructuringShorthand =</TD></TR><TR><TD CLASS="l">2343</TD><TD>                    Boolean.TRUE.equals(prop.getProp(Node.DESTRUCTURING_SHORTHAND));</TD></TR><TR CLASS="c"><TD CLASS="l">2344</TD><TD>            decompile(prop.getLeft());</TD></TR><TR CLASS="c"><TD CLASS="l">2345</TD><TD>            if (!destructuringShorthand) {</TD></TR><TR CLASS="c"><TD CLASS="l">2346</TD><TD>                decompiler.addToken(Token.COLON);</TD></TR><TR CLASS="c"><TD CLASS="l">2347</TD><TD>                decompile(prop.getRight());</TD></TR><TR><TD CLASS="l">2348</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">2349</TD><TD>            if (i &lt; size - 1) {</TD></TR><TR CLASS="c"><TD CLASS="l">2350</TD><TD>                decompiler.addToken(Token.COMMA);</TD></TR><TR><TD CLASS="l">2351</TD><TD>            }</TD></TR><TR><TD CLASS="l">2352</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2353</TD><TD>        decompiler.addToken(Token.RC);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2e">2354</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2355</TD><TD> </TD></TR><TR><TD CLASS="l">2356</TD><TD>    // only used for destructuring forms</TD></TR><TR><TD CLASS="l">2357</TD><TD>    void decompilePropertyGet(PropertyGet node) {</TD></TR><TR CLASS="c"><TD CLASS="l">2358</TD><TD>        decompile(node.getTarget());</TD></TR><TR CLASS="c"><TD CLASS="l">2359</TD><TD>        decompiler.addToken(Token.DOT);</TD></TR><TR CLASS="c"><TD CLASS="l">2360</TD><TD>        decompile(node.getProperty());</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="3">2361</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2362</TD><TD> </TD></TR><TR><TD CLASS="l">2363</TD><TD>    // only used for destructuring forms</TD></TR><TR><TD CLASS="l">2364</TD><TD>    void decompileElementGet(ElementGet node) {</TD></TR><TR CLASS="z"><TD CLASS="l">2365</TD><TD>        decompile(node.getTarget());</TD></TR><TR CLASS="z"><TD CLASS="l">2366</TD><TD>        decompiler.addToken(Token.LB);</TD></TR><TR CLASS="z"><TD CLASS="l">2367</TD><TD>        decompile(node.getElement());</TD></TR><TR CLASS="z"><TD CLASS="l">2368</TD><TD>        decompiler.addToken(Token.RB);</TD></TR><TR CLASS="z"><TD CLASS="l">2369</TD><TD>    }</TD></TR><TR><TD CLASS="l">2370</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>