<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="7.html">org.mozilla.classfile</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">ClassFileWriter.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>ClassFileWriter.java</TD><TD CLASS="h">60%  (6/10)</TD><TD CLASS="h">43%  (89/208)</TD><TD CLASS="h">46%  (3615/7806)</TD><TD CLASS="h">48%  (831.2/1715)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">ClassFileWriter$ClassFileFormatException</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#0">ClassFileWriter$ClassFileFormatException (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#2">ClassFileWriter$StackMapTable</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/2227)</TD><TD CLASS="h">0%   (0/458)</TD></TR><TR><TD CLASS="f"><A HREF="#2">ClassFileWriter$StackMapTable (ClassFileWriter): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">addToWorkList (SuperBlock): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/44)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#5">clearStack (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">computeRawStackMap (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/148)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR><TD CLASS="f"><A HREF="#7">computeWriteSize (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">execute (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/695)</TD><TD CLASS="h">0%   (0/178)</TD></TR><TR><TD CLASS="f"><A HREF="#9">executeALoad (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">executeAStore (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#b">executeBlock (SuperBlock): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/219)</TD><TD CLASS="h">0%   (0/39)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">executeStore (int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#d">executeWorkList (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">flowInto (SuperBlock): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#f">generate (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getBranchTarget (int): SuperBlock</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getLocal (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getOperand (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getOperand (int, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getSuperBlockDependencies (): SuperBlock []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/86)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getSuperBlockFromOffset (int): SuperBlock</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getWorstCaseWriteSize (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">initializeTypeInfo (int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">initializeTypeInfo (int, int, int [], int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#19">isBranch (int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">isSuperBlockEnd (int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">killSuperBlock (SuperBlock): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/165)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">pop (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">pop2 (): long</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">push (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">push2 (long): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">setLocal (int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#21">verify (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">write (byte [], int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#23">writeAppendFrame (int [], int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">writeChopFrame (int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#25">writeFullFrame (int [], int [], int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">writeSameFrame (int [], int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#27">writeSameLocalsOneStackItemFrame (int [], int [], int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/44)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">writeType (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#29">writeTypes (int []): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">writeTypes (int [], int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#2b">SuperBlock</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/267)</TD><TD CLASS="h">0%   (0/58)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">SuperBlock (int, int, int, int []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2d">getEnd (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2e">getIndex (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2f">getLocals (): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#30">getStack (): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#31">getStart (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#32">getTrimmedLocals (): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/69)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#33">isInQueue (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#34">isInitialized (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#35">merge (int [], int, int [], int, ConstantPool): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/65)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#36">mergeState (int [], int [], int, ConstantPool): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#37">setInQueue (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#38">setInitialized (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#39">toString (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#3a">TypeInfo</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/350)</TD><TD CLASS="h">0%   (0/87)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">OBJECT (String, ConstantPool): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">OBJECT (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3a">TypeInfo (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">UNINITIALIZED_VARIABLE (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">fromType (String, ConstantPool): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">getClassFromInternalName (String): Class</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#41">getPayload (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">getPayloadAsType (int, ConstantPool): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#43">getTag (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">isTwoWords (int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#45">merge (int, int, ConstantPool): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/148)</TD><TD CLASS="h">0%   (0/35)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">print (int [], int [], ConstantPool): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#47">print (int [], int, int [], int, ConstantPool): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">toString (int [], ConstantPool): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#49">toString (int [], int, ConstantPool): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">toString (int, ConstantPool): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#4b">ClassFileField</A></TD><TD>100% (1/1)</TD><TD>75%  (3/4)</TD><TD CLASS="h">54%  (53/99)</TD><TD CLASS="h">57%  (16/28)</TD></TR><TR><TD CLASS="f"><A HREF="#4c">setAttributes (short, short, short, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4d">write (byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">50%  (29/58)</TD><TD CLASS="h">55%  (6/11)</TD></TR><TR><TD CLASS="f"><A HREF="#4e">getWriteSize (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (9/10)</TD><TD>80%  (4/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4b">ClassFileField (short, short, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#50">ClassFileWriter</A></TD><TD>100% (1/1)</TD><TD CLASS="h">64%  (63/99)</TD><TD CLASS="h">69%  (2545/3695)</TD><TD CLASS="h">72%  (615.6/852)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$000 (ClassFileWriter): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$100 (ClassFileWriter): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$1000 (String): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$1100 (ClassFileWriter): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$1200 (String): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$1300 (ClassFileWriter): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$1400 (ClassFileWriter): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$200 (ClassFileWriter): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$300 (ClassFileWriter): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$400 (ClassFileWriter): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$410 (ClassFileWriter): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$500 (ClassFileWriter): ExceptionTableEntry []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$600 (ClassFileWriter): UintMap</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$700 (ClassFileWriter): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#50">access$800 (ClassFileWriter): ConstantPool</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">access$900 (int): char</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#61">add (int, int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/123)</TD><TD CLASS="h">0%   (0/27)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">addFStore (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#63">addField (String, String, short, double): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#64">addField (String, String, short, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#65">addField (String, String, short, long): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#66">addLLoad (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#67">addLStore (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#68">addLoadConstant (float): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#69">addLoadConstant (long): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6a">arrayTypeToName (int): char</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#6b">badStack (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6c">bytecodeStr (int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6d">classDescriptorToInternalName (String): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6e">createInitialLocals (): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/124)</TD><TD CLASS="h">0%   (0/34)</TD></TR><TR><TD CLASS="f"><A HREF="#6f">descriptorToInternalName (String): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#70">finalizeSuperBlockStarts (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/83)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#71">isUnderStringSizeLimit (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#72">opcodeLength (int, boolean): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#73">setFlags (short): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#74">write (OutputStream): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#75">addSuperBlockStart (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">7%   (3/45)</TD><TD CLASS="h">22%  (2/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#76">opcodeCount (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">18%  (4/22)</TD><TD CLASS="h">33%  (2/6)</TD></TR><TR><TD CLASS="f"><A HREF="#77">stackChange (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">50%  (14/28)</TD><TD CLASS="h">78%  (7/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#78">setTableSwitchJump (int, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">55%  (76/138)</TD><TD CLASS="h">69%  (11/16)</TD></TR><TR><TD CLASS="f"><A HREF="#79">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">60%  (74/124)</TD><TD CLASS="h">71%  (16.4/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7a">getLabelPC (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">60%  (15/25)</TD><TD CLASS="h">67%  (4/6)</TD></TR><TR><TD CLASS="f"><A HREF="#7b">markLabel (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">61%  (23/38)</TD><TD CLASS="h">67%  (6/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7c">markTableSwitchCase (int, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">70%  (28/40)</TD><TD>86%  (6/7)</TD></TR><TR><TD CLASS="f"><A HREF="#7d">add (int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">70%  (179/255)</TD><TD CLASS="h">73%  (49.8/68)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7e">adjustStackTop (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">76%  (19/25)</TD><TD>90%  (4.5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#7f">sizeOfParameters (String): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">77%  (98/128)</TD><TD CLASS="h">76%  (35/46)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#80">addTableSwitch (int, int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">78%  (80/102)</TD><TD>93%  (16.7/18)</TD></TR><TR><TD CLASS="f"><A HREF="#81">addExceptionHandler (int, int, int, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>83%  (73/88)</TD><TD>83%  (15/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#82">add (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>84%  (37/44)</TD><TD>88%  (8.8/10)</TD></TR><TR><TD CLASS="f"><A HREF="#83">addPush (long): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>84%  (16/19)</TD><TD>83%  (5/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#84">add (int, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>84%  (38/45)</TD><TD>89%  (9.8/11)</TD></TR><TR><TD CLASS="f"><A HREF="#85">addLabelFixup (int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>86%  (63/73)</TD><TD>87%  (13/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#86">stopMethod (short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>87%  (397/458)</TD><TD>85%  (92/108)</TD></TR><TR><TD CLASS="f"><A HREF="#87">add (int, String, String, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>87%  (61/70)</TD><TD>91%  (14.6/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#88">fixLabelGotos (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>89%  (70/79)</TD><TD>88%  (15/17)</TD></TR><TR><TD CLASS="f"><A HREF="#89">addReservedCodeSpace (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (44/49)</TD><TD>92%  (11/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8a">addLineNumberEntry (short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (49/54)</TD><TD>92%  (11/12)</TD></TR><TR><TD CLASS="f"><A HREF="#8b">addInvoke (int, String, String, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>92%  (76/83)</TD><TD>95%  (19.9/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8c">toByteArray (): byte []</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>98%  (175/179)</TD><TD>97%  (33/34)</TD></TR><TR><TD CLASS="f"><A HREF="#8d">ClassFileWriter (String, String, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (67/67)</TD><TD>100% (17/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8e">acquireLabel (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (50/50)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#8f">addALoad (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#90">addAStore (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#91">addDLoad (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#92">addDStore (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#93">addFLoad (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#94">addField (String, String, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (20/20)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="f"><A HREF="#95">addILoad (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#96">addIStore (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#97">addInterface (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#98">addLoadConstant (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#99">addLoadConstant (double): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9a">addLoadConstant (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (34/34)</TD><TD>100% (9/9)</TD></TR><TR><TD CLASS="f"><A HREF="#9b">addLoadThis (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9c">addPush (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (78/78)</TD><TD>100% (23/23)</TD></TR><TR><TD CLASS="f"><A HREF="#9d">addPush (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9e">addPush (double): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (40/40)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#9f">addPush (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (44/44)</TD><TD>100% (10/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a0">addToCodeBuffer (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#a1">addToCodeInt16 (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a2">addVariableDescriptor (String, String, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (42/42)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="f"><A HREF="#a3">classNameToSignature (String): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (51/51)</TD><TD>100% (10/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a4">getCharBuffer (int): char []</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (23/23)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#a5">getClassName (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a6">getCurrentCodeOffset (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#a7">getSlashedForm (String): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a8">getStackTop (): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#a9">getWriteSize (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (80/80)</TD><TD>100% (23/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#aa">markHandler (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#ab">markLabel (int, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ac">markTableSwitchCase (int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (17/17)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="f"><A HREF="#ad">markTableSwitchDefault (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (17/17)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ae">putInt16 (int, byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (20/20)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#af">putInt32 (int, byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (38/38)</TD><TD>100% (5/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b0">putInt64 (long, byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (14/14)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#b1">setStackTop (short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b2">startMethod (String, String, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (34/34)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="f"><A HREF="#b3">xop (int, int, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (29/29)</TD><TD>100% (11/11)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#b4">FieldOrMethodRef</A></TD><TD>100% (1/1)</TD><TD CLASS="h">50%  (3/6)</TD><TD>85%  (68/80)</TD><TD>81%  (14.6/18)</TD></TR><TR><TD CLASS="f"><A HREF="#b5">getClassName (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b6">getName (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#b7">getType (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b8">equals (Object): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (27/30)</TD><TD>85%  (2.6/3)</TD></TR><TR><TD CLASS="f"><A HREF="#b4">FieldOrMethodRef (String, String, String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#ba">hashCode (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (26/26)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#bb">ConstantPool</A></TD><TD>100% (1/1)</TD><TD>75%  (15/20)</TD><TD>87%  (866/992)</TD><TD>87%  (162/186)</TD></TR><TR><TD CLASS="f"><A HREF="#bc">addConstant (float): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#bd">addConstant (long): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/38)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#be">getConstantData (int): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#bf">getConstantType (int): byte</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#c0">isUnderUtfEncodingLimit (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c1">addUtf8 (String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (192/203)</TD><TD>91%  (32/35)</TD></TR><TR><TD CLASS="f"><A HREF="#bb">ConstantPool (ClassFileWriter): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (51/51)</TD><TD>100% (13/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c3">addClass (String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (94/94)</TD><TD>100% (20/20)</TD></TR><TR><TD CLASS="f"><A HREF="#c4">addConstant (String): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (57/57)</TD><TD>100% (10/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c5">addConstant (double): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (41/41)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#c6">addConstant (int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (37/37)</TD><TD>100% (5/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c7">addFieldRef (String, String, String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (80/80)</TD><TD>100% (14/14)</TD></TR><TR><TD CLASS="f"><A HREF="#c8">addInterfaceMethodRef (String, String, String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (66/66)</TD><TD>100% (10/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c9">addMethodRef (String, String, String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (80/80)</TD><TD>100% (14/14)</TD></TR><TR><TD CLASS="f"><A HREF="#ca">addNameAndType (String, String): short</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (53/53)</TD><TD>100% (8/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#cb">ensure (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (40/40)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#cc">getUtfEncodingLimit (String, int, int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (42/42)</TD><TD>100% (13/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#cd">getWriteSize (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#ce">setConstantData (int, Object): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#cf">write (byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (22/22)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#d0">ClassFileMethod</A></TD><TD>100% (1/1)</TD><TD CLASS="h">57%  (4/7)</TD><TD>88%  (68/77)</TD><TD>85%  (17/20)</TD></TR><TR><TD CLASS="f"><A HREF="#d1">getFlags (): short</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d2">getName (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#d3">getType (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d0">ClassFileMethod (String, short, String, short, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (18/18)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="f"><A HREF="#d5">getWriteSize (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d6">setCodeAttribute (byte []): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#d7">write (byte [], int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (40/40)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#d8">ExceptionTableEntry</A></TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#d8">ExceptionTableEntry (int, int, int, short): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</TD></TR><TR><TD CLASS="l">2</TD><TD> *</TD></TR><TR><TD CLASS="l">3</TD><TD> * This Source Code Form is subject to the terms of the Mozilla Public</TD></TR><TR><TD CLASS="l">4</TD><TD> * License, v. 2.0. If a copy of the MPL was not distributed with this</TD></TR><TR><TD CLASS="l">5</TD><TD> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</TD></TR><TR><TD CLASS="l">6</TD><TD> </TD></TR><TR><TD CLASS="l">7</TD><TD>package org.mozilla.classfile;</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>import org.mozilla.javascript.ObjToIntMap;</TD></TR><TR><TD CLASS="l">10</TD><TD>import org.mozilla.javascript.ObjArray;</TD></TR><TR><TD CLASS="l">11</TD><TD>import org.mozilla.javascript.UintMap;</TD></TR><TR><TD CLASS="l">12</TD><TD> </TD></TR><TR><TD CLASS="l">13</TD><TD>import java.io.*;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">15</TD><TD> </TD></TR><TR><TD CLASS="l">16</TD><TD>/**</TD></TR><TR><TD CLASS="l">17</TD><TD> * ClassFileWriter</TD></TR><TR><TD CLASS="l">18</TD><TD> *</TD></TR><TR><TD CLASS="l">19</TD><TD> * A ClassFileWriter is used to write a Java class file. Methods are</TD></TR><TR><TD CLASS="l">20</TD><TD> * provided to create fields and methods, and within methods to write</TD></TR><TR><TD CLASS="l"><A NAME="50">21</A></TD><TD> * Java bytecodes.</TD></TR><TR><TD CLASS="l">22</TD><TD> *</TD></TR><TR><TD CLASS="l">23</TD><TD> * @author Roger Lawrence</TD></TR><TR><TD CLASS="l">24</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">25</TD><TD>public class ClassFileWriter {</TD></TR><TR><TD CLASS="l">26</TD><TD> </TD></TR><TR><TD CLASS="l">27</TD><TD>    /**</TD></TR><TR><TD CLASS="l">28</TD><TD>     * Thrown for cases where the error in generating the class file is</TD></TR><TR><TD CLASS="l">29</TD><TD>     * due to a program size constraints rather than a likely bug in the</TD></TR><TR><TD CLASS="l">30</TD><TD>     * compiler.</TD></TR><TR><TD CLASS="l">31</TD><TD>     */</TD></TR><TR><TD CLASS="l">32</TD><TD>    public static class ClassFileFormatException extends RuntimeException {</TD></TR><TR><TD CLASS="l"><A NAME="0">33</A></TD><TD> </TD></TR><TR><TD CLASS="l">34</TD><TD>        private static final long serialVersionUID = 1263998431033790599L;</TD></TR><TR><TD CLASS="l">35</TD><TD> </TD></TR><TR><TD CLASS="l">36</TD><TD>        ClassFileFormatException(String message) {</TD></TR><TR CLASS="z"><TD CLASS="l">37</TD><TD>            super(message);</TD></TR><TR CLASS="z"><TD CLASS="l">38</TD><TD>        }</TD></TR><TR><TD CLASS="l">39</TD><TD>    }</TD></TR><TR><TD CLASS="l">40</TD><TD> </TD></TR><TR><TD CLASS="l">41</TD><TD>    /**</TD></TR><TR><TD CLASS="l">42</TD><TD>     * Construct a ClassFileWriter for a class.</TD></TR><TR><TD CLASS="l">43</TD><TD>     *</TD></TR><TR><TD CLASS="l">44</TD><TD>     * @param className the name of the class to write, including</TD></TR><TR><TD CLASS="l">45</TD><TD>     *        full package qualification.</TD></TR><TR><TD CLASS="l">46</TD><TD>     * @param superClassName the name of the superclass of the class</TD></TR><TR><TD CLASS="l">47</TD><TD>     *        to write, including full package qualification.</TD></TR><TR><TD CLASS="l">48</TD><TD>     * @param sourceFileName the name of the source file to use for</TD></TR><TR><TD CLASS="l">49</TD><TD>     *        producing debug information, or null if debug information</TD></TR><TR><TD CLASS="l"><A NAME="8d">50</A></TD><TD>     *        is not desired</TD></TR><TR><TD CLASS="l">51</TD><TD>     */</TD></TR><TR><TD CLASS="l">52</TD><TD>    public ClassFileWriter(String className, String superClassName,</TD></TR><TR><TD CLASS="l">53</TD><TD>                           String sourceFileName)</TD></TR><TR CLASS="c"><TD CLASS="l">54</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">55</TD><TD>        generatedClassName = className;</TD></TR><TR CLASS="c"><TD CLASS="l">56</TD><TD>        itsConstantPool = new ConstantPool(this);</TD></TR><TR CLASS="c"><TD CLASS="l">57</TD><TD>        itsThisClassIndex = itsConstantPool.addClass(className);</TD></TR><TR CLASS="c"><TD CLASS="l">58</TD><TD>        itsSuperClassIndex = itsConstantPool.addClass(superClassName);</TD></TR><TR CLASS="c"><TD CLASS="l">59</TD><TD>        if (sourceFileName != null)</TD></TR><TR CLASS="c"><TD CLASS="l">60</TD><TD>            itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);</TD></TR><TR><TD CLASS="l">61</TD><TD>        // All &#34;new&#34; implementations are supposed to output ACC_SUPER as a</TD></TR><TR><TD CLASS="l">62</TD><TD>        // class flag. This is specified in the first JVM spec, so it should</TD></TR><TR><TD CLASS="l">63</TD><TD>        // be old enough that it's okay to always set it.</TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>        itsFlags = ACC_PUBLIC | ACC_SUPER;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="a5">65</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">66</TD><TD> </TD></TR><TR><TD CLASS="l">67</TD><TD>    public final String getClassName()</TD></TR><TR><TD CLASS="l">68</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">69</TD><TD>        return generatedClassName;</TD></TR><TR><TD CLASS="l">70</TD><TD>    }</TD></TR><TR><TD CLASS="l">71</TD><TD> </TD></TR><TR><TD CLASS="l">72</TD><TD>    /**</TD></TR><TR><TD CLASS="l">73</TD><TD>     * Add an interface implemented by this class.</TD></TR><TR><TD CLASS="l">74</TD><TD>     *</TD></TR><TR><TD CLASS="l">75</TD><TD>     * This method may be called multiple times for classes that</TD></TR><TR><TD CLASS="l">76</TD><TD>     * implement multiple interfaces.</TD></TR><TR><TD CLASS="l">77</TD><TD>     *</TD></TR><TR><TD CLASS="l">78</TD><TD>     * @param interfaceName a name of an interface implemented</TD></TR><TR><TD CLASS="l"><A NAME="97">79</A></TD><TD>     *        by the class being written, including full package</TD></TR><TR><TD CLASS="l">80</TD><TD>     *        qualification.</TD></TR><TR><TD CLASS="l">81</TD><TD>     */</TD></TR><TR><TD CLASS="l">82</TD><TD>    public void addInterface(String interfaceName) {</TD></TR><TR CLASS="c"><TD CLASS="l">83</TD><TD>        short interfaceIndex = itsConstantPool.addClass(interfaceName);</TD></TR><TR CLASS="c"><TD CLASS="l">84</TD><TD>        itsInterfaces.add(Short.valueOf(interfaceIndex));</TD></TR><TR CLASS="c"><TD CLASS="l">85</TD><TD>    }</TD></TR><TR><TD CLASS="l">86</TD><TD> </TD></TR><TR><TD CLASS="l">87</TD><TD>    public static final short</TD></TR><TR><TD CLASS="l">88</TD><TD>        ACC_PUBLIC = 0x0001,</TD></TR><TR><TD CLASS="l">89</TD><TD>        ACC_PRIVATE = 0x0002,</TD></TR><TR><TD CLASS="l">90</TD><TD>        ACC_PROTECTED = 0x0004,</TD></TR><TR><TD CLASS="l">91</TD><TD>        ACC_STATIC = 0x0008,</TD></TR><TR><TD CLASS="l">92</TD><TD>        ACC_FINAL = 0x0010,</TD></TR><TR><TD CLASS="l">93</TD><TD>        ACC_SUPER = 0x0020,</TD></TR><TR><TD CLASS="l">94</TD><TD>        ACC_SYNCHRONIZED = 0x0020,</TD></TR><TR><TD CLASS="l">95</TD><TD>        ACC_VOLATILE = 0x0040,</TD></TR><TR><TD CLASS="l">96</TD><TD>        ACC_TRANSIENT = 0x0080,</TD></TR><TR><TD CLASS="l">97</TD><TD>        ACC_NATIVE = 0x0100,</TD></TR><TR><TD CLASS="l">98</TD><TD>        ACC_ABSTRACT = 0x0400;</TD></TR><TR><TD CLASS="l">99</TD><TD> </TD></TR><TR><TD CLASS="l">100</TD><TD>    /**</TD></TR><TR><TD CLASS="l">101</TD><TD>     * Set the class's flags.</TD></TR><TR><TD CLASS="l">102</TD><TD>     *</TD></TR><TR><TD CLASS="l">103</TD><TD>     * Flags must be a set of the following flags, bitwise or'd</TD></TR><TR><TD CLASS="l">104</TD><TD>     * together:</TD></TR><TR><TD CLASS="l">105</TD><TD>     *      ACC_PUBLIC</TD></TR><TR><TD CLASS="l">106</TD><TD>     *      ACC_PRIVATE</TD></TR><TR><TD CLASS="l">107</TD><TD>     *      ACC_PROTECTED</TD></TR><TR><TD CLASS="l">108</TD><TD>     *      ACC_FINAL</TD></TR><TR><TD CLASS="l">109</TD><TD>     *      ACC_ABSTRACT</TD></TR><TR><TD CLASS="l"><A NAME="73">110</A></TD><TD>     * TODO: check that this is the appropriate set</TD></TR><TR><TD CLASS="l">111</TD><TD>     * @param flags the set of class flags to set</TD></TR><TR><TD CLASS="l">112</TD><TD>     */</TD></TR><TR><TD CLASS="l">113</TD><TD>    public void setFlags(short flags) {</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>        itsFlags = flags;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a7">115</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">116</TD><TD> </TD></TR><TR><TD CLASS="l">117</TD><TD>    static String getSlashedForm(String name)</TD></TR><TR><TD CLASS="l">118</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">119</TD><TD>        return name.replace('.', '/');</TD></TR><TR><TD CLASS="l">120</TD><TD>    }</TD></TR><TR><TD CLASS="l">121</TD><TD> </TD></TR><TR><TD CLASS="l">122</TD><TD>    /**</TD></TR><TR><TD CLASS="l">123</TD><TD>     * Convert Java class name in dot notation into</TD></TR><TR><TD CLASS="l">124</TD><TD>     * &#34;Lname-with-dots-replaced-by-slashes;&#34; form suitable for use as</TD></TR><TR><TD CLASS="l"><A NAME="a3">125</A></TD><TD>     * JVM type signatures.</TD></TR><TR><TD CLASS="l">126</TD><TD>     */</TD></TR><TR><TD CLASS="l">127</TD><TD>    public static String classNameToSignature(String name)</TD></TR><TR><TD CLASS="l">128</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">129</TD><TD>        int nameLength = name.length();</TD></TR><TR CLASS="c"><TD CLASS="l">130</TD><TD>        int colonPos = 1 + nameLength;</TD></TR><TR CLASS="c"><TD CLASS="l">131</TD><TD>        char[] buf = new char[colonPos + 1];</TD></TR><TR CLASS="c"><TD CLASS="l">132</TD><TD>        buf[0] = 'L';</TD></TR><TR CLASS="c"><TD CLASS="l">133</TD><TD>        buf[colonPos] = ';';</TD></TR><TR CLASS="c"><TD CLASS="l">134</TD><TD>        name.getChars(0, nameLength, buf, 1);</TD></TR><TR CLASS="c"><TD CLASS="l">135</TD><TD>        for (int i = 1; i != colonPos; ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">136</TD><TD>            if (buf[i] == '.') {</TD></TR><TR CLASS="c"><TD CLASS="l">137</TD><TD>                buf[i] = '/';</TD></TR><TR><TD CLASS="l">138</TD><TD>            }</TD></TR><TR><TD CLASS="l">139</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">140</TD><TD>        return new String(buf, 0, colonPos + 1);</TD></TR><TR><TD CLASS="l">141</TD><TD>    }</TD></TR><TR><TD CLASS="l">142</TD><TD> </TD></TR><TR><TD CLASS="l">143</TD><TD>    /**</TD></TR><TR><TD CLASS="l">144</TD><TD>     * Add a field to the class.</TD></TR><TR><TD CLASS="l">145</TD><TD>     *</TD></TR><TR><TD CLASS="l">146</TD><TD>     * @param fieldName the name of the field</TD></TR><TR><TD CLASS="l">147</TD><TD>     * @param type the type of the field using ...</TD></TR><TR><TD CLASS="l"><A NAME="94">148</A></TD><TD>     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.</TD></TR><TR><TD CLASS="l">149</TD><TD>     *        bitwise or'd together</TD></TR><TR><TD CLASS="l">150</TD><TD>     */</TD></TR><TR><TD CLASS="l">151</TD><TD>    public void addField(String fieldName, String type, short flags) {</TD></TR><TR CLASS="c"><TD CLASS="l">152</TD><TD>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</TD></TR><TR CLASS="c"><TD CLASS="l">153</TD><TD>        short typeIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="c"><TD CLASS="l">154</TD><TD>        itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));</TD></TR><TR CLASS="c"><TD CLASS="l">155</TD><TD>    }</TD></TR><TR><TD CLASS="l">156</TD><TD> </TD></TR><TR><TD CLASS="l">157</TD><TD>    /**</TD></TR><TR><TD CLASS="l">158</TD><TD>     * Add a field to the class.</TD></TR><TR><TD CLASS="l">159</TD><TD>     *</TD></TR><TR><TD CLASS="l">160</TD><TD>     * @param fieldName the name of the field</TD></TR><TR><TD CLASS="l">161</TD><TD>     * @param type the type of the field using ...</TD></TR><TR><TD CLASS="l">162</TD><TD>     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.</TD></TR><TR><TD CLASS="l">163</TD><TD>     *        bitwise or'd together</TD></TR><TR><TD CLASS="l">164</TD><TD>     * @param value an initial integral value</TD></TR><TR><TD CLASS="l"><A NAME="64">165</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">166</TD><TD>    public void addField(String fieldName, String type, short flags,</TD></TR><TR><TD CLASS="l">167</TD><TD>                         int value)</TD></TR><TR><TD CLASS="l">168</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</TD></TR><TR CLASS="z"><TD CLASS="l">170</TD><TD>        short typeIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="z"><TD CLASS="l">171</TD><TD>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</TD></TR><TR><TD CLASS="l">172</TD><TD>                                                  flags);</TD></TR><TR CLASS="z"><TD CLASS="l">173</TD><TD>        field.setAttributes(itsConstantPool.addUtf8(&#34;ConstantValue&#34;),</TD></TR><TR><TD CLASS="l">174</TD><TD>                            (short)0,</TD></TR><TR><TD CLASS="l">175</TD><TD>                            (short)0,</TD></TR><TR><TD CLASS="l">176</TD><TD>                            itsConstantPool.addConstant(value));</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>        itsFields.add(field);</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>    }</TD></TR><TR><TD CLASS="l">179</TD><TD> </TD></TR><TR><TD CLASS="l">180</TD><TD>    /**</TD></TR><TR><TD CLASS="l">181</TD><TD>     * Add a field to the class.</TD></TR><TR><TD CLASS="l">182</TD><TD>     *</TD></TR><TR><TD CLASS="l">183</TD><TD>     * @param fieldName the name of the field</TD></TR><TR><TD CLASS="l">184</TD><TD>     * @param type the type of the field using ...</TD></TR><TR><TD CLASS="l">185</TD><TD>     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.</TD></TR><TR><TD CLASS="l">186</TD><TD>     *        bitwise or'd together</TD></TR><TR><TD CLASS="l">187</TD><TD>     * @param value an initial long value</TD></TR><TR><TD CLASS="l"><A NAME="65">188</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">189</TD><TD>    public void addField(String fieldName, String type, short flags,</TD></TR><TR><TD CLASS="l">190</TD><TD>                         long value)</TD></TR><TR><TD CLASS="l">191</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">192</TD><TD>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</TD></TR><TR CLASS="z"><TD CLASS="l">193</TD><TD>        short typeIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</TD></TR><TR><TD CLASS="l">195</TD><TD>                                                  flags);</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>        field.setAttributes(itsConstantPool.addUtf8(&#34;ConstantValue&#34;),</TD></TR><TR><TD CLASS="l">197</TD><TD>                            (short)0,</TD></TR><TR><TD CLASS="l">198</TD><TD>                            (short)2,</TD></TR><TR><TD CLASS="l">199</TD><TD>                            itsConstantPool.addConstant(value));</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>        itsFields.add(field);</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>    }</TD></TR><TR><TD CLASS="l">202</TD><TD> </TD></TR><TR><TD CLASS="l">203</TD><TD>    /**</TD></TR><TR><TD CLASS="l">204</TD><TD>     * Add a field to the class.</TD></TR><TR><TD CLASS="l">205</TD><TD>     *</TD></TR><TR><TD CLASS="l">206</TD><TD>     * @param fieldName the name of the field</TD></TR><TR><TD CLASS="l">207</TD><TD>     * @param type the type of the field using ...</TD></TR><TR><TD CLASS="l">208</TD><TD>     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.</TD></TR><TR><TD CLASS="l">209</TD><TD>     *        bitwise or'd together</TD></TR><TR><TD CLASS="l">210</TD><TD>     * @param value an initial double value</TD></TR><TR><TD CLASS="l"><A NAME="63">211</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">212</TD><TD>    public void addField(String fieldName, String type, short flags,</TD></TR><TR><TD CLASS="l">213</TD><TD>                         double value)</TD></TR><TR><TD CLASS="l">214</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>        short typeIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,</TD></TR><TR><TD CLASS="l">218</TD><TD>                                                  flags);</TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>        field.setAttributes(itsConstantPool.addUtf8(&#34;ConstantValue&#34;),</TD></TR><TR><TD CLASS="l">220</TD><TD>                            (short)0,</TD></TR><TR><TD CLASS="l">221</TD><TD>                            (short)2,</TD></TR><TR><TD CLASS="l">222</TD><TD>                            itsConstantPool.addConstant(value));</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>        itsFields.add(field);</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>    }</TD></TR><TR><TD CLASS="l">225</TD><TD> </TD></TR><TR><TD CLASS="l">226</TD><TD>    /**</TD></TR><TR><TD CLASS="l">227</TD><TD>     * Add Information about java variable to use when generating the local</TD></TR><TR><TD CLASS="l">228</TD><TD>     * variable table.</TD></TR><TR><TD CLASS="l">229</TD><TD>     *</TD></TR><TR><TD CLASS="l">230</TD><TD>     * @param name variable name.</TD></TR><TR><TD CLASS="l">231</TD><TD>     * @param type variable type as bytecode descriptor string.</TD></TR><TR><TD CLASS="l">232</TD><TD>     * @param startPC the starting bytecode PC where this variable is live,</TD></TR><TR><TD CLASS="l">233</TD><TD>     *                 or -1 if it does not have a Java register.</TD></TR><TR><TD CLASS="l">234</TD><TD>     * @param register the Java register number of variable</TD></TR><TR><TD CLASS="l"><A NAME="a2">235</A></TD><TD>     *                 or -1 if it does not have a Java register.</TD></TR><TR><TD CLASS="l">236</TD><TD>     */</TD></TR><TR><TD CLASS="l">237</TD><TD>    public void addVariableDescriptor(String name, String type, int startPC, int register)</TD></TR><TR><TD CLASS="l">238</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">239</TD><TD>        int nameIndex = itsConstantPool.addUtf8(name);</TD></TR><TR CLASS="c"><TD CLASS="l">240</TD><TD>        int descriptorIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="c"><TD CLASS="l">241</TD><TD>        int [] chunk = { nameIndex, descriptorIndex, startPC, register };</TD></TR><TR CLASS="c"><TD CLASS="l">242</TD><TD>        if (itsVarDescriptors == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">243</TD><TD>            itsVarDescriptors = new ObjArray();</TD></TR><TR><TD CLASS="l">244</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">245</TD><TD>        itsVarDescriptors.add(chunk);</TD></TR><TR CLASS="c"><TD CLASS="l">246</TD><TD>    }</TD></TR><TR><TD CLASS="l">247</TD><TD> </TD></TR><TR><TD CLASS="l">248</TD><TD>    /**</TD></TR><TR><TD CLASS="l">249</TD><TD>     * Add a method and begin adding code.</TD></TR><TR><TD CLASS="l">250</TD><TD>     *</TD></TR><TR><TD CLASS="l">251</TD><TD>     * This method must be called before other methods for adding code,</TD></TR><TR><TD CLASS="l">252</TD><TD>     * exception tables, etc. can be invoked.</TD></TR><TR><TD CLASS="l">253</TD><TD>     *</TD></TR><TR><TD CLASS="l">254</TD><TD>     * @param methodName the name of the method</TD></TR><TR><TD CLASS="l">255</TD><TD>     * @param type a string representing the type</TD></TR><TR><TD CLASS="l"><A NAME="b2">256</A></TD><TD>     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.</TD></TR><TR><TD CLASS="l">257</TD><TD>     *        bitwise or'd together</TD></TR><TR><TD CLASS="l">258</TD><TD>     */</TD></TR><TR><TD CLASS="l">259</TD><TD>    public void startMethod(String methodName, String type, short flags) {</TD></TR><TR CLASS="c"><TD CLASS="l">260</TD><TD>        short methodNameIndex = itsConstantPool.addUtf8(methodName);</TD></TR><TR CLASS="c"><TD CLASS="l">261</TD><TD>        short typeIndex = itsConstantPool.addUtf8(type);</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>        itsCurrentMethod = new ClassFileMethod(methodName, methodNameIndex,</TD></TR><TR><TD CLASS="l">263</TD><TD>                                               type, typeIndex, flags);</TD></TR><TR CLASS="c"><TD CLASS="l">264</TD><TD>        itsJumpFroms = new UintMap();</TD></TR><TR CLASS="c"><TD CLASS="l">265</TD><TD>        itsMethods.add(itsCurrentMethod);</TD></TR><TR CLASS="c"><TD CLASS="l">266</TD><TD>        addSuperBlockStart(0);</TD></TR><TR CLASS="c"><TD CLASS="l">267</TD><TD>    }</TD></TR><TR><TD CLASS="l">268</TD><TD> </TD></TR><TR><TD CLASS="l">269</TD><TD>    /**</TD></TR><TR><TD CLASS="l">270</TD><TD>     * Complete generation of the method.</TD></TR><TR><TD CLASS="l">271</TD><TD>     *</TD></TR><TR><TD CLASS="l">272</TD><TD>     * After this method is called, no more code can be added to the</TD></TR><TR><TD CLASS="l">273</TD><TD>     * method begun with &lt;code&gt;startMethod&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">274</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="86">275</A></TD><TD>     * @param maxLocals the maximum number of local variable slots</TD></TR><TR><TD CLASS="l">276</TD><TD>     *        (a.k.a. Java registers) used by the method</TD></TR><TR><TD CLASS="l">277</TD><TD>     */</TD></TR><TR><TD CLASS="l">278</TD><TD>    public void stopMethod(short maxLocals) {</TD></TR><TR CLASS="c"><TD CLASS="l">279</TD><TD>        if (itsCurrentMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>            throw new IllegalStateException(&#34;No method to stop&#34;);</TD></TR><TR><TD CLASS="l">281</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">282</TD><TD>        fixLabelGotos();</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">284</TD><TD>        itsMaxLocals = maxLocals;</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">286</TD><TD>        StackMapTable stackMap = null;</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>        if (GenerateStackMap) {</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>            finalizeSuperBlockStarts();</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>            stackMap = new StackMapTable();</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>            stackMap.generate();</TD></TR><TR><TD CLASS="l">291</TD><TD>        }</TD></TR><TR><TD CLASS="l">292</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">293</TD><TD>        int lineNumberTableLength = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">294</TD><TD>        if (itsLineNumberTable != null) {</TD></TR><TR><TD CLASS="l">295</TD><TD>            // 6 bytes for the attribute header</TD></TR><TR><TD CLASS="l">296</TD><TD>            // 2 bytes for the line number count</TD></TR><TR><TD CLASS="l">297</TD><TD>            // 4 bytes for each entry</TD></TR><TR CLASS="c"><TD CLASS="l">298</TD><TD>            lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);</TD></TR><TR><TD CLASS="l">299</TD><TD>        }</TD></TR><TR><TD CLASS="l">300</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">301</TD><TD>        int variableTableLength = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">302</TD><TD>        if (itsVarDescriptors != null) {</TD></TR><TR><TD CLASS="l">303</TD><TD>            // 6 bytes for the attribute header</TD></TR><TR><TD CLASS="l">304</TD><TD>            // 2 bytes for the variable count</TD></TR><TR><TD CLASS="l">305</TD><TD>            // 10 bytes for each entry</TD></TR><TR CLASS="c"><TD CLASS="l">306</TD><TD>            variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);</TD></TR><TR><TD CLASS="l">307</TD><TD>        }</TD></TR><TR><TD CLASS="l">308</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">309</TD><TD>        int stackMapTableLength = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">310</TD><TD>        if (stackMap != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">311</TD><TD>            int stackMapWriteSize = stackMap.computeWriteSize();</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>            if (stackMapWriteSize &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                stackMapTableLength = 6 + stackMapWriteSize;</TD></TR><TR><TD CLASS="l">314</TD><TD>            }</TD></TR><TR><TD CLASS="l">315</TD><TD>        }</TD></TR><TR><TD CLASS="l">316</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">317</TD><TD>        int attrLength = 2 +                    // attribute_name_index</TD></TR><TR><TD CLASS="l">318</TD><TD>                         4 +                    // attribute_length</TD></TR><TR><TD CLASS="l">319</TD><TD>                         2 +                    // max_stack</TD></TR><TR><TD CLASS="l">320</TD><TD>                         2 +                    // max_locals</TD></TR><TR><TD CLASS="l">321</TD><TD>                         4 +                    // code_length</TD></TR><TR><TD CLASS="l">322</TD><TD>                         itsCodeBufferTop +</TD></TR><TR><TD CLASS="l">323</TD><TD>                         2 +                    // exception_table_length</TD></TR><TR><TD CLASS="l">324</TD><TD>                         (itsExceptionTableTop * 8) +</TD></TR><TR><TD CLASS="l">325</TD><TD>                         2 +                    // attributes_count</TD></TR><TR><TD CLASS="l">326</TD><TD>                         lineNumberTableLength +</TD></TR><TR><TD CLASS="l">327</TD><TD>                         variableTableLength +</TD></TR><TR><TD CLASS="l">328</TD><TD>                         stackMapTableLength;</TD></TR><TR><TD CLASS="l">329</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>        if (attrLength &gt; 65536) {</TD></TR><TR><TD CLASS="l">331</TD><TD>            // See http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html,</TD></TR><TR><TD CLASS="l">332</TD><TD>            // section 4.10, &#34;The amount of code per non-native, non-abstract</TD></TR><TR><TD CLASS="l">333</TD><TD>            // method is limited to 65536 bytes...</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>            throw new ClassFileFormatException(</TD></TR><TR><TD CLASS="l">335</TD><TD>                &#34;generated bytecode for method exceeds 64K limit.&#34;);</TD></TR><TR><TD CLASS="l">336</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">337</TD><TD>        byte[] codeAttribute = new byte[attrLength];</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>        int index = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">339</TD><TD>        int codeAttrIndex = itsConstantPool.addUtf8(&#34;Code&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">340</TD><TD>        index = putInt16(codeAttrIndex, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">341</TD><TD>        attrLength -= 6;                 // discount the attribute header</TD></TR><TR CLASS="c"><TD CLASS="l">342</TD><TD>        index = putInt32(attrLength, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>        index = putInt16(itsMaxStack, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">344</TD><TD>        index = putInt16(itsMaxLocals, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        index = putInt32(itsCodeBufferTop, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>        System.arraycopy(itsCodeBuffer, 0, codeAttribute, index,</TD></TR><TR><TD CLASS="l">347</TD><TD>                         itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">348</TD><TD>        index += itsCodeBufferTop;</TD></TR><TR><TD CLASS="l">349</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">350</TD><TD>        if (itsExceptionTableTop &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">351</TD><TD>            index = putInt16(itsExceptionTableTop, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">353</TD><TD>                ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="c"><TD CLASS="l">354</TD><TD>                short startPC = (short)getLabelPC(ete.itsStartLabel);</TD></TR><TR CLASS="c"><TD CLASS="l">355</TD><TD>                short endPC = (short)getLabelPC(ete.itsEndLabel);</TD></TR><TR CLASS="c"><TD CLASS="l">356</TD><TD>                short handlerPC = (short)getLabelPC(ete.itsHandlerLabel);</TD></TR><TR CLASS="c"><TD CLASS="l">357</TD><TD>                short catchType = ete.itsCatchType;</TD></TR><TR CLASS="c"><TD CLASS="l">358</TD><TD>                if (startPC == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>                    throw new IllegalStateException(&#34;start label not defined&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>                if (endPC == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                    throw new IllegalStateException(&#34;end label not defined&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">362</TD><TD>                if (handlerPC == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                    throw new IllegalStateException(</TD></TR><TR><TD CLASS="l">364</TD><TD>                        &#34;handler label not defined&#34;);</TD></TR><TR><TD CLASS="l">365</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">366</TD><TD>                index = putInt16(startPC, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">367</TD><TD>                index = putInt16(endPC, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">368</TD><TD>                index = putInt16(handlerPC, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">369</TD><TD>                index = putInt16(catchType, codeAttribute, index);</TD></TR><TR><TD CLASS="l">370</TD><TD>            }</TD></TR><TR><TD CLASS="l">371</TD><TD>        }</TD></TR><TR><TD CLASS="l">372</TD><TD>        else {</TD></TR><TR><TD CLASS="l">373</TD><TD>            // write 0 as exception table length</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>            index = putInt16(0, codeAttribute, index);</TD></TR><TR><TD CLASS="l">375</TD><TD>        }</TD></TR><TR><TD CLASS="l">376</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">377</TD><TD>        int attributeCount = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">378</TD><TD>        if (itsLineNumberTable != null)</TD></TR><TR CLASS="c"><TD CLASS="l">379</TD><TD>            attributeCount++;</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>        if (itsVarDescriptors != null)</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>            attributeCount++;</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>        if (stackMapTableLength &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">383</TD><TD>            attributeCount++;</TD></TR><TR><TD CLASS="l">384</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>        index = putInt16(attributeCount, codeAttribute, index);</TD></TR><TR><TD CLASS="l">386</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>        if (itsLineNumberTable != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">388</TD><TD>            int lineNumberTableAttrIndex</TD></TR><TR><TD CLASS="l">389</TD><TD>                    = itsConstantPool.addUtf8(&#34;LineNumberTable&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">390</TD><TD>            index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">391</TD><TD>            int tableAttrLength = 2 + (itsLineNumberTableTop * 4);</TD></TR><TR CLASS="c"><TD CLASS="l">392</TD><TD>            index = putInt32(tableAttrLength, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">393</TD><TD>            index = putInt16(itsLineNumberTableTop, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">394</TD><TD>            for (int i = 0; i &lt; itsLineNumberTableTop; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">395</TD><TD>                index = putInt32(itsLineNumberTable[i], codeAttribute, index);</TD></TR><TR><TD CLASS="l">396</TD><TD>            }</TD></TR><TR><TD CLASS="l">397</TD><TD>        }</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">399</TD><TD>        if (itsVarDescriptors != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">400</TD><TD>            int variableTableAttrIndex</TD></TR><TR><TD CLASS="l">401</TD><TD>                    = itsConstantPool.addUtf8(&#34;LocalVariableTable&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">402</TD><TD>            index = putInt16(variableTableAttrIndex, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">403</TD><TD>            int varCount = itsVarDescriptors.size();</TD></TR><TR CLASS="c"><TD CLASS="l">404</TD><TD>            int tableAttrLength = 2 + (varCount * 10);</TD></TR><TR CLASS="c"><TD CLASS="l">405</TD><TD>            index = putInt32(tableAttrLength, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">406</TD><TD>            index = putInt16(varCount, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">407</TD><TD>            for (int i = 0; i &lt; varCount; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">408</TD><TD>                int[] chunk = (int[])itsVarDescriptors.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">409</TD><TD>                int nameIndex       = chunk[0];</TD></TR><TR CLASS="c"><TD CLASS="l">410</TD><TD>                int descriptorIndex = chunk[1];</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>                int startPC         = chunk[2];</TD></TR><TR CLASS="c"><TD CLASS="l">412</TD><TD>                int register        = chunk[3];</TD></TR><TR CLASS="c"><TD CLASS="l">413</TD><TD>                int length = itsCodeBufferTop - startPC;</TD></TR><TR><TD CLASS="l">414</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">415</TD><TD>                index = putInt16(startPC, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">416</TD><TD>                index = putInt16(length, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">417</TD><TD>                index = putInt16(nameIndex, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">418</TD><TD>                index = putInt16(descriptorIndex, codeAttribute, index);</TD></TR><TR CLASS="c"><TD CLASS="l">419</TD><TD>                index = putInt16(register, codeAttribute, index);</TD></TR><TR><TD CLASS="l">420</TD><TD>            }</TD></TR><TR><TD CLASS="l">421</TD><TD>        }</TD></TR><TR><TD CLASS="l">422</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">423</TD><TD>        if (stackMapTableLength &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>            int stackMapTableAttrIndex =</TD></TR><TR><TD CLASS="l">425</TD><TD>                    itsConstantPool.addUtf8(&#34;StackMapTable&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>            int start = index;</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>            index = putInt16(stackMapTableAttrIndex, codeAttribute, index);</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>            index = stackMap.write(codeAttribute, index);</TD></TR><TR><TD CLASS="l">429</TD><TD>        }</TD></TR><TR><TD CLASS="l">430</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>        itsCurrentMethod.setCodeAttribute(codeAttribute);</TD></TR><TR><TD CLASS="l">432</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">433</TD><TD>        itsExceptionTable = null;</TD></TR><TR CLASS="c"><TD CLASS="l">434</TD><TD>        itsExceptionTableTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">435</TD><TD>        itsLineNumberTableTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">436</TD><TD>        itsCodeBufferTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">437</TD><TD>        itsCurrentMethod = null;</TD></TR><TR CLASS="c"><TD CLASS="l">438</TD><TD>        itsMaxStack = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">439</TD><TD>        itsStackTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>        itsLabelTableTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">441</TD><TD>        itsFixupTableTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">442</TD><TD>        itsVarDescriptors = null;</TD></TR><TR CLASS="c"><TD CLASS="l">443</TD><TD>        itsSuperBlockStarts = null;</TD></TR><TR CLASS="c"><TD CLASS="l">444</TD><TD>        itsSuperBlockStartsTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">445</TD><TD>        itsJumpFroms = null;</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>    }</TD></TR><TR><TD CLASS="l">447</TD><TD> </TD></TR><TR><TD CLASS="l">448</TD><TD>    /**</TD></TR><TR><TD CLASS="l">449</TD><TD>     * Add the single-byte opcode to the current method.</TD></TR><TR><TD CLASS="l"><A NAME="82">450</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">451</TD><TD>     * @param theOpCode the opcode of the bytecode</TD></TR><TR><TD CLASS="l">452</TD><TD>     */</TD></TR><TR><TD CLASS="l">453</TD><TD>    public void add(int theOpCode) {</TD></TR><TR CLASS="c"><TD CLASS="l">454</TD><TD>        if (opcodeCount(theOpCode) != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>            throw new IllegalArgumentException(&#34;Unexpected operands&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">456</TD><TD>        int newStack = itsStackTop + stackChange(theOpCode);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="85% line coverage (11 out of 13 instructions)">457</TD><TD TITLE="85% line coverage (11 out of 13 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR><TD CLASS="l">458</TD><TD>        if (DEBUGCODE)</TD></TR><TR><TD CLASS="l">459</TD><TD>            System.out.println(&#34;Add &#34; + bytecodeStr(theOpCode));</TD></TR><TR CLASS="c"><TD CLASS="l">460</TD><TD>        addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">461</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="c"><TD CLASS="l">462</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">463</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">464</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">465</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">466</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">467</TD><TD>        if (theOpCode == ByteCode.ATHROW) {</TD></TR><TR CLASS="c"><TD CLASS="l">468</TD><TD>            addSuperBlockStart(itsCodeBufferTop);</TD></TR><TR><TD CLASS="l">469</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">470</TD><TD>    }</TD></TR><TR><TD CLASS="l">471</TD><TD> </TD></TR><TR><TD CLASS="l">472</TD><TD>    /**</TD></TR><TR><TD CLASS="l">473</TD><TD>     * Add a single-operand opcode to the current method.</TD></TR><TR><TD CLASS="l">474</TD><TD>     *</TD></TR><TR><TD CLASS="l">475</TD><TD>     * @param theOpCode the opcode of the bytecode</TD></TR><TR><TD CLASS="l">476</TD><TD>     * @param theOperand the operand of the bytecode</TD></TR><TR><TD CLASS="l">477</TD><TD>     */</TD></TR><TR><TD CLASS="l">478</TD><TD>    public void add(int theOpCode, int theOperand) {</TD></TR><TR><TD CLASS="l"><A NAME="7d">479</A></TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l">480</TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">481</TD><TD>                               +&#34;, &#34;+Integer.toHexString(theOperand));</TD></TR><TR><TD CLASS="l">482</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">483</TD><TD>        int newStack = itsStackTop + stackChange(theOpCode);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="85% line coverage (11 out of 13 instructions)">484</TD><TD TITLE="85% line coverage (11 out of 13 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">486</TD><TD>        switch (theOpCode) {</TD></TR><TR><TD CLASS="l">487</TD><TD>            case ByteCode.GOTO :</TD></TR><TR><TD CLASS="l">488</TD><TD>                // This is necessary because dead code is seemingly being</TD></TR><TR><TD CLASS="l">489</TD><TD>                // generated and Sun's verifier is expecting type state to be</TD></TR><TR><TD CLASS="l">490</TD><TD>                // placed even at dead blocks of code.</TD></TR><TR CLASS="c"><TD CLASS="l">491</TD><TD>                addSuperBlockStart(itsCodeBufferTop + 3);</TD></TR><TR><TD CLASS="l">492</TD><TD>                // fallthru...</TD></TR><TR><TD CLASS="l">493</TD><TD>            case ByteCode.IFEQ :</TD></TR><TR><TD CLASS="l">494</TD><TD>            case ByteCode.IFNE :</TD></TR><TR><TD CLASS="l">495</TD><TD>            case ByteCode.IFLT :</TD></TR><TR><TD CLASS="l">496</TD><TD>            case ByteCode.IFGE :</TD></TR><TR><TD CLASS="l">497</TD><TD>            case ByteCode.IFGT :</TD></TR><TR><TD CLASS="l">498</TD><TD>            case ByteCode.IFLE :</TD></TR><TR><TD CLASS="l">499</TD><TD>            case ByteCode.IF_ICMPEQ :</TD></TR><TR><TD CLASS="l">500</TD><TD>            case ByteCode.IF_ICMPNE :</TD></TR><TR><TD CLASS="l">501</TD><TD>            case ByteCode.IF_ICMPLT :</TD></TR><TR><TD CLASS="l">502</TD><TD>            case ByteCode.IF_ICMPGE :</TD></TR><TR><TD CLASS="l">503</TD><TD>            case ByteCode.IF_ICMPGT :</TD></TR><TR><TD CLASS="l">504</TD><TD>            case ByteCode.IF_ICMPLE :</TD></TR><TR><TD CLASS="l">505</TD><TD>            case ByteCode.IF_ACMPEQ :</TD></TR><TR><TD CLASS="l">506</TD><TD>            case ByteCode.IF_ACMPNE :</TD></TR><TR><TD CLASS="l">507</TD><TD>            case ByteCode.JSR :</TD></TR><TR><TD CLASS="l">508</TD><TD>            case ByteCode.IFNULL :</TD></TR><TR><TD CLASS="l">509</TD><TD>            case ByteCode.IFNONNULL : {</TD></TR><TR CLASS="c"><TD CLASS="l">510</TD><TD>                    if ((theOperand &amp; 0x80000000) != 0x80000000) {</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>                        if ((theOperand &lt; 0) || (theOperand &gt; 65535))</TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">513</TD><TD>                                &#34;Bad label for branch&#34;);</TD></TR><TR><TD CLASS="l">514</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">515</TD><TD>                    int branchPC = itsCodeBufferTop;</TD></TR><TR CLASS="c"><TD CLASS="l">516</TD><TD>                    addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">517</TD><TD>                    if ((theOperand &amp; 0x80000000) != 0x80000000) {</TD></TR><TR><TD CLASS="l">518</TD><TD>                            // hard displacement</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>                        addToCodeInt16(theOperand);</TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>                        int target = theOperand + branchPC;</TD></TR><TR CLASS="z"><TD CLASS="l">521</TD><TD>                        addSuperBlockStart(target);</TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>                        itsJumpFroms.put(target, branchPC);</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>                    }</TD></TR><TR><TD CLASS="l">524</TD><TD>                    else {  // a label</TD></TR><TR CLASS="c"><TD CLASS="l">525</TD><TD>                        int targetPC = getLabelPC(theOperand);</TD></TR><TR><TD CLASS="l">526</TD><TD>                        if (DEBUGLABELS) {</TD></TR><TR><TD CLASS="l">527</TD><TD>                            int theLabel = theOperand &amp; 0x7FFFFFFF;</TD></TR><TR><TD CLASS="l">528</TD><TD>                            System.out.println(&#34;Fixing branch to &#34; +</TD></TR><TR><TD CLASS="l">529</TD><TD>                                               theLabel + &#34; at &#34; + targetPC +</TD></TR><TR><TD CLASS="l">530</TD><TD>                                               &#34; from &#34; + branchPC);</TD></TR><TR><TD CLASS="l">531</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">532</TD><TD>                        if (targetPC != -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">533</TD><TD>                            int offset = targetPC - branchPC;</TD></TR><TR CLASS="c"><TD CLASS="l">534</TD><TD>                            addToCodeInt16(offset);</TD></TR><TR CLASS="c"><TD CLASS="l">535</TD><TD>                            addSuperBlockStart(targetPC);</TD></TR><TR CLASS="c"><TD CLASS="l">536</TD><TD>                            itsJumpFroms.put(targetPC, branchPC);</TD></TR><TR CLASS="c"><TD CLASS="l">537</TD><TD>                        }</TD></TR><TR><TD CLASS="l">538</TD><TD>                        else {</TD></TR><TR CLASS="c"><TD CLASS="l">539</TD><TD>                            addLabelFixup(theOperand, branchPC + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">540</TD><TD>                            addToCodeInt16(0);</TD></TR><TR><TD CLASS="l">541</TD><TD>                        }</TD></TR><TR><TD CLASS="l">542</TD><TD>                    }</TD></TR><TR><TD CLASS="l">543</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">544</TD><TD>                break;</TD></TR><TR><TD CLASS="l">545</TD><TD> </TD></TR><TR><TD CLASS="l">546</TD><TD>            case ByteCode.BIPUSH :</TD></TR><TR CLASS="c"><TD CLASS="l">547</TD><TD>                if ((byte)theOperand != theOperand)</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                    throw new IllegalArgumentException(&#34;out of range byte&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">549</TD><TD>                addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">550</TD><TD>                addToCodeBuffer((byte)theOperand);</TD></TR><TR CLASS="c"><TD CLASS="l">551</TD><TD>                break;</TD></TR><TR><TD CLASS="l">552</TD><TD> </TD></TR><TR><TD CLASS="l">553</TD><TD>            case ByteCode.SIPUSH :</TD></TR><TR CLASS="c"><TD CLASS="l">554</TD><TD>                if ((short)theOperand != theOperand)</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                    throw new IllegalArgumentException(&#34;out of range short&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">556</TD><TD>                addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">557</TD><TD>                   addToCodeInt16(theOperand);</TD></TR><TR CLASS="c"><TD CLASS="l">558</TD><TD>                break;</TD></TR><TR><TD CLASS="l">559</TD><TD> </TD></TR><TR><TD CLASS="l">560</TD><TD>            case ByteCode.NEWARRAY :</TD></TR><TR CLASS="c"><TD CLASS="l">561</TD><TD>                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 256))</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                    throw new IllegalArgumentException(&#34;out of range index&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">563</TD><TD>                addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">564</TD><TD>                addToCodeBuffer(theOperand);</TD></TR><TR CLASS="c"><TD CLASS="l">565</TD><TD>                break;</TD></TR><TR><TD CLASS="l">566</TD><TD> </TD></TR><TR><TD CLASS="l">567</TD><TD>            case ByteCode.GETFIELD :</TD></TR><TR><TD CLASS="l">568</TD><TD>            case ByteCode.PUTFIELD :</TD></TR><TR CLASS="z"><TD CLASS="l">569</TD><TD>                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>                    throw new IllegalArgumentException(&#34;out of range field&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>                addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>                addToCodeInt16(theOperand);</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>                break;</TD></TR><TR><TD CLASS="l">574</TD><TD> </TD></TR><TR><TD CLASS="l">575</TD><TD>            case ByteCode.LDC :</TD></TR><TR><TD CLASS="l">576</TD><TD>            case ByteCode.LDC_W :</TD></TR><TR><TD CLASS="l">577</TD><TD>            case ByteCode.LDC2_W :</TD></TR><TR CLASS="c"><TD CLASS="l">578</TD><TD>                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>                    throw new IllegalArgumentException(&#34;out of range index&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">580</TD><TD>                if (theOperand &gt;= 256</TD></TR><TR><TD CLASS="l">581</TD><TD>                    || theOpCode == ByteCode.LDC_W</TD></TR><TR><TD CLASS="l">582</TD><TD>                    || theOpCode == ByteCode.LDC2_W)</TD></TR><TR><TD CLASS="l">583</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">584</TD><TD>                    if (theOpCode == ByteCode.LDC) {</TD></TR><TR CLASS="c"><TD CLASS="l">585</TD><TD>                        addToCodeBuffer(ByteCode.LDC_W);</TD></TR><TR><TD CLASS="l">586</TD><TD>                    } else {</TD></TR><TR CLASS="c"><TD CLASS="l">587</TD><TD>                        addToCodeBuffer(theOpCode);</TD></TR><TR><TD CLASS="l">588</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">589</TD><TD>                    addToCodeInt16(theOperand);</TD></TR><TR><TD CLASS="l">590</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">591</TD><TD>                    addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">592</TD><TD>                    addToCodeBuffer(theOperand);</TD></TR><TR><TD CLASS="l">593</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">594</TD><TD>                break;</TD></TR><TR><TD CLASS="l">595</TD><TD> </TD></TR><TR><TD CLASS="l">596</TD><TD>            case ByteCode.RET :</TD></TR><TR><TD CLASS="l">597</TD><TD>            case ByteCode.ILOAD :</TD></TR><TR><TD CLASS="l">598</TD><TD>            case ByteCode.LLOAD :</TD></TR><TR><TD CLASS="l">599</TD><TD>            case ByteCode.FLOAD :</TD></TR><TR><TD CLASS="l">600</TD><TD>            case ByteCode.DLOAD :</TD></TR><TR><TD CLASS="l">601</TD><TD>            case ByteCode.ALOAD :</TD></TR><TR><TD CLASS="l">602</TD><TD>            case ByteCode.ISTORE :</TD></TR><TR><TD CLASS="l">603</TD><TD>            case ByteCode.LSTORE :</TD></TR><TR><TD CLASS="l">604</TD><TD>            case ByteCode.FSTORE :</TD></TR><TR><TD CLASS="l">605</TD><TD>            case ByteCode.DSTORE :</TD></TR><TR><TD CLASS="l">606</TD><TD>            case ByteCode.ASTORE :</TD></TR><TR CLASS="c"><TD CLASS="l">607</TD><TD>                if (!(0 &lt;= theOperand &amp;&amp; theOperand &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                    throw new ClassFileFormatException(&#34;out of range variable&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">609</TD><TD>                if (theOperand &gt;= 256) {</TD></TR><TR CLASS="c"><TD CLASS="l">610</TD><TD>                    addToCodeBuffer(ByteCode.WIDE);</TD></TR><TR CLASS="c"><TD CLASS="l">611</TD><TD>                    addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">612</TD><TD>                    addToCodeInt16(theOperand);</TD></TR><TR><TD CLASS="l">613</TD><TD>                }</TD></TR><TR><TD CLASS="l">614</TD><TD>                else {</TD></TR><TR CLASS="c"><TD CLASS="l">615</TD><TD>                    addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">616</TD><TD>                    addToCodeBuffer(theOperand);</TD></TR><TR><TD CLASS="l">617</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">618</TD><TD>                break;</TD></TR><TR><TD CLASS="l">619</TD><TD> </TD></TR><TR><TD CLASS="l">620</TD><TD>            default :</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>                throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">622</TD><TD>                    &#34;Unexpected opcode for 1 operand&#34;);</TD></TR><TR><TD CLASS="l">623</TD><TD>        }</TD></TR><TR><TD CLASS="l">624</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">625</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="c"><TD CLASS="l">626</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">627</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">628</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">629</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">630</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">631</TD><TD>    }</TD></TR><TR><TD CLASS="l">632</TD><TD> </TD></TR><TR><TD CLASS="l">633</TD><TD>    /**</TD></TR><TR><TD CLASS="l">634</TD><TD>     * Generate the load constant bytecode for the given integer.</TD></TR><TR><TD CLASS="l"><A NAME="9a">635</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">636</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">637</TD><TD>     */</TD></TR><TR><TD CLASS="l">638</TD><TD>    public void addLoadConstant(int k) {</TD></TR><TR CLASS="c"><TD CLASS="l">639</TD><TD>        switch (k) {</TD></TR><TR CLASS="c"><TD CLASS="l">640</TD><TD>            case 0: add(ByteCode.ICONST_0); break;</TD></TR><TR CLASS="c"><TD CLASS="l">641</TD><TD>            case 1: add(ByteCode.ICONST_1); break;</TD></TR><TR CLASS="c"><TD CLASS="l">642</TD><TD>            case 2: add(ByteCode.ICONST_2); break;</TD></TR><TR CLASS="c"><TD CLASS="l">643</TD><TD>            case 3: add(ByteCode.ICONST_3); break;</TD></TR><TR CLASS="c"><TD CLASS="l">644</TD><TD>            case 4: add(ByteCode.ICONST_4); break;</TD></TR><TR CLASS="c"><TD CLASS="l">645</TD><TD>            case 5: add(ByteCode.ICONST_5); break;</TD></TR><TR><TD CLASS="l">646</TD><TD>            default:</TD></TR><TR CLASS="c"><TD CLASS="l">647</TD><TD>                add(ByteCode.LDC, itsConstantPool.addConstant(k));</TD></TR><TR><TD CLASS="l">648</TD><TD>                break;</TD></TR><TR><TD CLASS="l">649</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">650</TD><TD>    }</TD></TR><TR><TD CLASS="l">651</TD><TD> </TD></TR><TR><TD CLASS="l">652</TD><TD>    /**</TD></TR><TR><TD CLASS="l">653</TD><TD>     * Generate the load constant bytecode for the given long.</TD></TR><TR><TD CLASS="l"><A NAME="69">654</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">655</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">656</TD><TD>     */</TD></TR><TR><TD CLASS="l">657</TD><TD>    public void addLoadConstant(long k) {</TD></TR><TR CLASS="z"><TD CLASS="l">658</TD><TD>        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>    }</TD></TR><TR><TD CLASS="l">660</TD><TD> </TD></TR><TR><TD CLASS="l">661</TD><TD>    /**</TD></TR><TR><TD CLASS="l">662</TD><TD>     * Generate the load constant bytecode for the given float.</TD></TR><TR><TD CLASS="l"><A NAME="68">663</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">664</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">665</TD><TD>     */</TD></TR><TR><TD CLASS="l">666</TD><TD>    public void addLoadConstant(float k) {</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>        add(ByteCode.LDC, itsConstantPool.addConstant(k));</TD></TR><TR CLASS="z"><TD CLASS="l">668</TD><TD>    }</TD></TR><TR><TD CLASS="l">669</TD><TD> </TD></TR><TR><TD CLASS="l">670</TD><TD>    /**</TD></TR><TR><TD CLASS="l">671</TD><TD>     * Generate the load constant bytecode for the given double.</TD></TR><TR><TD CLASS="l"><A NAME="99">672</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">673</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">674</TD><TD>     */</TD></TR><TR><TD CLASS="l">675</TD><TD>    public void addLoadConstant(double k) {</TD></TR><TR CLASS="c"><TD CLASS="l">676</TD><TD>        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));</TD></TR><TR CLASS="c"><TD CLASS="l">677</TD><TD>    }</TD></TR><TR><TD CLASS="l">678</TD><TD> </TD></TR><TR><TD CLASS="l">679</TD><TD>    /**</TD></TR><TR><TD CLASS="l">680</TD><TD>     * Generate the load constant bytecode for the given string.</TD></TR><TR><TD CLASS="l"><A NAME="98">681</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">682</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">683</TD><TD>     */</TD></TR><TR><TD CLASS="l">684</TD><TD>    public void addLoadConstant(String k) {</TD></TR><TR CLASS="c"><TD CLASS="l">685</TD><TD>        add(ByteCode.LDC, itsConstantPool.addConstant(k));</TD></TR><TR CLASS="c"><TD CLASS="l">686</TD><TD>    }</TD></TR><TR><TD CLASS="l">687</TD><TD> </TD></TR><TR><TD CLASS="l">688</TD><TD>    /**</TD></TR><TR><TD CLASS="l">689</TD><TD>     * Add the given two-operand bytecode to the current method.</TD></TR><TR><TD CLASS="l">690</TD><TD>     *</TD></TR><TR><TD CLASS="l">691</TD><TD>     * @param theOpCode the opcode of the bytecode</TD></TR><TR><TD CLASS="l">692</TD><TD>     * @param theOperand1 the first operand of the bytecode</TD></TR><TR><TD CLASS="l">693</TD><TD>     * @param theOperand2 the second operand of the bytecode</TD></TR><TR><TD CLASS="l">694</TD><TD>     */</TD></TR><TR><TD CLASS="l">695</TD><TD>    public void add(int theOpCode, int theOperand1, int theOperand2) {</TD></TR><TR><TD CLASS="l">696</TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l"><A NAME="61">697</A></TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">698</TD><TD>                               +&#34;, &#34;+Integer.toHexString(theOperand1)</TD></TR><TR><TD CLASS="l">699</TD><TD>                               +&#34;, &#34;+Integer.toHexString(theOperand2));</TD></TR><TR><TD CLASS="l">700</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>        int newStack = itsStackTop + stackChange(theOpCode);</TD></TR><TR CLASS="z"><TD CLASS="l">702</TD><TD>        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR><TD CLASS="l">703</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">704</TD><TD>        if (theOpCode == ByteCode.IINC) {</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>            if (!(0 &lt;= theOperand1 &amp;&amp; theOperand1 &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">706</TD><TD>                throw new ClassFileFormatException(&#34;out of range variable&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>            if (!(0 &lt;= theOperand2 &amp;&amp; theOperand2 &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>                throw new ClassFileFormatException(&#34;out of range increment&#34;);</TD></TR><TR><TD CLASS="l">709</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>            if (theOperand1 &gt; 255 || theOperand2 &lt; -128 || theOperand2 &gt; 127) {</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                addToCodeBuffer(ByteCode.WIDE);</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                addToCodeBuffer(ByteCode.IINC);</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                addToCodeInt16(theOperand1);</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                addToCodeInt16(theOperand2);</TD></TR><TR><TD CLASS="l">715</TD><TD>            }</TD></TR><TR><TD CLASS="l">716</TD><TD>            else {</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>                addToCodeBuffer(ByteCode.IINC);</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>                addToCodeBuffer(theOperand1);</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                addToCodeBuffer(theOperand2);</TD></TR><TR><TD CLASS="l">720</TD><TD>            }</TD></TR><TR><TD CLASS="l">721</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>        else if (theOpCode == ByteCode.MULTIANEWARRAY) {</TD></TR><TR CLASS="z"><TD CLASS="l">723</TD><TD>            if (!(0 &lt;= theOperand1 &amp;&amp; theOperand1 &lt; 65536))</TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                throw new IllegalArgumentException(&#34;out of range index&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">725</TD><TD>            if (!(0 &lt;= theOperand2 &amp;&amp; theOperand2 &lt; 256))</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                throw new IllegalArgumentException(&#34;out of range dimensions&#34;);</TD></TR><TR><TD CLASS="l">727</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>            addToCodeBuffer(ByteCode.MULTIANEWARRAY);</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>            addToCodeInt16(theOperand1);</TD></TR><TR CLASS="z"><TD CLASS="l">730</TD><TD>            addToCodeBuffer(theOperand2);</TD></TR><TR><TD CLASS="l">731</TD><TD>        }</TD></TR><TR><TD CLASS="l">732</TD><TD>        else {</TD></TR><TR CLASS="z"><TD CLASS="l">733</TD><TD>            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">734</TD><TD>                &#34;Unexpected opcode for 2 operands&#34;);</TD></TR><TR><TD CLASS="l">735</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">736</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">738</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">739</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">740</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">741</TD><TD>        }</TD></TR><TR><TD CLASS="l">742</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>    }</TD></TR><TR><TD CLASS="l">744</TD><TD> </TD></TR><TR><TD CLASS="l">745</TD><TD>    public void add(int theOpCode, String className) {</TD></TR><TR><TD CLASS="l"><A NAME="84">746</A></TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l">747</TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">748</TD><TD>                               +&#34;, &#34;+className);</TD></TR><TR><TD CLASS="l">749</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">750</TD><TD>        int newStack = itsStackTop + stackChange(theOpCode);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="85% line coverage (11 out of 13 instructions)">751</TD><TD TITLE="85% line coverage (11 out of 13 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR CLASS="c"><TD CLASS="l">752</TD><TD>        switch (theOpCode) {</TD></TR><TR><TD CLASS="l">753</TD><TD>            case ByteCode.NEW :</TD></TR><TR><TD CLASS="l">754</TD><TD>            case ByteCode.ANEWARRAY :</TD></TR><TR><TD CLASS="l">755</TD><TD>            case ByteCode.CHECKCAST :</TD></TR><TR><TD CLASS="l">756</TD><TD>            case ByteCode.INSTANCEOF : {</TD></TR><TR CLASS="c"><TD CLASS="l">757</TD><TD>                short classIndex = itsConstantPool.addClass(className);</TD></TR><TR CLASS="c"><TD CLASS="l">758</TD><TD>                addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">759</TD><TD>                addToCodeInt16(classIndex);</TD></TR><TR><TD CLASS="l">760</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">761</TD><TD>            break;</TD></TR><TR><TD CLASS="l">762</TD><TD> </TD></TR><TR><TD CLASS="l">763</TD><TD>            default :</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">765</TD><TD>                    &#34;bad opcode for class reference&#34;);</TD></TR><TR><TD CLASS="l">766</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">767</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="c"><TD CLASS="l">768</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">769</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">770</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">771</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">772</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">773</TD><TD>    }</TD></TR><TR><TD CLASS="l">774</TD><TD> </TD></TR><TR><TD CLASS="l">775</TD><TD> </TD></TR><TR><TD CLASS="l">776</TD><TD>    public void add(int theOpCode, String className, String fieldName,</TD></TR><TR><TD CLASS="l">777</TD><TD>                    String fieldType)</TD></TR><TR><TD CLASS="l">778</TD><TD>    {</TD></TR><TR><TD CLASS="l"><A NAME="87">779</A></TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l">780</TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">781</TD><TD>                               +&#34;, &#34;+className+&#34;, &#34;+fieldName+&#34;, &#34;+fieldType);</TD></TR><TR><TD CLASS="l">782</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">783</TD><TD>        int newStack = itsStackTop + stackChange(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">784</TD><TD>        char fieldTypeChar = fieldType.charAt(0);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="91% line coverage (20 out of 22 instructions)">785</TD><TD TITLE="91% line coverage (20 out of 22 instructions)">        int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D')</TD></TR><TR><TD CLASS="l">786</TD><TD>                        ? 2 : 1;</TD></TR><TR CLASS="c"><TD CLASS="l">787</TD><TD>        switch (theOpCode) {</TD></TR><TR><TD CLASS="l">788</TD><TD>            case ByteCode.GETFIELD :</TD></TR><TR><TD CLASS="l">789</TD><TD>            case ByteCode.GETSTATIC :</TD></TR><TR CLASS="c"><TD CLASS="l">790</TD><TD>                newStack += fieldSize;</TD></TR><TR CLASS="c"><TD CLASS="l">791</TD><TD>                break;</TD></TR><TR><TD CLASS="l">792</TD><TD>            case ByteCode.PUTSTATIC :</TD></TR><TR><TD CLASS="l">793</TD><TD>            case ByteCode.PUTFIELD :</TD></TR><TR CLASS="c"><TD CLASS="l">794</TD><TD>                newStack -= fieldSize;</TD></TR><TR CLASS="c"><TD CLASS="l">795</TD><TD>                break;</TD></TR><TR><TD CLASS="l">796</TD><TD>            default :</TD></TR><TR CLASS="z"><TD CLASS="l">797</TD><TD>                throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">798</TD><TD>                    &#34;bad opcode for field reference&#34;);</TD></TR><TR><TD CLASS="l">799</TD><TD>        }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="71% line coverage (5 out of 7 instructions)">800</TD><TD TITLE="71% line coverage (5 out of 7 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR CLASS="c"><TD CLASS="l">801</TD><TD>        short fieldRefIndex = itsConstantPool.addFieldRef(className,</TD></TR><TR><TD CLASS="l">802</TD><TD>                                             fieldName, fieldType);</TD></TR><TR CLASS="c"><TD CLASS="l">803</TD><TD>        addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">804</TD><TD>        addToCodeInt16(fieldRefIndex);</TD></TR><TR><TD CLASS="l">805</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">806</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="c"><TD CLASS="l">807</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">808</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">809</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">810</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">811</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">812</TD><TD>    }</TD></TR><TR><TD CLASS="l">813</TD><TD> </TD></TR><TR><TD CLASS="l">814</TD><TD>    public void addInvoke(int theOpCode, String className, String methodName,</TD></TR><TR><TD CLASS="l">815</TD><TD>                          String methodType)</TD></TR><TR><TD CLASS="l">816</TD><TD>    {</TD></TR><TR><TD CLASS="l">817</TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l"><A NAME="8b">818</A></TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">819</TD><TD>                               +&#34;, &#34;+className+&#34;, &#34;+methodName+&#34;, &#34;</TD></TR><TR><TD CLASS="l">820</TD><TD>                               +methodType);</TD></TR><TR><TD CLASS="l">821</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">822</TD><TD>        int parameterInfo = sizeOfParameters(methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">823</TD><TD>        int parameterCount = parameterInfo &gt;&gt;&gt; 16;</TD></TR><TR CLASS="c"><TD CLASS="l">824</TD><TD>        int stackDiff = (short)parameterInfo;</TD></TR><TR><TD CLASS="l">825</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">826</TD><TD>        int newStack = itsStackTop + stackDiff;</TD></TR><TR CLASS="c"><TD CLASS="l">827</TD><TD>        newStack += stackChange(theOpCode);     // adjusts for 'this'</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="93% line coverage (25 out of 27 instructions)">828</TD><TD TITLE="93% line coverage (25 out of 27 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR><TD CLASS="l">829</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">830</TD><TD>        switch (theOpCode) {</TD></TR><TR><TD CLASS="l">831</TD><TD>            case ByteCode.INVOKEVIRTUAL :</TD></TR><TR><TD CLASS="l">832</TD><TD>            case ByteCode.INVOKESPECIAL :</TD></TR><TR><TD CLASS="l">833</TD><TD>            case ByteCode.INVOKESTATIC :</TD></TR><TR><TD CLASS="l">834</TD><TD>            case ByteCode.INVOKEINTERFACE : {</TD></TR><TR CLASS="c"><TD CLASS="l">835</TD><TD>                    addToCodeBuffer(theOpCode);</TD></TR><TR CLASS="c"><TD CLASS="l">836</TD><TD>                    if (theOpCode == ByteCode.INVOKEINTERFACE) {</TD></TR><TR CLASS="c"><TD CLASS="l">837</TD><TD>                        short ifMethodRefIndex</TD></TR><TR><TD CLASS="l">838</TD><TD>                                    = itsConstantPool.addInterfaceMethodRef(</TD></TR><TR><TD CLASS="l">839</TD><TD>                                               className, methodName,</TD></TR><TR><TD CLASS="l">840</TD><TD>                                               methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">841</TD><TD>                        addToCodeInt16(ifMethodRefIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">842</TD><TD>                        addToCodeBuffer(parameterCount + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">843</TD><TD>                        addToCodeBuffer(0);</TD></TR><TR CLASS="c"><TD CLASS="l">844</TD><TD>                    }</TD></TR><TR><TD CLASS="l">845</TD><TD>                    else {</TD></TR><TR CLASS="c"><TD CLASS="l">846</TD><TD>                        short methodRefIndex = itsConstantPool.addMethodRef(</TD></TR><TR><TD CLASS="l">847</TD><TD>                                               className, methodName,</TD></TR><TR><TD CLASS="l">848</TD><TD>                                               methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">849</TD><TD>                        addToCodeInt16(methodRefIndex);</TD></TR><TR><TD CLASS="l">850</TD><TD>                    }</TD></TR><TR><TD CLASS="l">851</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">852</TD><TD>                break;</TD></TR><TR><TD CLASS="l">853</TD><TD> </TD></TR><TR><TD CLASS="l">854</TD><TD>            default :</TD></TR><TR CLASS="z"><TD CLASS="l">855</TD><TD>                throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">856</TD><TD>                    &#34;bad opcode for method reference&#34;);</TD></TR><TR><TD CLASS="l">857</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">858</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="c"><TD CLASS="l">859</TD><TD>        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">860</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">861</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(theOpCode)</TD></TR><TR><TD CLASS="l">862</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">863</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">864</TD><TD>    }</TD></TR><TR><TD CLASS="l">865</TD><TD> </TD></TR><TR><TD CLASS="l">866</TD><TD>    /**</TD></TR><TR><TD CLASS="l">867</TD><TD>     * Generate code to load the given integer on stack.</TD></TR><TR><TD CLASS="l">868</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="9f">869</A></TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">870</TD><TD>     */</TD></TR><TR><TD CLASS="l">871</TD><TD>    public void addPush(int k)</TD></TR><TR><TD CLASS="l">872</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">873</TD><TD>        if ((byte)k == k) {</TD></TR><TR CLASS="c"><TD CLASS="l">874</TD><TD>            if (k == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">875</TD><TD>                add(ByteCode.ICONST_M1);</TD></TR><TR CLASS="c"><TD CLASS="l">876</TD><TD>            } else if (0 &lt;= k &amp;&amp; k &lt;= 5) {</TD></TR><TR CLASS="c"><TD CLASS="l">877</TD><TD>                add((byte)(ByteCode.ICONST_0 + k));</TD></TR><TR><TD CLASS="l">878</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">879</TD><TD>                add(ByteCode.BIPUSH, (byte)k);</TD></TR><TR><TD CLASS="l">880</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">881</TD><TD>        } else if ((short)k == k) {</TD></TR><TR CLASS="c"><TD CLASS="l">882</TD><TD>            add(ByteCode.SIPUSH, (short)k);</TD></TR><TR><TD CLASS="l">883</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">884</TD><TD>            addLoadConstant(k);</TD></TR><TR><TD CLASS="l">885</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="9d">886</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">887</TD><TD> </TD></TR><TR><TD CLASS="l">888</TD><TD>    public void addPush(boolean k)</TD></TR><TR><TD CLASS="l">889</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">890</TD><TD>        add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);</TD></TR><TR CLASS="c"><TD CLASS="l">891</TD><TD>    }</TD></TR><TR><TD CLASS="l">892</TD><TD> </TD></TR><TR><TD CLASS="l">893</TD><TD>    /**</TD></TR><TR><TD CLASS="l">894</TD><TD>     * Generate code to load the given long on stack.</TD></TR><TR><TD CLASS="l">895</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="83">896</A></TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">897</TD><TD>     */</TD></TR><TR><TD CLASS="l">898</TD><TD>    public void addPush(long k)</TD></TR><TR><TD CLASS="l">899</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">900</TD><TD>        int ik = (int)k;</TD></TR><TR CLASS="c"><TD CLASS="l">901</TD><TD>        if (ik == k) {</TD></TR><TR CLASS="c"><TD CLASS="l">902</TD><TD>            addPush(ik);</TD></TR><TR CLASS="c"><TD CLASS="l">903</TD><TD>            add(ByteCode.I2L);</TD></TR><TR><TD CLASS="l">904</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">905</TD><TD>            addLoadConstant(k);</TD></TR><TR><TD CLASS="l">906</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">907</TD><TD>    }</TD></TR><TR><TD CLASS="l">908</TD><TD> </TD></TR><TR><TD CLASS="l">909</TD><TD>    /**</TD></TR><TR><TD CLASS="l">910</TD><TD>     * Generate code to load the given double on stack.</TD></TR><TR><TD CLASS="l">911</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="9e">912</A></TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">913</TD><TD>     */</TD></TR><TR><TD CLASS="l">914</TD><TD>    public void addPush(double k)</TD></TR><TR><TD CLASS="l">915</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">916</TD><TD>        if (k == 0.0) {</TD></TR><TR><TD CLASS="l">917</TD><TD>            // zero</TD></TR><TR CLASS="c"><TD CLASS="l">918</TD><TD>            add(ByteCode.DCONST_0);</TD></TR><TR CLASS="c"><TD CLASS="l">919</TD><TD>            if (1.0 / k &lt; 0) {</TD></TR><TR><TD CLASS="l">920</TD><TD>                // Negative zero</TD></TR><TR CLASS="c"><TD CLASS="l">921</TD><TD>                add(ByteCode.DNEG);</TD></TR><TR><TD CLASS="l">922</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">923</TD><TD>        } else if (k == 1.0 || k == -1.0) {</TD></TR><TR CLASS="c"><TD CLASS="l">924</TD><TD>            add(ByteCode.DCONST_1);</TD></TR><TR CLASS="c"><TD CLASS="l">925</TD><TD>            if (k &lt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">926</TD><TD>                add(ByteCode.DNEG);</TD></TR><TR><TD CLASS="l">927</TD><TD>            }</TD></TR><TR><TD CLASS="l">928</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">929</TD><TD>            addLoadConstant(k);</TD></TR><TR><TD CLASS="l">930</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">931</TD><TD>    }</TD></TR><TR><TD CLASS="l">932</TD><TD> </TD></TR><TR><TD CLASS="l">933</TD><TD>    /**</TD></TR><TR><TD CLASS="l">934</TD><TD>     * Generate the code to leave on stack the given string even if the</TD></TR><TR><TD CLASS="l">935</TD><TD>     * string encoding exeeds the class file limit for single string constant</TD></TR><TR><TD CLASS="l"><A NAME="9c">936</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">937</TD><TD>     * @param k the constant</TD></TR><TR><TD CLASS="l">938</TD><TD>     */</TD></TR><TR><TD CLASS="l">939</TD><TD>    public void addPush(String k) {</TD></TR><TR CLASS="c"><TD CLASS="l">940</TD><TD>        int length = k.length();</TD></TR><TR CLASS="c"><TD CLASS="l">941</TD><TD>        int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);</TD></TR><TR CLASS="c"><TD CLASS="l">942</TD><TD>        if (limit == length) {</TD></TR><TR CLASS="c"><TD CLASS="l">943</TD><TD>            addLoadConstant(k);</TD></TR><TR CLASS="c"><TD CLASS="l">944</TD><TD>            return;</TD></TR><TR><TD CLASS="l">945</TD><TD>        }</TD></TR><TR><TD CLASS="l">946</TD><TD>        // Split string into picies fitting the UTF limit and generate code for</TD></TR><TR><TD CLASS="l">947</TD><TD>        // StringBuffer sb = new StringBuffer(length);</TD></TR><TR><TD CLASS="l">948</TD><TD>        // sb.append(loadConstant(piece_1));</TD></TR><TR><TD CLASS="l">949</TD><TD>        // ...</TD></TR><TR><TD CLASS="l">950</TD><TD>        // sb.append(loadConstant(piece_N));</TD></TR><TR><TD CLASS="l">951</TD><TD>        // sb.toString();</TD></TR><TR CLASS="c"><TD CLASS="l">952</TD><TD>        final String SB = &#34;java/lang/StringBuffer&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">953</TD><TD>        add(ByteCode.NEW, SB);</TD></TR><TR CLASS="c"><TD CLASS="l">954</TD><TD>        add(ByteCode.DUP);</TD></TR><TR CLASS="c"><TD CLASS="l">955</TD><TD>        addPush(length);</TD></TR><TR CLASS="c"><TD CLASS="l">956</TD><TD>        addInvoke(ByteCode.INVOKESPECIAL, SB, &#34;&lt;init&gt;&#34;, &#34;(I)V&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">957</TD><TD>        int cursor = 0;</TD></TR><TR><TD CLASS="l">958</TD><TD>        for (;;) {</TD></TR><TR CLASS="c"><TD CLASS="l">959</TD><TD>            add(ByteCode.DUP);</TD></TR><TR CLASS="c"><TD CLASS="l">960</TD><TD>            String s = k.substring(cursor, limit);</TD></TR><TR CLASS="c"><TD CLASS="l">961</TD><TD>            addLoadConstant(s);</TD></TR><TR CLASS="c"><TD CLASS="l">962</TD><TD>            addInvoke(ByteCode.INVOKEVIRTUAL, SB, &#34;append&#34;,</TD></TR><TR><TD CLASS="l">963</TD><TD>                      &#34;(Ljava/lang/String;)Ljava/lang/StringBuffer;&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">964</TD><TD>            add(ByteCode.POP);</TD></TR><TR CLASS="c"><TD CLASS="l">965</TD><TD>            if (limit == length) {</TD></TR><TR CLASS="c"><TD CLASS="l">966</TD><TD>                break;</TD></TR><TR><TD CLASS="l">967</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">968</TD><TD>            cursor = limit;</TD></TR><TR CLASS="c"><TD CLASS="l">969</TD><TD>            limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);</TD></TR><TR CLASS="c"><TD CLASS="l">970</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">971</TD><TD>        addInvoke(ByteCode.INVOKEVIRTUAL, SB, &#34;toString&#34;,</TD></TR><TR><TD CLASS="l">972</TD><TD>                  &#34;()Ljava/lang/String;&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">973</TD><TD>    }</TD></TR><TR><TD CLASS="l">974</TD><TD> </TD></TR><TR><TD CLASS="l">975</TD><TD>    /**</TD></TR><TR><TD CLASS="l">976</TD><TD>     * Check if k fits limit on string constant size imposed by class file</TD></TR><TR><TD CLASS="l">977</TD><TD>     * format.</TD></TR><TR><TD CLASS="l">978</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="71">979</A></TD><TD>     * @param k the string constant</TD></TR><TR><TD CLASS="l">980</TD><TD>     */</TD></TR><TR><TD CLASS="l">981</TD><TD>    public boolean isUnderStringSizeLimit(String k)</TD></TR><TR><TD CLASS="l">982</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">983</TD><TD>        return itsConstantPool.isUnderUtfEncodingLimit(k);</TD></TR><TR><TD CLASS="l">984</TD><TD>    }</TD></TR><TR><TD CLASS="l">985</TD><TD> </TD></TR><TR><TD CLASS="l">986</TD><TD>    /**</TD></TR><TR><TD CLASS="l">987</TD><TD>     * Store integer from stack top into the given local.</TD></TR><TR><TD CLASS="l">988</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="96">989</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">990</TD><TD>     */</TD></TR><TR><TD CLASS="l">991</TD><TD>    public void addIStore(int local)</TD></TR><TR><TD CLASS="l">992</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">993</TD><TD>        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);</TD></TR><TR CLASS="c"><TD CLASS="l">994</TD><TD>    }</TD></TR><TR><TD CLASS="l">995</TD><TD> </TD></TR><TR><TD CLASS="l">996</TD><TD>    /**</TD></TR><TR><TD CLASS="l">997</TD><TD>     * Store long from stack top into the given local.</TD></TR><TR><TD CLASS="l">998</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="67">999</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1000</TD><TD>     */</TD></TR><TR><TD CLASS="l">1001</TD><TD>    public void addLStore(int local)</TD></TR><TR><TD CLASS="l">1002</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1003</TD><TD>        xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);</TD></TR><TR CLASS="z"><TD CLASS="l">1004</TD><TD>    }</TD></TR><TR><TD CLASS="l">1005</TD><TD> </TD></TR><TR><TD CLASS="l">1006</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1007</TD><TD>     * Store float from stack top into the given local.</TD></TR><TR><TD CLASS="l">1008</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="62">1009</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1010</TD><TD>     */</TD></TR><TR><TD CLASS="l">1011</TD><TD>    public void addFStore(int local)</TD></TR><TR><TD CLASS="l">1012</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1013</TD><TD>        xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>    }</TD></TR><TR><TD CLASS="l">1015</TD><TD> </TD></TR><TR><TD CLASS="l">1016</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1017</TD><TD>     * Store double from stack top into the given local.</TD></TR><TR><TD CLASS="l">1018</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="92">1019</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1020</TD><TD>     */</TD></TR><TR><TD CLASS="l">1021</TD><TD>    public void addDStore(int local)</TD></TR><TR><TD CLASS="l">1022</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1023</TD><TD>        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1024</TD><TD>    }</TD></TR><TR><TD CLASS="l">1025</TD><TD> </TD></TR><TR><TD CLASS="l">1026</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1027</TD><TD>     * Store object from stack top into the given local.</TD></TR><TR><TD CLASS="l">1028</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="90">1029</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1030</TD><TD>     */</TD></TR><TR><TD CLASS="l">1031</TD><TD>    public void addAStore(int local)</TD></TR><TR><TD CLASS="l">1032</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1033</TD><TD>        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1034</TD><TD>    }</TD></TR><TR><TD CLASS="l">1035</TD><TD> </TD></TR><TR><TD CLASS="l">1036</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1037</TD><TD>     * Load integer from the given local into stack.</TD></TR><TR><TD CLASS="l">1038</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="95">1039</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1040</TD><TD>     */</TD></TR><TR><TD CLASS="l">1041</TD><TD>    public void addILoad(int local)</TD></TR><TR><TD CLASS="l">1042</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1043</TD><TD>        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1044</TD><TD>    }</TD></TR><TR><TD CLASS="l">1045</TD><TD> </TD></TR><TR><TD CLASS="l">1046</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1047</TD><TD>     * Load long from the given local into stack.</TD></TR><TR><TD CLASS="l">1048</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="66">1049</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1050</TD><TD>     */</TD></TR><TR><TD CLASS="l">1051</TD><TD>    public void addLLoad(int local)</TD></TR><TR><TD CLASS="l">1052</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1053</TD><TD>        xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>    }</TD></TR><TR><TD CLASS="l">1055</TD><TD> </TD></TR><TR><TD CLASS="l">1056</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1057</TD><TD>     * Load float from the given local into stack.</TD></TR><TR><TD CLASS="l">1058</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="93">1059</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1060</TD><TD>     */</TD></TR><TR><TD CLASS="l">1061</TD><TD>    public void addFLoad(int local)</TD></TR><TR><TD CLASS="l">1062</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1063</TD><TD>        xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1064</TD><TD>    }</TD></TR><TR><TD CLASS="l">1065</TD><TD> </TD></TR><TR><TD CLASS="l">1066</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1067</TD><TD>     * Load double from the given local into stack.</TD></TR><TR><TD CLASS="l">1068</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="91">1069</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1070</TD><TD>     */</TD></TR><TR><TD CLASS="l">1071</TD><TD>    public void addDLoad(int local)</TD></TR><TR><TD CLASS="l">1072</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1073</TD><TD>        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1074</TD><TD>    }</TD></TR><TR><TD CLASS="l">1075</TD><TD> </TD></TR><TR><TD CLASS="l">1076</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1077</TD><TD>     * Load object from the given local into stack.</TD></TR><TR><TD CLASS="l">1078</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="8f">1079</A></TD><TD>     * @param local number of local register</TD></TR><TR><TD CLASS="l">1080</TD><TD>     */</TD></TR><TR><TD CLASS="l">1081</TD><TD>    public void addALoad(int local)</TD></TR><TR><TD CLASS="l">1082</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1083</TD><TD>        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);</TD></TR><TR CLASS="c"><TD CLASS="l">1084</TD><TD>    }</TD></TR><TR><TD CLASS="l">1085</TD><TD> </TD></TR><TR><TD CLASS="l">1086</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="9b">1087</A></TD><TD>     * Load &#34;this&#34; into stack.</TD></TR><TR><TD CLASS="l">1088</TD><TD>     */</TD></TR><TR><TD CLASS="l">1089</TD><TD>    public void addLoadThis()</TD></TR><TR><TD CLASS="l">1090</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1091</TD><TD>        add(ByteCode.ALOAD_0);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="b3">1092</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1093</TD><TD> </TD></TR><TR><TD CLASS="l">1094</TD><TD>    private void xop(int shortOp, int op, int local)</TD></TR><TR><TD CLASS="l">1095</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1096</TD><TD>        switch (local) {</TD></TR><TR><TD CLASS="l">1097</TD><TD>          case 0:</TD></TR><TR CLASS="c"><TD CLASS="l">1098</TD><TD>            add(shortOp);</TD></TR><TR CLASS="c"><TD CLASS="l">1099</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1100</TD><TD>          case 1:</TD></TR><TR CLASS="c"><TD CLASS="l">1101</TD><TD>            add(shortOp + 1);</TD></TR><TR CLASS="c"><TD CLASS="l">1102</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1103</TD><TD>          case 2:</TD></TR><TR CLASS="c"><TD CLASS="l">1104</TD><TD>            add(shortOp + 2);</TD></TR><TR CLASS="c"><TD CLASS="l">1105</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1106</TD><TD>          case 3:</TD></TR><TR CLASS="c"><TD CLASS="l">1107</TD><TD>            add(shortOp + 3);</TD></TR><TR CLASS="c"><TD CLASS="l">1108</TD><TD>            break;</TD></TR><TR><TD CLASS="l">1109</TD><TD>          default:</TD></TR><TR CLASS="c"><TD CLASS="l">1110</TD><TD>            add(op, local);</TD></TR><TR><TD CLASS="l">1111</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1112</TD><TD>    }</TD></TR><TR><TD CLASS="l">1113</TD><TD> </TD></TR><TR><TD CLASS="l">1114</TD><TD>    public int addTableSwitch(int low, int high)</TD></TR><TR><TD CLASS="l">1115</TD><TD>    {</TD></TR><TR><TD CLASS="l"><A NAME="80">1116</A></TD><TD>        if (DEBUGCODE) {</TD></TR><TR><TD CLASS="l">1117</TD><TD>            System.out.println(&#34;Add &#34;+bytecodeStr(ByteCode.TABLESWITCH)</TD></TR><TR><TD CLASS="l">1118</TD><TD>                               +&#34; &#34;+low+&#34; &#34;+high);</TD></TR><TR><TD CLASS="l">1119</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1120</TD><TD>        if (low &gt; high)</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>            throw new ClassFileFormatException(&#34;Bad bounds: &#34;+low+' '+ high);</TD></TR><TR><TD CLASS="l">1122</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1123</TD><TD>        int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="85% line coverage (11 out of 13 instructions)">1124</TD><TD TITLE="85% line coverage (11 out of 13 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR><TD CLASS="l">1125</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1126</TD><TD>        int entryCount = high - low + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">1127</TD><TD>        int padSize = 3 &amp; ~itsCodeBufferTop; // == 3 - itsCodeBufferTop % 4</TD></TR><TR><TD CLASS="l">1128</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1129</TD><TD>        int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));</TD></TR><TR CLASS="c"><TD CLASS="l">1130</TD><TD>        int switchStart = N;</TD></TR><TR CLASS="c"><TD CLASS="l">1131</TD><TD>        itsCodeBuffer[N++] = (byte)ByteCode.TABLESWITCH;</TD></TR><TR CLASS="c"><TD CLASS="l">1132</TD><TD>        while (padSize != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">1133</TD><TD>            itsCodeBuffer[N++] = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1134</TD><TD>            --padSize;</TD></TR><TR><TD CLASS="l">1135</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1136</TD><TD>        N += 4; // skip default offset</TD></TR><TR CLASS="c"><TD CLASS="l">1137</TD><TD>        N = putInt32(low, itsCodeBuffer, N);</TD></TR><TR CLASS="c"><TD CLASS="l">1138</TD><TD>        putInt32(high, itsCodeBuffer, N);</TD></TR><TR><TD CLASS="l">1139</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1140</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="84% line coverage (21 out of 25 instructions)">1141</TD><TD TITLE="84% line coverage (21 out of 25 instructions)">        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">1142</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">1143</TD><TD>            System.out.println(&#34;After &#34;+bytecodeStr(ByteCode.TABLESWITCH)</TD></TR><TR><TD CLASS="l">1144</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">1145</TD><TD>        }</TD></TR><TR><TD CLASS="l">1146</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1147</TD><TD>        return switchStart;</TD></TR><TR><TD CLASS="l"><A NAME="ad">1148</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1149</TD><TD> </TD></TR><TR><TD CLASS="l">1150</TD><TD>    public final void markTableSwitchDefault(int switchStart)</TD></TR><TR><TD CLASS="l">1151</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1152</TD><TD>        addSuperBlockStart(itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1153</TD><TD>        itsJumpFroms.put(itsCodeBufferTop, switchStart);</TD></TR><TR CLASS="c"><TD CLASS="l">1154</TD><TD>        setTableSwitchJump(switchStart, -1, itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="ac">1155</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1156</TD><TD> </TD></TR><TR><TD CLASS="l">1157</TD><TD>    public final void markTableSwitchCase(int switchStart, int caseIndex)</TD></TR><TR><TD CLASS="l">1158</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1159</TD><TD>        addSuperBlockStart(itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1160</TD><TD>        itsJumpFroms.put(itsCodeBufferTop, switchStart);</TD></TR><TR CLASS="c"><TD CLASS="l">1161</TD><TD>        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1162</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="7c">1163</A></TD><TD> </TD></TR><TR><TD CLASS="l">1164</TD><TD>    public final void markTableSwitchCase(int switchStart, int caseIndex,</TD></TR><TR><TD CLASS="l">1165</TD><TD>                                          int stackTop)</TD></TR><TR><TD CLASS="l">1166</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1167</TD><TD>        if (!(0 &lt;= stackTop &amp;&amp; stackTop &lt;= itsMaxStack))</TD></TR><TR CLASS="z"><TD CLASS="l">1168</TD><TD>            throw new IllegalArgumentException(&#34;Bad stack index: &#34;+stackTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1169</TD><TD>        itsStackTop = (short)stackTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1170</TD><TD>        addSuperBlockStart(itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1171</TD><TD>        itsJumpFroms.put(itsCodeBufferTop, switchStart);</TD></TR><TR CLASS="c"><TD CLASS="l">1172</TD><TD>        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1173</TD><TD>    }</TD></TR><TR><TD CLASS="l">1174</TD><TD> </TD></TR><TR><TD CLASS="l">1175</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1176</TD><TD>     * Set a jump case for a tableswitch instruction. The jump target should</TD></TR><TR><TD CLASS="l">1177</TD><TD>     * be marked as a super block start for stack map generation.</TD></TR><TR><TD CLASS="l"><A NAME="78">1178</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1179</TD><TD>    public void setTableSwitchJump(int switchStart, int caseIndex,</TD></TR><TR><TD CLASS="l">1180</TD><TD>                                   int jumpTarget)</TD></TR><TR><TD CLASS="l">1181</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1182</TD><TD>        if (!(0 &lt;= jumpTarget &amp;&amp; jumpTarget &lt;= itsCodeBufferTop))</TD></TR><TR CLASS="z"><TD CLASS="l">1183</TD><TD>            throw new IllegalArgumentException(&#34;Bad jump target: &#34;+jumpTarget);</TD></TR><TR CLASS="c"><TD CLASS="l">1184</TD><TD>        if (!(caseIndex &gt;= -1))</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>            throw new IllegalArgumentException(&#34;Bad case index: &#34;+caseIndex);</TD></TR><TR><TD CLASS="l">1186</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1187</TD><TD>        int padSize = 3 &amp; ~switchStart; // == 3 - switchStart % 4</TD></TR><TR><TD CLASS="l">1188</TD><TD>        int caseOffset;</TD></TR><TR CLASS="c"><TD CLASS="l">1189</TD><TD>        if (caseIndex &lt; 0) {</TD></TR><TR><TD CLASS="l">1190</TD><TD>            // default label</TD></TR><TR CLASS="c"><TD CLASS="l">1191</TD><TD>            caseOffset = switchStart + 1 + padSize;</TD></TR><TR><TD CLASS="l">1192</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1193</TD><TD>            caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);</TD></TR><TR><TD CLASS="l">1194</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1195</TD><TD>        if (!(0 &lt;= switchStart</TD></TR><TR><TD CLASS="l">1196</TD><TD>              &amp;&amp; switchStart &lt;= itsCodeBufferTop - 4 * 4 - padSize - 1))</TD></TR><TR><TD CLASS="l">1197</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1198</TD><TD>            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">1199</TD><TD>                switchStart+&#34; is outside a possible range of tableswitch&#34;</TD></TR><TR><TD CLASS="l">1200</TD><TD>                +&#34; in already generated code&#34;);</TD></TR><TR><TD CLASS="l">1201</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1202</TD><TD>        if ((0xFF &amp; itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {</TD></TR><TR CLASS="z"><TD CLASS="l">1203</TD><TD>            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">1204</TD><TD>                switchStart+&#34; is not offset of tableswitch statement&#34;);</TD></TR><TR><TD CLASS="l">1205</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1206</TD><TD>        if (!(0 &lt;= caseOffset &amp;&amp; caseOffset + 4 &lt;= itsCodeBufferTop)) {</TD></TR><TR><TD CLASS="l">1207</TD><TD>            // caseIndex &gt;= -1 does not guarantee that caseOffset &gt;= 0 due</TD></TR><TR><TD CLASS="l">1208</TD><TD>            // to a possible overflow.</TD></TR><TR CLASS="z"><TD CLASS="l">1209</TD><TD>            throw new ClassFileFormatException(</TD></TR><TR><TD CLASS="l">1210</TD><TD>                &#34;Too big case index: &#34;+caseIndex);</TD></TR><TR><TD CLASS="l">1211</TD><TD>        }</TD></TR><TR><TD CLASS="l">1212</TD><TD>        // ALERT: perhaps check against case bounds?</TD></TR><TR CLASS="c"><TD CLASS="l">1213</TD><TD>        putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="8e">1214</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1215</TD><TD> </TD></TR><TR><TD CLASS="l">1216</TD><TD>    public int acquireLabel()</TD></TR><TR><TD CLASS="l">1217</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1218</TD><TD>        int top = itsLabelTableTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1219</TD><TD>        if (itsLabelTable == null || top == itsLabelTable.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">1220</TD><TD>            if (itsLabelTable == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1221</TD><TD>                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];</TD></TR><TR><TD CLASS="l">1222</TD><TD>            }else {</TD></TR><TR CLASS="c"><TD CLASS="l">1223</TD><TD>                int[] tmp = new int[itsLabelTable.length * 2];</TD></TR><TR CLASS="c"><TD CLASS="l">1224</TD><TD>                System.arraycopy(itsLabelTable, 0, tmp, 0, top);</TD></TR><TR CLASS="c"><TD CLASS="l">1225</TD><TD>                itsLabelTable = tmp;</TD></TR><TR><TD CLASS="l">1226</TD><TD>            }</TD></TR><TR><TD CLASS="l">1227</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1228</TD><TD>        itsLabelTableTop = top + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">1229</TD><TD>        itsLabelTable[top] = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">1230</TD><TD>        return top | 0x80000000;</TD></TR><TR><TD CLASS="l"><A NAME="7b">1231</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1232</TD><TD> </TD></TR><TR><TD CLASS="l">1233</TD><TD>    public void markLabel(int label)</TD></TR><TR><TD CLASS="l">1234</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1235</TD><TD>        if (!(label &lt; 0))</TD></TR><TR CLASS="z"><TD CLASS="l">1236</TD><TD>            throw new IllegalArgumentException(&#34;Bad label, no biscuit&#34;);</TD></TR><TR><TD CLASS="l">1237</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1238</TD><TD>        label &amp;= 0x7FFFFFFF;</TD></TR><TR CLASS="c"><TD CLASS="l">1239</TD><TD>        if (label &gt; itsLabelTableTop)</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>            throw new IllegalArgumentException(&#34;Bad label&#34;);</TD></TR><TR><TD CLASS="l">1241</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1242</TD><TD>        if (itsLabelTable[label] != -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>            throw new IllegalStateException(&#34;Can only mark label once&#34;);</TD></TR><TR><TD CLASS="l">1244</TD><TD>        }</TD></TR><TR><TD CLASS="l">1245</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1246</TD><TD>        itsLabelTable[label] = itsCodeBufferTop;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="ab">1247</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1248</TD><TD> </TD></TR><TR><TD CLASS="l">1249</TD><TD>    public void markLabel(int label, short stackTop)</TD></TR><TR><TD CLASS="l">1250</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1251</TD><TD>        markLabel(label);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="aa">1252</A></TD><TD>        itsStackTop = stackTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1253</TD><TD>    }</TD></TR><TR><TD CLASS="l">1254</TD><TD> </TD></TR><TR><TD CLASS="l">1255</TD><TD>    public void markHandler(int theLabel) {</TD></TR><TR CLASS="c"><TD CLASS="l">1256</TD><TD>        itsStackTop = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">1257</TD><TD>        markLabel(theLabel);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="7a">1258</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1259</TD><TD> </TD></TR><TR><TD CLASS="l">1260</TD><TD>    public int getLabelPC(int label)</TD></TR><TR><TD CLASS="l">1261</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1262</TD><TD>        if (!(label &lt; 0))</TD></TR><TR CLASS="z"><TD CLASS="l">1263</TD><TD>            throw new IllegalArgumentException(&#34;Bad label, no biscuit&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1264</TD><TD>        label &amp;= 0x7FFFFFFF;</TD></TR><TR CLASS="c"><TD CLASS="l">1265</TD><TD>        if (!(label &lt; itsLabelTableTop))</TD></TR><TR CLASS="z"><TD CLASS="l">1266</TD><TD>            throw new IllegalArgumentException(&#34;Bad label&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1267</TD><TD>        return itsLabelTable[label];</TD></TR><TR><TD CLASS="l"><A NAME="85">1268</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1269</TD><TD> </TD></TR><TR><TD CLASS="l">1270</TD><TD>    private void addLabelFixup(int label, int fixupSite)</TD></TR><TR><TD CLASS="l">1271</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1272</TD><TD>        if (!(label &lt; 0))</TD></TR><TR CLASS="z"><TD CLASS="l">1273</TD><TD>            throw new IllegalArgumentException(&#34;Bad label, no biscuit&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1274</TD><TD>        label &amp;= 0x7FFFFFFF;</TD></TR><TR CLASS="c"><TD CLASS="l">1275</TD><TD>        if (!(label &lt; itsLabelTableTop))</TD></TR><TR CLASS="z"><TD CLASS="l">1276</TD><TD>            throw new IllegalArgumentException(&#34;Bad label&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1277</TD><TD>        int top = itsFixupTableTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1278</TD><TD>        if (itsFixupTable == null || top == itsFixupTable.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">1279</TD><TD>            if (itsFixupTable == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1280</TD><TD>                itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];</TD></TR><TR><TD CLASS="l">1281</TD><TD>            }else {</TD></TR><TR CLASS="c"><TD CLASS="l">1282</TD><TD>                long[] tmp = new long[itsFixupTable.length * 2];</TD></TR><TR CLASS="c"><TD CLASS="l">1283</TD><TD>                System.arraycopy(itsFixupTable, 0, tmp, 0, top);</TD></TR><TR CLASS="c"><TD CLASS="l">1284</TD><TD>                itsFixupTable = tmp;</TD></TR><TR><TD CLASS="l">1285</TD><TD>            }</TD></TR><TR><TD CLASS="l">1286</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1287</TD><TD>        itsFixupTableTop = top + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">1288</TD><TD>        itsFixupTable[top] = ((long)label &lt;&lt; 32) | fixupSite;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="88">1289</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1290</TD><TD> </TD></TR><TR><TD CLASS="l">1291</TD><TD>    private  void fixLabelGotos()</TD></TR><TR><TD CLASS="l">1292</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1293</TD><TD>        byte[] codeBuffer = itsCodeBuffer;</TD></TR><TR CLASS="c"><TD CLASS="l">1294</TD><TD>        for (int i = 0; i &lt; itsFixupTableTop; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">1295</TD><TD>            long fixup = itsFixupTable[i];</TD></TR><TR CLASS="c"><TD CLASS="l">1296</TD><TD>            int label = (int)(fixup &gt;&gt; 32);</TD></TR><TR CLASS="c"><TD CLASS="l">1297</TD><TD>            int fixupSite = (int)fixup;</TD></TR><TR CLASS="c"><TD CLASS="l">1298</TD><TD>            int pc = itsLabelTable[label];</TD></TR><TR CLASS="c"><TD CLASS="l">1299</TD><TD>            if (pc == -1) {</TD></TR><TR><TD CLASS="l">1300</TD><TD>                // Unlocated label</TD></TR><TR CLASS="z"><TD CLASS="l">1301</TD><TD>                throw new RuntimeException();</TD></TR><TR><TD CLASS="l">1302</TD><TD>            }</TD></TR><TR><TD CLASS="l">1303</TD><TD>            // -1 to get delta from instruction start</TD></TR><TR CLASS="c"><TD CLASS="l">1304</TD><TD>            addSuperBlockStart(pc);</TD></TR><TR CLASS="c"><TD CLASS="l">1305</TD><TD>            itsJumpFroms.put(pc, fixupSite - 1);</TD></TR><TR CLASS="c"><TD CLASS="l">1306</TD><TD>            int offset = pc - (fixupSite - 1);</TD></TR><TR CLASS="c"><TD CLASS="l">1307</TD><TD>            if ((short)offset != offset) {</TD></TR><TR CLASS="z"><TD CLASS="l">1308</TD><TD>                throw new ClassFileFormatException</TD></TR><TR><TD CLASS="l">1309</TD><TD>                    (&#34;Program too complex: too big jump offset&#34;);</TD></TR><TR><TD CLASS="l">1310</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1311</TD><TD>            codeBuffer[fixupSite] = (byte)(offset &gt;&gt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">1312</TD><TD>            codeBuffer[fixupSite + 1] = (byte)offset;</TD></TR><TR><TD CLASS="l">1313</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1314</TD><TD>        itsFixupTableTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">1315</TD><TD>    }</TD></TR><TR><TD CLASS="l">1316</TD><TD> </TD></TR><TR><TD CLASS="l">1317</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1318</TD><TD>     * Get the current offset into the code of the current method.</TD></TR><TR><TD CLASS="l"><A NAME="a6">1319</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">1320</TD><TD>     * @return an integer representing the offset</TD></TR><TR><TD CLASS="l">1321</TD><TD>     */</TD></TR><TR><TD CLASS="l">1322</TD><TD>    public int getCurrentCodeOffset() {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="a8">1323</A></TD><TD>        return itsCodeBufferTop;</TD></TR><TR><TD CLASS="l">1324</TD><TD>    }</TD></TR><TR><TD CLASS="l">1325</TD><TD> </TD></TR><TR><TD CLASS="l">1326</TD><TD>    public short getStackTop() {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="b1">1327</A></TD><TD>        return itsStackTop;</TD></TR><TR><TD CLASS="l">1328</TD><TD>    }</TD></TR><TR><TD CLASS="l">1329</TD><TD> </TD></TR><TR><TD CLASS="l">1330</TD><TD>    public void setStackTop(short n) {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="7e">1331</A></TD><TD>        itsStackTop = n;</TD></TR><TR CLASS="c"><TD CLASS="l">1332</TD><TD>    }</TD></TR><TR><TD CLASS="l">1333</TD><TD> </TD></TR><TR><TD CLASS="l">1334</TD><TD>    public void adjustStackTop(int delta) {</TD></TR><TR CLASS="c"><TD CLASS="l">1335</TD><TD>        int newStack = itsStackTop + delta;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="83% line coverage (10 out of 12 instructions)">1336</TD><TD TITLE="83% line coverage (10 out of 12 instructions)">        if (newStack &lt; 0 || Short.MAX_VALUE &lt; newStack) badStack(newStack);</TD></TR><TR CLASS="c"><TD CLASS="l">1337</TD><TD>        itsStackTop = (short)newStack;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (8 out of 12 instructions)">1338</TD><TD TITLE="67% line coverage (8 out of 12 instructions)">        if (newStack &gt; itsMaxStack) itsMaxStack = (short)newStack;</TD></TR><TR><TD CLASS="l">1339</TD><TD>        if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">1340</TD><TD>            System.out.println(&#34;After &#34;+&#34;adjustStackTop(&#34;+delta+&#34;)&#34;</TD></TR><TR><TD CLASS="l">1341</TD><TD>                               +&#34; stack = &#34;+itsStackTop);</TD></TR><TR><TD CLASS="l">1342</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="a0">1343</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1344</TD><TD> </TD></TR><TR><TD CLASS="l">1345</TD><TD>    private void addToCodeBuffer(int b)</TD></TR><TR><TD CLASS="l">1346</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1347</TD><TD>        int N = addReservedCodeSpace(1);</TD></TR><TR CLASS="c"><TD CLASS="l">1348</TD><TD>        itsCodeBuffer[N] = (byte)b;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="a1">1349</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1350</TD><TD> </TD></TR><TR><TD CLASS="l">1351</TD><TD>    private void addToCodeInt16(int value)</TD></TR><TR><TD CLASS="l">1352</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1353</TD><TD>        int N = addReservedCodeSpace(2);</TD></TR><TR CLASS="c"><TD CLASS="l">1354</TD><TD>        putInt16(value, itsCodeBuffer, N);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="89">1355</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1356</TD><TD> </TD></TR><TR><TD CLASS="l">1357</TD><TD>    private int addReservedCodeSpace(int size)</TD></TR><TR><TD CLASS="l">1358</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1359</TD><TD>        if (itsCurrentMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>            throw new IllegalArgumentException(&#34;No method to add to&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1361</TD><TD>        int oldTop = itsCodeBufferTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1362</TD><TD>        int newTop = oldTop + size;</TD></TR><TR CLASS="c"><TD CLASS="l">1363</TD><TD>        if (newTop &gt; itsCodeBuffer.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">1364</TD><TD>            int newSize = itsCodeBuffer.length * 2;</TD></TR><TR CLASS="c"><TD CLASS="l">1365</TD><TD>            if (newTop &gt; newSize) { newSize = newTop; }</TD></TR><TR CLASS="c"><TD CLASS="l">1366</TD><TD>            byte[] tmp = new byte[newSize];</TD></TR><TR CLASS="c"><TD CLASS="l">1367</TD><TD>            System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);</TD></TR><TR CLASS="c"><TD CLASS="l">1368</TD><TD>            itsCodeBuffer = tmp;</TD></TR><TR><TD CLASS="l">1369</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1370</TD><TD>        itsCodeBufferTop = newTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1371</TD><TD>        return oldTop;</TD></TR><TR><TD CLASS="l">1372</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="81">1373</A></TD><TD> </TD></TR><TR><TD CLASS="l">1374</TD><TD>    public void addExceptionHandler(int startLabel, int endLabel,</TD></TR><TR><TD CLASS="l">1375</TD><TD>                                    int handlerLabel, String catchClassName)</TD></TR><TR><TD CLASS="l">1376</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1377</TD><TD>        if ((startLabel &amp; 0x80000000) != 0x80000000)</TD></TR><TR CLASS="z"><TD CLASS="l">1378</TD><TD>            throw new IllegalArgumentException(&#34;Bad startLabel&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1379</TD><TD>        if ((endLabel &amp; 0x80000000) != 0x80000000)</TD></TR><TR CLASS="z"><TD CLASS="l">1380</TD><TD>            throw new IllegalArgumentException(&#34;Bad endLabel&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1381</TD><TD>        if ((handlerLabel &amp; 0x80000000) != 0x80000000)</TD></TR><TR CLASS="z"><TD CLASS="l">1382</TD><TD>            throw new IllegalArgumentException(&#34;Bad handlerLabel&#34;);</TD></TR><TR><TD CLASS="l">1383</TD><TD> </TD></TR><TR><TD CLASS="l">1384</TD><TD>        /*</TD></TR><TR><TD CLASS="l">1385</TD><TD>         * If catchClassName is null, use 0 for the catch_type_index; which</TD></TR><TR><TD CLASS="l">1386</TD><TD>         * means catch everything.  (Even when the verifier has let you throw</TD></TR><TR><TD CLASS="l">1387</TD><TD>         * something other than a Throwable.)</TD></TR><TR><TD CLASS="l">1388</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">1389</TD><TD>        short catch_type_index = (catchClassName == null)</TD></TR><TR><TD CLASS="l">1390</TD><TD>                                 ? 0</TD></TR><TR><TD CLASS="l">1391</TD><TD>                                 : itsConstantPool.addClass(catchClassName);</TD></TR><TR CLASS="c"><TD CLASS="l">1392</TD><TD>        ExceptionTableEntry newEntry = new ExceptionTableEntry(</TD></TR><TR><TD CLASS="l">1393</TD><TD>                                           startLabel,</TD></TR><TR><TD CLASS="l">1394</TD><TD>                                           endLabel,</TD></TR><TR><TD CLASS="l">1395</TD><TD>                                           handlerLabel,</TD></TR><TR><TD CLASS="l">1396</TD><TD>                                           catch_type_index);</TD></TR><TR CLASS="c"><TD CLASS="l">1397</TD><TD>        int N = itsExceptionTableTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1398</TD><TD>        if (N == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">1399</TD><TD>            itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];</TD></TR><TR CLASS="c"><TD CLASS="l">1400</TD><TD>        } else if (N == itsExceptionTable.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">1401</TD><TD>            ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];</TD></TR><TR CLASS="c"><TD CLASS="l">1402</TD><TD>            System.arraycopy(itsExceptionTable, 0, tmp, 0, N);</TD></TR><TR CLASS="c"><TD CLASS="l">1403</TD><TD>            itsExceptionTable = tmp;</TD></TR><TR><TD CLASS="l">1404</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1405</TD><TD>        itsExceptionTable[N] = newEntry;</TD></TR><TR CLASS="c"><TD CLASS="l">1406</TD><TD>        itsExceptionTableTop = N + 1;</TD></TR><TR><TD CLASS="l"><A NAME="8a">1407</A></TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1408</TD><TD>    }</TD></TR><TR><TD CLASS="l">1409</TD><TD> </TD></TR><TR><TD CLASS="l">1410</TD><TD>    public void addLineNumberEntry(short lineNumber) {</TD></TR><TR CLASS="c"><TD CLASS="l">1411</TD><TD>        if (itsCurrentMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1412</TD><TD>            throw new IllegalArgumentException(&#34;No method to stop&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">1413</TD><TD>        int N = itsLineNumberTableTop;</TD></TR><TR CLASS="c"><TD CLASS="l">1414</TD><TD>        if (N == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">1415</TD><TD>            itsLineNumberTable = new int[LineNumberTableSize];</TD></TR><TR CLASS="c"><TD CLASS="l">1416</TD><TD>        } else if (N == itsLineNumberTable.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">1417</TD><TD>            int[] tmp = new int[N * 2];</TD></TR><TR CLASS="c"><TD CLASS="l">1418</TD><TD>            System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);</TD></TR><TR CLASS="c"><TD CLASS="l">1419</TD><TD>            itsLineNumberTable = tmp;</TD></TR><TR><TD CLASS="l">1420</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1421</TD><TD>        itsLineNumberTable[N] = (itsCodeBufferTop &lt;&lt; 16) + lineNumber;</TD></TR><TR CLASS="c"><TD CLASS="l">1422</TD><TD>        itsLineNumberTableTop = N + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">1423</TD><TD>    }</TD></TR><TR><TD CLASS="l">1424</TD><TD> </TD></TR><TR><TD CLASS="l">1425</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1426</TD><TD>     * A stack map table is a code attribute introduced in Java 6 that</TD></TR><TR><TD CLASS="l">1427</TD><TD>     * gives type information at key points in the method body (namely, at</TD></TR><TR><TD CLASS="l">1428</TD><TD>     * the beginning of each super block after the first). Each frame of a</TD></TR><TR><TD CLASS="l"><A NAME="2">1429</A></TD><TD>     * stack map table contains the state of local variable and operand stack</TD></TR><TR><TD CLASS="l">1430</TD><TD>     * for a given super block.</TD></TR><TR><TD CLASS="l">1431</TD><TD>     */</TD></TR><TR><TD CLASS="l">1432</TD><TD>    final class StackMapTable {</TD></TR><TR CLASS="z"><TD CLASS="l">1433</TD><TD>        StackMapTable() {</TD></TR><TR CLASS="z"><TD CLASS="l">1434</TD><TD>            superBlocks = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1435</TD><TD>            locals = stack = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>            workList = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1437</TD><TD>            rawStackMap = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1438</TD><TD>            localsTop = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>            stackTop = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>            workListTop = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1441</TD><TD>            rawStackMapTop = 0;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="f">1442</A></TD><TD>            wide = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1443</TD><TD>        }</TD></TR><TR><TD CLASS="l">1444</TD><TD> </TD></TR><TR><TD CLASS="l">1445</TD><TD>        void generate() {</TD></TR><TR CLASS="z"><TD CLASS="l">1446</TD><TD>            superBlocks = new SuperBlock[itsSuperBlockStartsTop];</TD></TR><TR CLASS="z"><TD CLASS="l">1447</TD><TD>            int[] initialLocals = createInitialLocals();</TD></TR><TR><TD CLASS="l">1448</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1449</TD><TD>            for (int i = 0; i &lt; itsSuperBlockStartsTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1450</TD><TD>                int start = itsSuperBlockStarts[i];</TD></TR><TR><TD CLASS="l">1451</TD><TD>                int end;</TD></TR><TR CLASS="z"><TD CLASS="l">1452</TD><TD>                if (i == itsSuperBlockStartsTop - 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1453</TD><TD>                    end = itsCodeBufferTop;</TD></TR><TR><TD CLASS="l">1454</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1455</TD><TD>                    end = itsSuperBlockStarts[i + 1];</TD></TR><TR><TD CLASS="l">1456</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>                superBlocks[i] = new SuperBlock(i, start, end, initialLocals);</TD></TR><TR><TD CLASS="l">1458</TD><TD>            }</TD></TR><TR><TD CLASS="l">1459</TD><TD> </TD></TR><TR><TD CLASS="l">1460</TD><TD>            if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1461</TD><TD>                System.out.println(&#34;super blocks: &#34;);</TD></TR><TR><TD CLASS="l">1462</TD><TD>                for (int i = 0;</TD></TR><TR><TD CLASS="l">1463</TD><TD>                     i &lt; superBlocks.length &amp;&amp; superBlocks[i] != null; i++) {</TD></TR><TR><TD CLASS="l">1464</TD><TD>                    System.out.println(&#34;sb &#34; + i + &#34;: [&#34; +</TD></TR><TR><TD CLASS="l">1465</TD><TD>                                       superBlocks[i].getStart() + &#34;, &#34; +</TD></TR><TR><TD CLASS="l">1466</TD><TD>                                       superBlocks[i].getEnd() + &#34;)&#34;);</TD></TR><TR><TD CLASS="l">1467</TD><TD>                }</TD></TR><TR><TD CLASS="l">1468</TD><TD>            }</TD></TR><TR><TD CLASS="l">1469</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1470</TD><TD>            superBlockDeps = getSuperBlockDependencies();</TD></TR><TR><TD CLASS="l">1471</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1472</TD><TD>            verify();</TD></TR><TR><TD CLASS="l">1473</TD><TD> </TD></TR><TR><TD CLASS="l">1474</TD><TD>            if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1475</TD><TD>                System.out.println(&#34;type information:&#34;);</TD></TR><TR><TD CLASS="l">1476</TD><TD>                for (int i = 0; i &lt; superBlocks.length; i++) {</TD></TR><TR><TD CLASS="l">1477</TD><TD>                    SuperBlock sb = superBlocks[i];</TD></TR><TR><TD CLASS="l">1478</TD><TD>                    System.out.println(&#34;sb &#34; + i + &#34;:&#34;);</TD></TR><TR><TD CLASS="l">1479</TD><TD>                    TypeInfo.print(sb.getLocals(), sb.getStack(),</TD></TR><TR><TD CLASS="l">1480</TD><TD>                                   itsConstantPool);</TD></TR><TR><TD CLASS="l">1481</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="15">1482</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1483</TD><TD>        }</TD></TR><TR><TD CLASS="l">1484</TD><TD> </TD></TR><TR><TD CLASS="l">1485</TD><TD>        private SuperBlock getSuperBlockFromOffset(int offset) {</TD></TR><TR CLASS="z"><TD CLASS="l">1486</TD><TD>            for (int i = 0; i &lt; superBlocks.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1487</TD><TD>                SuperBlock sb = superBlocks[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1488</TD><TD>                if (sb == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1489</TD><TD>                    break;</TD></TR><TR CLASS="z"><TD CLASS="l">1490</TD><TD>                } else if (offset &gt;= sb.getStart() &amp;&amp; offset &lt; sb.getEnd()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1491</TD><TD>                    return sb;</TD></TR><TR><TD CLASS="l">1492</TD><TD>                }</TD></TR><TR><TD CLASS="l">1493</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1494</TD><TD>            throw new IllegalArgumentException(&#34;bad offset: &#34; + offset);</TD></TR><TR><TD CLASS="l">1495</TD><TD>        }</TD></TR><TR><TD CLASS="l">1496</TD><TD> </TD></TR><TR><TD CLASS="l">1497</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="1a">1498</A></TD><TD>         * Determine whether or not an opcode is an actual end to a super</TD></TR><TR><TD CLASS="l">1499</TD><TD>         * block. This includes any returns or unconditional jumps.</TD></TR><TR><TD CLASS="l">1500</TD><TD>         */</TD></TR><TR><TD CLASS="l">1501</TD><TD>        private boolean isSuperBlockEnd(int opcode) {</TD></TR><TR CLASS="z"><TD CLASS="l">1502</TD><TD>            switch (opcode) {</TD></TR><TR><TD CLASS="l">1503</TD><TD>                case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">1504</TD><TD>                case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">1505</TD><TD>                case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">1506</TD><TD>                case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">1507</TD><TD>                case ByteCode.RETURN:</TD></TR><TR><TD CLASS="l">1508</TD><TD>                case ByteCode.ATHROW:</TD></TR><TR><TD CLASS="l">1509</TD><TD>                case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">1510</TD><TD>                case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">1511</TD><TD>                case ByteCode.TABLESWITCH:</TD></TR><TR><TD CLASS="l">1512</TD><TD>                case ByteCode.LOOKUPSWITCH:</TD></TR><TR CLASS="z"><TD CLASS="l">1513</TD><TD>                    return true;</TD></TR><TR><TD CLASS="l">1514</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">1515</TD><TD>                    return false;</TD></TR><TR><TD CLASS="l">1516</TD><TD>            }</TD></TR><TR><TD CLASS="l">1517</TD><TD>        }</TD></TR><TR><TD CLASS="l">1518</TD><TD> </TD></TR><TR><TD CLASS="l">1519</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1520</TD><TD>         * Calculate partial dependencies for super blocks.</TD></TR><TR><TD CLASS="l">1521</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="14">1522</A></TD><TD>         * This is used as a workaround for dead code that is generated. Only</TD></TR><TR><TD CLASS="l">1523</TD><TD>         * one dependency per super block is given.</TD></TR><TR><TD CLASS="l">1524</TD><TD>         */</TD></TR><TR><TD CLASS="l">1525</TD><TD>        private SuperBlock[] getSuperBlockDependencies() {</TD></TR><TR CLASS="z"><TD CLASS="l">1526</TD><TD>            SuperBlock[] deps = new SuperBlock[superBlocks.length];</TD></TR><TR><TD CLASS="l">1527</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1528</TD><TD>            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1529</TD><TD>                ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1530</TD><TD>                short startPC = (short) getLabelPC(ete.itsStartLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1531</TD><TD>                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1532</TD><TD>                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);</TD></TR><TR CLASS="z"><TD CLASS="l">1533</TD><TD>                SuperBlock dep = getSuperBlockFromOffset(startPC);</TD></TR><TR CLASS="z"><TD CLASS="l">1534</TD><TD>                deps[handlerSB.getIndex()] = dep;</TD></TR><TR><TD CLASS="l">1535</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1536</TD><TD>            int[] targetPCs = itsJumpFroms.getKeys();</TD></TR><TR CLASS="z"><TD CLASS="l">1537</TD><TD>            for (int i = 0; i &lt; targetPCs.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1538</TD><TD>                int targetPC = targetPCs[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1539</TD><TD>                int branchPC = itsJumpFroms.getInt(targetPC, -1);</TD></TR><TR CLASS="z"><TD CLASS="l">1540</TD><TD>                SuperBlock branchSB = getSuperBlockFromOffset(branchPC);</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>                SuperBlock targetSB = getSuperBlockFromOffset(targetPC);</TD></TR><TR CLASS="z"><TD CLASS="l">1542</TD><TD>                deps[targetSB.getIndex()] = branchSB;</TD></TR><TR><TD CLASS="l">1543</TD><TD>            }</TD></TR><TR><TD CLASS="l">1544</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1545</TD><TD>            return deps;</TD></TR><TR><TD CLASS="l">1546</TD><TD>        }</TD></TR><TR><TD CLASS="l">1547</TD><TD> </TD></TR><TR><TD CLASS="l">1548</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1549</TD><TD>         * Get the target super block of a branch instruction.</TD></TR><TR><TD CLASS="l">1550</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="10">1551</A></TD><TD>         * @param bci the index of the branch instruction in the code buffer</TD></TR><TR><TD CLASS="l">1552</TD><TD>         */</TD></TR><TR><TD CLASS="l">1553</TD><TD>        private SuperBlock getBranchTarget(int bci) {</TD></TR><TR><TD CLASS="l">1554</TD><TD>            int target;</TD></TR><TR CLASS="z"><TD CLASS="l">1555</TD><TD>            if ((itsCodeBuffer[bci] &amp; 0xFF) == ByteCode.GOTO_W) {</TD></TR><TR CLASS="z"><TD CLASS="l">1556</TD><TD>                target = bci + getOperand(bci + 1, 4);</TD></TR><TR><TD CLASS="l">1557</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1558</TD><TD>                target = bci + (short) getOperand(bci + 1, 2);</TD></TR><TR><TD CLASS="l">1559</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1560</TD><TD>            return getSuperBlockFromOffset(target);</TD></TR><TR><TD CLASS="l">1561</TD><TD>        }</TD></TR><TR><TD CLASS="l">1562</TD><TD> </TD></TR><TR><TD CLASS="l">1563</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="19">1564</A></TD><TD>         * Determine whether or not an opcode is a conditional or unconditional</TD></TR><TR><TD CLASS="l">1565</TD><TD>         * jump.</TD></TR><TR><TD CLASS="l">1566</TD><TD>         */</TD></TR><TR><TD CLASS="l">1567</TD><TD>        private boolean isBranch(int opcode) {</TD></TR><TR CLASS="z"><TD CLASS="l">1568</TD><TD>            switch (opcode) {</TD></TR><TR><TD CLASS="l">1569</TD><TD>                case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">1570</TD><TD>                case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">1571</TD><TD>                case ByteCode.IFEQ:</TD></TR><TR><TD CLASS="l">1572</TD><TD>                case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">1573</TD><TD>                case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">1574</TD><TD>                case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">1575</TD><TD>                case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">1576</TD><TD>                case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">1577</TD><TD>                case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">1578</TD><TD>                case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">1579</TD><TD>                case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">1580</TD><TD>                case ByteCode.IF_ACMPNE:</TD></TR><TR><TD CLASS="l">1581</TD><TD>                case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">1582</TD><TD>                case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">1583</TD><TD>                case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">1584</TD><TD>                case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">1585</TD><TD>                case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">1586</TD><TD>                case ByteCode.IF_ICMPNE:</TD></TR><TR CLASS="z"><TD CLASS="l">1587</TD><TD>                    return true;</TD></TR><TR><TD CLASS="l">1588</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">1589</TD><TD>                    return false;</TD></TR><TR><TD CLASS="l"><A NAME="12">1590</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">1591</TD><TD>        }</TD></TR><TR><TD CLASS="l">1592</TD><TD> </TD></TR><TR><TD CLASS="l">1593</TD><TD>        private int getOperand(int offset) {</TD></TR><TR CLASS="z"><TD CLASS="l">1594</TD><TD>            return getOperand(offset, 1);</TD></TR><TR><TD CLASS="l">1595</TD><TD>        }</TD></TR><TR><TD CLASS="l">1596</TD><TD> </TD></TR><TR><TD CLASS="l">1597</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1598</TD><TD>         * Extract a logical operand from the byte code.</TD></TR><TR><TD CLASS="l"><A NAME="13">1599</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">1600</TD><TD>         * This is used, for example, to get branch offsets.</TD></TR><TR><TD CLASS="l">1601</TD><TD>         */</TD></TR><TR><TD CLASS="l">1602</TD><TD>        private int getOperand(int start, int size) {</TD></TR><TR CLASS="z"><TD CLASS="l">1603</TD><TD>            int result = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1604</TD><TD>            if (size &gt; 4) {</TD></TR><TR CLASS="z"><TD CLASS="l">1605</TD><TD>                throw new IllegalArgumentException(&#34;bad operand size&#34;);</TD></TR><TR><TD CLASS="l">1606</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1607</TD><TD>            for (int i = 0; i &lt; size; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1608</TD><TD>                result = (result &lt;&lt; 8) | (itsCodeBuffer[start + i] &amp; 0xFF);</TD></TR><TR><TD CLASS="l">1609</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1610</TD><TD>            return result;</TD></TR><TR><TD CLASS="l">1611</TD><TD>        }</TD></TR><TR><TD CLASS="l">1612</TD><TD> </TD></TR><TR><TD CLASS="l">1613</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="21">1614</A></TD><TD>         * Calculate initial local variable and op stack types for each super</TD></TR><TR><TD CLASS="l">1615</TD><TD>         * block in the method.</TD></TR><TR><TD CLASS="l">1616</TD><TD>         */</TD></TR><TR><TD CLASS="l">1617</TD><TD>        private void verify() {</TD></TR><TR CLASS="z"><TD CLASS="l">1618</TD><TD>            int[] initialLocals = createInitialLocals();</TD></TR><TR CLASS="z"><TD CLASS="l">1619</TD><TD>            superBlocks[0].merge(initialLocals, initialLocals.length,</TD></TR><TR><TD CLASS="l">1620</TD><TD>                                 new int[0], 0, itsConstantPool);</TD></TR><TR><TD CLASS="l">1621</TD><TD> </TD></TR><TR><TD CLASS="l">1622</TD><TD>            // Start from the top of the method and queue up block dependencies</TD></TR><TR><TD CLASS="l">1623</TD><TD>            // as they come along.</TD></TR><TR CLASS="z"><TD CLASS="l">1624</TD><TD>            workList = new SuperBlock[] { superBlocks[0] };</TD></TR><TR CLASS="z"><TD CLASS="l">1625</TD><TD>            workListTop = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1626</TD><TD>            executeWorkList();</TD></TR><TR><TD CLASS="l">1627</TD><TD> </TD></TR><TR><TD CLASS="l">1628</TD><TD>            // Replace dead code with no-ops.</TD></TR><TR CLASS="z"><TD CLASS="l">1629</TD><TD>            for (int i = 0; i &lt; superBlocks.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1630</TD><TD>                SuperBlock sb = superBlocks[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1631</TD><TD>                if (!sb.isInitialized()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1632</TD><TD>                    killSuperBlock(sb);</TD></TR><TR><TD CLASS="l">1633</TD><TD>                }</TD></TR><TR><TD CLASS="l">1634</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1635</TD><TD>            executeWorkList();</TD></TR><TR CLASS="z"><TD CLASS="l">1636</TD><TD>        }</TD></TR><TR><TD CLASS="l">1637</TD><TD> </TD></TR><TR><TD CLASS="l">1638</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1639</TD><TD>         * Replace the contents of a super block with no-ops.</TD></TR><TR><TD CLASS="l">1640</TD><TD>         *</TD></TR><TR><TD CLASS="l">1641</TD><TD>         * The above description is not strictly true; the last instruction is</TD></TR><TR><TD CLASS="l">1642</TD><TD>         * an athrow instruction. This technique is borrowed from ASM's</TD></TR><TR><TD CLASS="l">1643</TD><TD>         * developer guide: http://asm.ow2.org/doc/developer-guide.html#deadcode</TD></TR><TR><TD CLASS="l">1644</TD><TD>         *</TD></TR><TR><TD CLASS="l">1645</TD><TD>         * The proposed algorithm fills a block with nop, ending it with an</TD></TR><TR><TD CLASS="l">1646</TD><TD>         * athrow. The stack map generated would be empty locals with an</TD></TR><TR><TD CLASS="l">1647</TD><TD>         * exception on the stack. In theory, it shouldn't matter what the</TD></TR><TR><TD CLASS="l">1648</TD><TD>         * locals are, as long as the stack has an exception for the athrow bit.</TD></TR><TR><TD CLASS="l">1649</TD><TD>         * However, it turns out that if the code being modified falls into an</TD></TR><TR><TD CLASS="l">1650</TD><TD>         * exception handler, it causes problems. Therefore, if it does, then</TD></TR><TR><TD CLASS="l">1651</TD><TD>         * we steal the locals from the exception block.</TD></TR><TR><TD CLASS="l">1652</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="1b">1653</A></TD><TD>         * If the block itself is an exception handler, we remove it from the</TD></TR><TR><TD CLASS="l">1654</TD><TD>         * exception table to simplify block dependencies.</TD></TR><TR><TD CLASS="l">1655</TD><TD>         */</TD></TR><TR><TD CLASS="l">1656</TD><TD>        private void killSuperBlock(SuperBlock sb) {</TD></TR><TR CLASS="z"><TD CLASS="l">1657</TD><TD>            int[] locals = new int[0];</TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>            int[] stack = new int[] { TypeInfo.OBJECT(&#34;java/lang/Throwable&#34;,</TD></TR><TR><TD CLASS="l">1659</TD><TD>                                                      itsConstantPool) };</TD></TR><TR><TD CLASS="l">1660</TD><TD> </TD></TR><TR><TD CLASS="l">1661</TD><TD>            // If the super block is handled by any exception handler, use its</TD></TR><TR><TD CLASS="l">1662</TD><TD>            // locals as the killed block's locals. Ignore uninitialized</TD></TR><TR><TD CLASS="l">1663</TD><TD>            // handlers, because they will also be killed and removed from the</TD></TR><TR><TD CLASS="l">1664</TD><TD>            // exception table.</TD></TR><TR CLASS="z"><TD CLASS="l">1665</TD><TD>            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1666</TD><TD>                ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1667</TD><TD>                int eteStart = getLabelPC(ete.itsStartLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1668</TD><TD>                int eteEnd = getLabelPC(ete.itsEndLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1669</TD><TD>                int handlerPC = getLabelPC(ete.itsHandlerLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1670</TD><TD>                SuperBlock handlerSB = getSuperBlockFromOffset(handlerPC);</TD></TR><TR CLASS="z"><TD CLASS="l">1671</TD><TD>                if ((sb.getStart() &gt; eteStart &amp;&amp; sb.getStart() &lt; eteEnd) ||</TD></TR><TR><TD CLASS="l">1672</TD><TD>                    (eteStart &gt; sb.getStart() &amp;&amp; eteStart &lt; sb.getEnd()) &amp;&amp;</TD></TR><TR><TD CLASS="l">1673</TD><TD>                    handlerSB.isInitialized()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1674</TD><TD>                    locals = handlerSB.getLocals();</TD></TR><TR CLASS="z"><TD CLASS="l">1675</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1676</TD><TD>                }</TD></TR><TR><TD CLASS="l">1677</TD><TD>            }</TD></TR><TR><TD CLASS="l">1678</TD><TD> </TD></TR><TR><TD CLASS="l">1679</TD><TD>            // Remove any exception table entry whose handler is the killed</TD></TR><TR><TD CLASS="l">1680</TD><TD>            // block. This removes block dependencies to make stack maps for</TD></TR><TR><TD CLASS="l">1681</TD><TD>            // dead blocks easier to create.</TD></TR><TR CLASS="z"><TD CLASS="l">1682</TD><TD>            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1683</TD><TD>                ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1684</TD><TD>                int eteStart = getLabelPC(ete.itsStartLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1685</TD><TD>                if (eteStart == sb.getStart()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1686</TD><TD>                    for (int j = i + 1; j &lt; itsExceptionTableTop; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1687</TD><TD>                        itsExceptionTable[j - 1] = itsExceptionTable[j];</TD></TR><TR><TD CLASS="l">1688</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1689</TD><TD>                    itsExceptionTableTop--;</TD></TR><TR CLASS="z"><TD CLASS="l">1690</TD><TD>                    i--;</TD></TR><TR><TD CLASS="l">1691</TD><TD>                }</TD></TR><TR><TD CLASS="l">1692</TD><TD>            }</TD></TR><TR><TD CLASS="l">1693</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1694</TD><TD>            sb.merge(locals, locals.length, stack, stack.length,</TD></TR><TR><TD CLASS="l">1695</TD><TD>                     itsConstantPool);</TD></TR><TR><TD CLASS="l">1696</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1697</TD><TD>            int end = sb.getEnd() - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1698</TD><TD>            itsCodeBuffer[end] = (byte) ByteCode.ATHROW;</TD></TR><TR CLASS="z"><TD CLASS="l">1699</TD><TD>            for (int bci = sb.getStart(); bci &lt; end; bci++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1700</TD><TD>                itsCodeBuffer[bci] = (byte) ByteCode.NOP;</TD></TR><TR><TD CLASS="l"><A NAME="d">1701</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1702</TD><TD>        }</TD></TR><TR><TD CLASS="l">1703</TD><TD> </TD></TR><TR><TD CLASS="l">1704</TD><TD>        private void executeWorkList() {</TD></TR><TR CLASS="z"><TD CLASS="l">1705</TD><TD>            while (workListTop &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1706</TD><TD>                SuperBlock work = workList[--workListTop];</TD></TR><TR CLASS="z"><TD CLASS="l">1707</TD><TD>                work.setInQueue(false);</TD></TR><TR CLASS="z"><TD CLASS="l">1708</TD><TD>                locals = work.getLocals();</TD></TR><TR CLASS="z"><TD CLASS="l">1709</TD><TD>                stack = work.getStack();</TD></TR><TR CLASS="z"><TD CLASS="l">1710</TD><TD>                localsTop = locals.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1711</TD><TD>                stackTop = stack.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1712</TD><TD>                executeBlock(work);</TD></TR><TR CLASS="z"><TD CLASS="l">1713</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>        }</TD></TR><TR><TD CLASS="l">1715</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="b">1716</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1717</TD><TD>         * Simulate the local variable and op stack for a super block.</TD></TR><TR><TD CLASS="l">1718</TD><TD>         */</TD></TR><TR><TD CLASS="l">1719</TD><TD>        private void executeBlock(SuperBlock work) {</TD></TR><TR CLASS="z"><TD CLASS="l">1720</TD><TD>            int bc = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>            int next = 0;</TD></TR><TR><TD CLASS="l">1722</TD><TD> </TD></TR><TR><TD CLASS="l">1723</TD><TD>            if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1724</TD><TD>                System.out.println(&#34;working on sb &#34; + work.getIndex());</TD></TR><TR><TD CLASS="l">1725</TD><TD>                System.out.println(&#34;initial type state:&#34;);</TD></TR><TR><TD CLASS="l">1726</TD><TD>                TypeInfo.print(locals, localsTop, stack, stackTop,</TD></TR><TR><TD CLASS="l">1727</TD><TD>                               itsConstantPool);</TD></TR><TR><TD CLASS="l">1728</TD><TD>            }</TD></TR><TR><TD CLASS="l">1729</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1730</TD><TD>            for (int bci = work.getStart(); bci &lt; work.getEnd(); bci += next) {</TD></TR><TR CLASS="z"><TD CLASS="l">1731</TD><TD>                bc = itsCodeBuffer[bci] &amp; 0xFF;</TD></TR><TR CLASS="z"><TD CLASS="l">1732</TD><TD>                next = execute(bci);</TD></TR><TR><TD CLASS="l">1733</TD><TD> </TD></TR><TR><TD CLASS="l">1734</TD><TD>                // If we have a branch to some super block, we need to merge</TD></TR><TR><TD CLASS="l">1735</TD><TD>                // the current state of the local table and op stack with what's</TD></TR><TR><TD CLASS="l">1736</TD><TD>                // currently stored as the initial state of the super block. If</TD></TR><TR><TD CLASS="l">1737</TD><TD>                // something actually changed, we need to add it to the work</TD></TR><TR><TD CLASS="l">1738</TD><TD>                // list.</TD></TR><TR CLASS="z"><TD CLASS="l">1739</TD><TD>                if (isBranch(bc)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1740</TD><TD>                    SuperBlock targetSB = getBranchTarget(bci);</TD></TR><TR><TD CLASS="l">1741</TD><TD>                    if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1742</TD><TD>                        System.out.println(&#34;sb &#34; + work.getIndex() +</TD></TR><TR><TD CLASS="l">1743</TD><TD>                                           &#34; points to sb &#34; +</TD></TR><TR><TD CLASS="l">1744</TD><TD>                                           targetSB.getIndex() +</TD></TR><TR><TD CLASS="l">1745</TD><TD>                                           &#34; (offset &#34; + bci + &#34; -&gt; &#34; +</TD></TR><TR><TD CLASS="l">1746</TD><TD>                                           targetSB.getStart() + &#34;)&#34;);</TD></TR><TR><TD CLASS="l">1747</TD><TD>                        System.out.println(&#34;type state at &#34; + bci + &#34;:&#34;);</TD></TR><TR><TD CLASS="l">1748</TD><TD>                        TypeInfo.print(locals, localsTop, stack, stackTop,</TD></TR><TR><TD CLASS="l">1749</TD><TD>                                       itsConstantPool);</TD></TR><TR><TD CLASS="l">1750</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1751</TD><TD>                    flowInto(targetSB);</TD></TR><TR><TD CLASS="l">1752</TD><TD>                    if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1753</TD><TD>                        System.out.println(&#34;type state of &#34; + targetSB +</TD></TR><TR><TD CLASS="l">1754</TD><TD>                                           &#34; after merge:&#34;);</TD></TR><TR><TD CLASS="l">1755</TD><TD>                        TypeInfo.print(targetSB.getLocals(),</TD></TR><TR><TD CLASS="l">1756</TD><TD>                                       targetSB.getStack(), itsConstantPool);</TD></TR><TR><TD CLASS="l">1757</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1758</TD><TD>                } else if (bc == ByteCode.TABLESWITCH) {</TD></TR><TR CLASS="z"><TD CLASS="l">1759</TD><TD>                    int switchStart = bci + 1 + (3 &amp; ~bci); // 3 - bci % 4</TD></TR><TR CLASS="z"><TD CLASS="l">1760</TD><TD>                    int defaultOffset = getOperand(switchStart, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">1761</TD><TD>                    SuperBlock targetSB =</TD></TR><TR><TD CLASS="l">1762</TD><TD>                            getSuperBlockFromOffset(bci + defaultOffset);</TD></TR><TR><TD CLASS="l">1763</TD><TD>                    if (DEBUGSTACK) {</TD></TR><TR><TD CLASS="l">1764</TD><TD>                        System.out.println(&#34;merging sb &#34; + work.getIndex() +</TD></TR><TR><TD CLASS="l">1765</TD><TD>                                           &#34; with sb &#34; + targetSB.getIndex());</TD></TR><TR><TD CLASS="l">1766</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1767</TD><TD>                    flowInto(targetSB);</TD></TR><TR CLASS="z"><TD CLASS="l">1768</TD><TD>                    int low = getOperand(switchStart + 4, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">1769</TD><TD>                    int high = getOperand(switchStart + 8, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">1770</TD><TD>                    int numCases = high - low + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1771</TD><TD>                    int caseBase = switchStart + 12;</TD></TR><TR CLASS="z"><TD CLASS="l">1772</TD><TD>                    for (int i = 0; i &lt; numCases; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1773</TD><TD>                        int label = bci + getOperand(caseBase + 4 * i, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">1774</TD><TD>                        targetSB = getSuperBlockFromOffset(label);</TD></TR><TR><TD CLASS="l">1775</TD><TD>                        if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1776</TD><TD>                            System.out.println(&#34;merging sb &#34; +</TD></TR><TR><TD CLASS="l">1777</TD><TD>                                               work.getIndex() + &#34; with sb &#34; +</TD></TR><TR><TD CLASS="l">1778</TD><TD>                                               targetSB.getIndex());</TD></TR><TR><TD CLASS="l">1779</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1780</TD><TD>                        flowInto(targetSB);</TD></TR><TR><TD CLASS="l">1781</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1782</TD><TD>                }</TD></TR><TR><TD CLASS="l">1783</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1784</TD><TD>                for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1785</TD><TD>                    ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1786</TD><TD>                    short startPC = (short) getLabelPC(ete.itsStartLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1787</TD><TD>                    short endPC = (short) getLabelPC(ete.itsEndLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1788</TD><TD>                    if (bci &lt; startPC || bci &gt;= endPC) {</TD></TR><TR CLASS="z"><TD CLASS="l">1789</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">1790</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1791</TD><TD>                    short handlerPC =</TD></TR><TR><TD CLASS="l">1792</TD><TD>                            (short) getLabelPC(ete.itsHandlerLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">1793</TD><TD>                    SuperBlock sb = getSuperBlockFromOffset(handlerPC);</TD></TR><TR><TD CLASS="l">1794</TD><TD>                    int exceptionType;</TD></TR><TR><TD CLASS="l">1795</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1796</TD><TD>                    if (ete.itsCatchType == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1797</TD><TD>                        exceptionType = TypeInfo.OBJECT(</TD></TR><TR><TD CLASS="l">1798</TD><TD>                            itsConstantPool.addClass(&#34;java/lang/Throwable&#34;));</TD></TR><TR><TD CLASS="l">1799</TD><TD>                    } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1800</TD><TD>                        exceptionType = TypeInfo.OBJECT(ete.itsCatchType);</TD></TR><TR><TD CLASS="l">1801</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1802</TD><TD>                    sb.merge(locals, localsTop, new int[] { exceptionType }, 1,</TD></TR><TR><TD CLASS="l">1803</TD><TD>                             itsConstantPool);</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>                    addToWorkList(sb);</TD></TR><TR><TD CLASS="l">1805</TD><TD>                }</TD></TR><TR><TD CLASS="l">1806</TD><TD>            }</TD></TR><TR><TD CLASS="l">1807</TD><TD> </TD></TR><TR><TD CLASS="l">1808</TD><TD>            if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1809</TD><TD>                System.out.println(&#34;end of sb &#34; + work.getIndex() + &#34;:&#34;);</TD></TR><TR><TD CLASS="l">1810</TD><TD>                TypeInfo.print(locals, localsTop, stack, stackTop,</TD></TR><TR><TD CLASS="l">1811</TD><TD>                               itsConstantPool);</TD></TR><TR><TD CLASS="l">1812</TD><TD>            }</TD></TR><TR><TD CLASS="l">1813</TD><TD> </TD></TR><TR><TD CLASS="l">1814</TD><TD>            // Check the last instruction to see if it is a true end of a</TD></TR><TR><TD CLASS="l">1815</TD><TD>            // super block (ie., if the instruction is a return). If it</TD></TR><TR><TD CLASS="l">1816</TD><TD>            // isn't, we need to continue processing the next chunk.</TD></TR><TR CLASS="z"><TD CLASS="l">1817</TD><TD>            if (!isSuperBlockEnd(bc)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1818</TD><TD>                int nextIndex = work.getIndex() + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1819</TD><TD>                if (nextIndex &lt; superBlocks.length) {</TD></TR><TR><TD CLASS="l">1820</TD><TD>                    if (DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">1821</TD><TD>                        System.out.println(&#34;continuing from sb &#34; +</TD></TR><TR><TD CLASS="l">1822</TD><TD>                                           work.getIndex() + &#34; into sb &#34; +</TD></TR><TR><TD CLASS="l">1823</TD><TD>                                           nextIndex);</TD></TR><TR><TD CLASS="l">1824</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>                    flowInto(superBlocks[nextIndex]);</TD></TR><TR><TD CLASS="l">1826</TD><TD>                }</TD></TR><TR><TD CLASS="l">1827</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1828</TD><TD>        }</TD></TR><TR><TD CLASS="l">1829</TD><TD> </TD></TR><TR><TD CLASS="l">1830</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="e">1831</A></TD><TD>         * Perform a merge of type state and add the super block to the work</TD></TR><TR><TD CLASS="l">1832</TD><TD>         * list if the merge changed anything.</TD></TR><TR><TD CLASS="l">1833</TD><TD>         */</TD></TR><TR><TD CLASS="l">1834</TD><TD>        private void flowInto(SuperBlock sb) {</TD></TR><TR CLASS="z"><TD CLASS="l">1835</TD><TD>            if (sb.merge(locals, localsTop, stack, stackTop, itsConstantPool)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1836</TD><TD>                addToWorkList(sb);</TD></TR><TR><TD CLASS="l"><A NAME="4">1837</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1838</TD><TD>        }</TD></TR><TR><TD CLASS="l">1839</TD><TD> </TD></TR><TR><TD CLASS="l">1840</TD><TD>        private void addToWorkList(SuperBlock sb) {</TD></TR><TR CLASS="z"><TD CLASS="l">1841</TD><TD>            if (!sb.isInQueue()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1842</TD><TD>                sb.setInQueue(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1843</TD><TD>                sb.setInitialized(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1844</TD><TD>                if (workListTop == workList.length) {</TD></TR><TR CLASS="z"><TD CLASS="l">1845</TD><TD>                    SuperBlock[] tmp = new SuperBlock[workListTop * 2];</TD></TR><TR CLASS="z"><TD CLASS="l">1846</TD><TD>                    System.arraycopy(workList, 0, tmp, 0, workListTop);</TD></TR><TR CLASS="z"><TD CLASS="l">1847</TD><TD>                    workList = tmp;</TD></TR><TR><TD CLASS="l">1848</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1849</TD><TD>                workList[workListTop++] = sb;</TD></TR><TR><TD CLASS="l">1850</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1851</TD><TD>        }</TD></TR><TR><TD CLASS="l">1852</TD><TD> </TD></TR><TR><TD CLASS="l">1853</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1854</TD><TD>         * Execute a single byte code instruction.</TD></TR><TR><TD CLASS="l">1855</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="8">1856</A></TD><TD>         * @param bci the index of the byte code instruction to execute</TD></TR><TR><TD CLASS="l">1857</TD><TD>         * @return the length of the byte code instruction</TD></TR><TR><TD CLASS="l">1858</TD><TD>         */</TD></TR><TR><TD CLASS="l">1859</TD><TD>        private int execute(int bci) {</TD></TR><TR CLASS="z"><TD CLASS="l">1860</TD><TD>            int bc = itsCodeBuffer[bci] &amp; 0xFF;</TD></TR><TR><TD CLASS="l">1861</TD><TD>            int type, type2, index;</TD></TR><TR CLASS="z"><TD CLASS="l">1862</TD><TD>            int length = 0;</TD></TR><TR><TD CLASS="l">1863</TD><TD>            long lType, lType2;</TD></TR><TR><TD CLASS="l">1864</TD><TD>            String className;</TD></TR><TR><TD CLASS="l">1865</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1866</TD><TD>            switch (bc) {</TD></TR><TR><TD CLASS="l">1867</TD><TD>                case ByteCode.NOP:</TD></TR><TR><TD CLASS="l">1868</TD><TD>                case ByteCode.IINC:</TD></TR><TR><TD CLASS="l">1869</TD><TD>                case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">1870</TD><TD>                case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">1871</TD><TD>                    // No change</TD></TR><TR CLASS="z"><TD CLASS="l">1872</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1873</TD><TD>                case ByteCode.CHECKCAST:</TD></TR><TR CLASS="z"><TD CLASS="l">1874</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">1875</TD><TD>                    push(TypeInfo.OBJECT(getOperand(bci + 1, 2)));</TD></TR><TR CLASS="z"><TD CLASS="l">1876</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1877</TD><TD>                case ByteCode.IASTORE: // pop; pop; pop</TD></TR><TR><TD CLASS="l">1878</TD><TD>                case ByteCode.LASTORE:</TD></TR><TR><TD CLASS="l">1879</TD><TD>                case ByteCode.FASTORE:</TD></TR><TR><TD CLASS="l">1880</TD><TD>                case ByteCode.DASTORE:</TD></TR><TR><TD CLASS="l">1881</TD><TD>                case ByteCode.AASTORE:</TD></TR><TR><TD CLASS="l">1882</TD><TD>                case ByteCode.BASTORE:</TD></TR><TR><TD CLASS="l">1883</TD><TD>                case ByteCode.CASTORE:</TD></TR><TR><TD CLASS="l">1884</TD><TD>                case ByteCode.SASTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">1885</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1886</TD><TD>                case ByteCode.PUTFIELD: // pop; pop</TD></TR><TR><TD CLASS="l">1887</TD><TD>                case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">1888</TD><TD>                case ByteCode.IF_ICMPNE:</TD></TR><TR><TD CLASS="l">1889</TD><TD>                case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">1890</TD><TD>                case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">1891</TD><TD>                case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">1892</TD><TD>                case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">1893</TD><TD>                case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">1894</TD><TD>                case ByteCode.IF_ACMPNE:</TD></TR><TR CLASS="z"><TD CLASS="l">1895</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1896</TD><TD>                case ByteCode.IFEQ: // pop</TD></TR><TR><TD CLASS="l">1897</TD><TD>                case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">1898</TD><TD>                case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">1899</TD><TD>                case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">1900</TD><TD>                case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">1901</TD><TD>                case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">1902</TD><TD>                case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">1903</TD><TD>                case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">1904</TD><TD>                case ByteCode.POP:</TD></TR><TR><TD CLASS="l">1905</TD><TD>                case ByteCode.MONITORENTER:</TD></TR><TR><TD CLASS="l">1906</TD><TD>                case ByteCode.MONITOREXIT:</TD></TR><TR><TD CLASS="l">1907</TD><TD>                case ByteCode.PUTSTATIC:</TD></TR><TR CLASS="z"><TD CLASS="l">1908</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1910</TD><TD>                case ByteCode.POP2:</TD></TR><TR CLASS="z"><TD CLASS="l">1911</TD><TD>                    pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">1912</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1913</TD><TD>                case ByteCode.ACONST_NULL:</TD></TR><TR CLASS="z"><TD CLASS="l">1914</TD><TD>                    push(TypeInfo.NULL);</TD></TR><TR CLASS="z"><TD CLASS="l">1915</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1916</TD><TD>                case ByteCode.IALOAD: // pop; pop; push(INTEGER)</TD></TR><TR><TD CLASS="l">1917</TD><TD>                case ByteCode.BALOAD:</TD></TR><TR><TD CLASS="l">1918</TD><TD>                case ByteCode.CALOAD:</TD></TR><TR><TD CLASS="l">1919</TD><TD>                case ByteCode.SALOAD:</TD></TR><TR><TD CLASS="l">1920</TD><TD>                case ByteCode.IADD:</TD></TR><TR><TD CLASS="l">1921</TD><TD>                case ByteCode.ISUB:</TD></TR><TR><TD CLASS="l">1922</TD><TD>                case ByteCode.IMUL:</TD></TR><TR><TD CLASS="l">1923</TD><TD>                case ByteCode.IDIV:</TD></TR><TR><TD CLASS="l">1924</TD><TD>                case ByteCode.IREM:</TD></TR><TR><TD CLASS="l">1925</TD><TD>                case ByteCode.ISHL:</TD></TR><TR><TD CLASS="l">1926</TD><TD>                case ByteCode.ISHR:</TD></TR><TR><TD CLASS="l">1927</TD><TD>                case ByteCode.IUSHR:</TD></TR><TR><TD CLASS="l">1928</TD><TD>                case ByteCode.IAND:</TD></TR><TR><TD CLASS="l">1929</TD><TD>                case ByteCode.IOR:</TD></TR><TR><TD CLASS="l">1930</TD><TD>                case ByteCode.IXOR:</TD></TR><TR><TD CLASS="l">1931</TD><TD>                case ByteCode.LCMP:</TD></TR><TR><TD CLASS="l">1932</TD><TD>                case ByteCode.FCMPL:</TD></TR><TR><TD CLASS="l">1933</TD><TD>                case ByteCode.FCMPG:</TD></TR><TR><TD CLASS="l">1934</TD><TD>                case ByteCode.DCMPL:</TD></TR><TR><TD CLASS="l">1935</TD><TD>                case ByteCode.DCMPG:</TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1937</TD><TD>                case ByteCode.INEG: // pop; push(INTEGER)</TD></TR><TR><TD CLASS="l">1938</TD><TD>                case ByteCode.L2I:</TD></TR><TR><TD CLASS="l">1939</TD><TD>                case ByteCode.F2I:</TD></TR><TR><TD CLASS="l">1940</TD><TD>                case ByteCode.D2I:</TD></TR><TR><TD CLASS="l">1941</TD><TD>                case ByteCode.I2B:</TD></TR><TR><TD CLASS="l">1942</TD><TD>                case ByteCode.I2C:</TD></TR><TR><TD CLASS="l">1943</TD><TD>                case ByteCode.I2S:</TD></TR><TR><TD CLASS="l">1944</TD><TD>                case ByteCode.ARRAYLENGTH:</TD></TR><TR><TD CLASS="l">1945</TD><TD>                case ByteCode.INSTANCEOF:</TD></TR><TR CLASS="z"><TD CLASS="l">1946</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1947</TD><TD>                case ByteCode.ICONST_M1: // push(INTEGER)</TD></TR><TR><TD CLASS="l">1948</TD><TD>                case ByteCode.ICONST_0:</TD></TR><TR><TD CLASS="l">1949</TD><TD>                case ByteCode.ICONST_1:</TD></TR><TR><TD CLASS="l">1950</TD><TD>                case ByteCode.ICONST_2:</TD></TR><TR><TD CLASS="l">1951</TD><TD>                case ByteCode.ICONST_3:</TD></TR><TR><TD CLASS="l">1952</TD><TD>                case ByteCode.ICONST_4:</TD></TR><TR><TD CLASS="l">1953</TD><TD>                case ByteCode.ICONST_5:</TD></TR><TR><TD CLASS="l">1954</TD><TD>                case ByteCode.ILOAD:</TD></TR><TR><TD CLASS="l">1955</TD><TD>                case ByteCode.ILOAD_0:</TD></TR><TR><TD CLASS="l">1956</TD><TD>                case ByteCode.ILOAD_1:</TD></TR><TR><TD CLASS="l">1957</TD><TD>                case ByteCode.ILOAD_2:</TD></TR><TR><TD CLASS="l">1958</TD><TD>                case ByteCode.ILOAD_3:</TD></TR><TR><TD CLASS="l">1959</TD><TD>                case ByteCode.BIPUSH:</TD></TR><TR><TD CLASS="l">1960</TD><TD>                case ByteCode.SIPUSH:</TD></TR><TR CLASS="z"><TD CLASS="l">1961</TD><TD>                    push(TypeInfo.INTEGER);</TD></TR><TR CLASS="z"><TD CLASS="l">1962</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1963</TD><TD>                case ByteCode.LALOAD: // pop; pop; push(LONG)</TD></TR><TR><TD CLASS="l">1964</TD><TD>                case ByteCode.LADD:</TD></TR><TR><TD CLASS="l">1965</TD><TD>                case ByteCode.LSUB:</TD></TR><TR><TD CLASS="l">1966</TD><TD>                case ByteCode.LMUL:</TD></TR><TR><TD CLASS="l">1967</TD><TD>                case ByteCode.LDIV:</TD></TR><TR><TD CLASS="l">1968</TD><TD>                case ByteCode.LREM:</TD></TR><TR><TD CLASS="l">1969</TD><TD>                case ByteCode.LSHL:</TD></TR><TR><TD CLASS="l">1970</TD><TD>                case ByteCode.LSHR:</TD></TR><TR><TD CLASS="l">1971</TD><TD>                case ByteCode.LUSHR:</TD></TR><TR><TD CLASS="l">1972</TD><TD>                case ByteCode.LAND:</TD></TR><TR><TD CLASS="l">1973</TD><TD>                case ByteCode.LOR:</TD></TR><TR><TD CLASS="l">1974</TD><TD>                case ByteCode.LXOR:</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1976</TD><TD>                case ByteCode.LNEG: // pop; push(LONG)</TD></TR><TR><TD CLASS="l">1977</TD><TD>                case ByteCode.I2L:</TD></TR><TR><TD CLASS="l">1978</TD><TD>                case ByteCode.F2L:</TD></TR><TR><TD CLASS="l">1979</TD><TD>                case ByteCode.D2L:</TD></TR><TR CLASS="z"><TD CLASS="l">1980</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1981</TD><TD>                case ByteCode.LCONST_0: // push(LONG)</TD></TR><TR><TD CLASS="l">1982</TD><TD>                case ByteCode.LCONST_1:</TD></TR><TR><TD CLASS="l">1983</TD><TD>                case ByteCode.LLOAD:</TD></TR><TR><TD CLASS="l">1984</TD><TD>                case ByteCode.LLOAD_0:</TD></TR><TR><TD CLASS="l">1985</TD><TD>                case ByteCode.LLOAD_1:</TD></TR><TR><TD CLASS="l">1986</TD><TD>                case ByteCode.LLOAD_2:</TD></TR><TR><TD CLASS="l">1987</TD><TD>                case ByteCode.LLOAD_3:</TD></TR><TR CLASS="z"><TD CLASS="l">1988</TD><TD>                    push(TypeInfo.LONG);</TD></TR><TR CLASS="z"><TD CLASS="l">1989</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">1990</TD><TD>                case ByteCode.FALOAD: // pop; pop; push(FLOAT)</TD></TR><TR><TD CLASS="l">1991</TD><TD>                case ByteCode.FADD:</TD></TR><TR><TD CLASS="l">1992</TD><TD>                case ByteCode.FSUB:</TD></TR><TR><TD CLASS="l">1993</TD><TD>                case ByteCode.FMUL:</TD></TR><TR><TD CLASS="l">1994</TD><TD>                case ByteCode.FDIV:</TD></TR><TR><TD CLASS="l">1995</TD><TD>                case ByteCode.FREM:</TD></TR><TR CLASS="z"><TD CLASS="l">1996</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">1997</TD><TD>                case ByteCode.FNEG: // pop; push(FLOAT)</TD></TR><TR><TD CLASS="l">1998</TD><TD>                case ByteCode.I2F:</TD></TR><TR><TD CLASS="l">1999</TD><TD>                case ByteCode.L2F:</TD></TR><TR><TD CLASS="l">2000</TD><TD>                case ByteCode.D2F:</TD></TR><TR CLASS="z"><TD CLASS="l">2001</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">2002</TD><TD>                case ByteCode.FCONST_0: // push(FLOAT)</TD></TR><TR><TD CLASS="l">2003</TD><TD>                case ByteCode.FCONST_1:</TD></TR><TR><TD CLASS="l">2004</TD><TD>                case ByteCode.FCONST_2:</TD></TR><TR><TD CLASS="l">2005</TD><TD>                case ByteCode.FLOAD:</TD></TR><TR><TD CLASS="l">2006</TD><TD>                case ByteCode.FLOAD_0:</TD></TR><TR><TD CLASS="l">2007</TD><TD>                case ByteCode.FLOAD_1:</TD></TR><TR><TD CLASS="l">2008</TD><TD>                case ByteCode.FLOAD_2:</TD></TR><TR><TD CLASS="l">2009</TD><TD>                case ByteCode.FLOAD_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2010</TD><TD>                    push(TypeInfo.FLOAT);</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2012</TD><TD>                case ByteCode.DALOAD: // pop; pop; push(DOUBLE)</TD></TR><TR><TD CLASS="l">2013</TD><TD>                case ByteCode.DADD:</TD></TR><TR><TD CLASS="l">2014</TD><TD>                case ByteCode.DSUB:</TD></TR><TR><TD CLASS="l">2015</TD><TD>                case ByteCode.DMUL:</TD></TR><TR><TD CLASS="l">2016</TD><TD>                case ByteCode.DDIV:</TD></TR><TR><TD CLASS="l">2017</TD><TD>                case ByteCode.DREM:</TD></TR><TR CLASS="z"><TD CLASS="l">2018</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">2019</TD><TD>                case ByteCode.DNEG: // pop; push(DOUBLE)</TD></TR><TR><TD CLASS="l">2020</TD><TD>                case ByteCode.I2D:</TD></TR><TR><TD CLASS="l">2021</TD><TD>                case ByteCode.L2D:</TD></TR><TR><TD CLASS="l">2022</TD><TD>                case ByteCode.F2D:</TD></TR><TR CLASS="z"><TD CLASS="l">2023</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">2024</TD><TD>                case ByteCode.DCONST_0: // push(DOUBLE)</TD></TR><TR><TD CLASS="l">2025</TD><TD>                case ByteCode.DCONST_1:</TD></TR><TR><TD CLASS="l">2026</TD><TD>                case ByteCode.DLOAD:</TD></TR><TR><TD CLASS="l">2027</TD><TD>                case ByteCode.DLOAD_0:</TD></TR><TR><TD CLASS="l">2028</TD><TD>                case ByteCode.DLOAD_1:</TD></TR><TR><TD CLASS="l">2029</TD><TD>                case ByteCode.DLOAD_2:</TD></TR><TR><TD CLASS="l">2030</TD><TD>                case ByteCode.DLOAD_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2031</TD><TD>                    push(TypeInfo.DOUBLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2032</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2033</TD><TD>                case ByteCode.ISTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">2034</TD><TD>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.INTEGER);</TD></TR><TR CLASS="z"><TD CLASS="l">2035</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2036</TD><TD>                case ByteCode.ISTORE_0:</TD></TR><TR><TD CLASS="l">2037</TD><TD>                case ByteCode.ISTORE_1:</TD></TR><TR><TD CLASS="l">2038</TD><TD>                case ByteCode.ISTORE_2:</TD></TR><TR><TD CLASS="l">2039</TD><TD>                case ByteCode.ISTORE_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2040</TD><TD>                    executeStore(bc - ByteCode.ISTORE_0, TypeInfo.INTEGER);</TD></TR><TR CLASS="z"><TD CLASS="l">2041</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2042</TD><TD>                case ByteCode.LSTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">2043</TD><TD>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.LONG);</TD></TR><TR CLASS="z"><TD CLASS="l">2044</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2045</TD><TD>                case ByteCode.LSTORE_0:</TD></TR><TR><TD CLASS="l">2046</TD><TD>                case ByteCode.LSTORE_1:</TD></TR><TR><TD CLASS="l">2047</TD><TD>                case ByteCode.LSTORE_2:</TD></TR><TR><TD CLASS="l">2048</TD><TD>                case ByteCode.LSTORE_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>                    executeStore(bc - ByteCode.LSTORE_0, TypeInfo.LONG);</TD></TR><TR CLASS="z"><TD CLASS="l">2050</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2051</TD><TD>                case ByteCode.FSTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">2052</TD><TD>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.FLOAT);</TD></TR><TR CLASS="z"><TD CLASS="l">2053</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2054</TD><TD>                case ByteCode.FSTORE_0:</TD></TR><TR><TD CLASS="l">2055</TD><TD>                case ByteCode.FSTORE_1:</TD></TR><TR><TD CLASS="l">2056</TD><TD>                case ByteCode.FSTORE_2:</TD></TR><TR><TD CLASS="l">2057</TD><TD>                case ByteCode.FSTORE_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2058</TD><TD>                    executeStore(bc - ByteCode.FSTORE_0, TypeInfo.FLOAT);</TD></TR><TR CLASS="z"><TD CLASS="l">2059</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2060</TD><TD>                case ByteCode.DSTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">2061</TD><TD>                    executeStore(getOperand(bci + 1, wide ? 2 : 1), TypeInfo.DOUBLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2062</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2063</TD><TD>                case ByteCode.DSTORE_0:</TD></TR><TR><TD CLASS="l">2064</TD><TD>                case ByteCode.DSTORE_1:</TD></TR><TR><TD CLASS="l">2065</TD><TD>                case ByteCode.DSTORE_2:</TD></TR><TR><TD CLASS="l">2066</TD><TD>                case ByteCode.DSTORE_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2067</TD><TD>                    executeStore(bc - ByteCode.DSTORE_0, TypeInfo.DOUBLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2068</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2069</TD><TD>                case ByteCode.ALOAD:</TD></TR><TR CLASS="z"><TD CLASS="l">2070</TD><TD>                    executeALoad(getOperand(bci + 1, wide ? 2 : 1));</TD></TR><TR CLASS="z"><TD CLASS="l">2071</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2072</TD><TD>                case ByteCode.ALOAD_0:</TD></TR><TR><TD CLASS="l">2073</TD><TD>                case ByteCode.ALOAD_1:</TD></TR><TR><TD CLASS="l">2074</TD><TD>                case ByteCode.ALOAD_2:</TD></TR><TR><TD CLASS="l">2075</TD><TD>                case ByteCode.ALOAD_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2076</TD><TD>                    executeALoad(bc - ByteCode.ALOAD_0);</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2078</TD><TD>                case ByteCode.ASTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">2079</TD><TD>                    executeAStore(getOperand(bci + 1, wide ? 2 : 1));</TD></TR><TR CLASS="z"><TD CLASS="l">2080</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2081</TD><TD>                case ByteCode.ASTORE_0:</TD></TR><TR><TD CLASS="l">2082</TD><TD>                case ByteCode.ASTORE_1:</TD></TR><TR><TD CLASS="l">2083</TD><TD>                case ByteCode.ASTORE_2:</TD></TR><TR><TD CLASS="l">2084</TD><TD>                case ByteCode.ASTORE_3:</TD></TR><TR CLASS="z"><TD CLASS="l">2085</TD><TD>                    executeAStore(bc - ByteCode.ASTORE_0);</TD></TR><TR CLASS="z"><TD CLASS="l">2086</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2087</TD><TD>                case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">2088</TD><TD>                case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">2089</TD><TD>                case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">2090</TD><TD>                case ByteCode.DRETURN:</TD></TR><TR><TD CLASS="l">2091</TD><TD>                case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">2092</TD><TD>                case ByteCode.RETURN:</TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>                    clearStack();</TD></TR><TR CLASS="z"><TD CLASS="l">2094</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2095</TD><TD>                case ByteCode.ATHROW:</TD></TR><TR CLASS="z"><TD CLASS="l">2096</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2097</TD><TD>                    clearStack();</TD></TR><TR CLASS="z"><TD CLASS="l">2098</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2099</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2100</TD><TD>                case ByteCode.SWAP:</TD></TR><TR CLASS="z"><TD CLASS="l">2101</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2102</TD><TD>                    type2 = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2103</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2104</TD><TD>                    push(type2);</TD></TR><TR CLASS="z"><TD CLASS="l">2105</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2106</TD><TD>                case ByteCode.LDC:</TD></TR><TR><TD CLASS="l">2107</TD><TD>                case ByteCode.LDC_W:</TD></TR><TR><TD CLASS="l">2108</TD><TD>                case ByteCode.LDC2_W:</TD></TR><TR CLASS="z"><TD CLASS="l">2109</TD><TD>                    if (bc == ByteCode.LDC) {</TD></TR><TR CLASS="z"><TD CLASS="l">2110</TD><TD>                        index = getOperand(bci + 1);</TD></TR><TR><TD CLASS="l">2111</TD><TD>                    } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2112</TD><TD>                        index = getOperand(bci + 1, 2);</TD></TR><TR><TD CLASS="l">2113</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2114</TD><TD>                    byte constType = itsConstantPool.getConstantType(index);</TD></TR><TR CLASS="z"><TD CLASS="l">2115</TD><TD>                    switch (constType) {</TD></TR><TR><TD CLASS="l">2116</TD><TD>                        case ConstantPool.CONSTANT_Double:</TD></TR><TR CLASS="z"><TD CLASS="l">2117</TD><TD>                            push(TypeInfo.DOUBLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2118</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2119</TD><TD>                        case ConstantPool.CONSTANT_Float:</TD></TR><TR CLASS="z"><TD CLASS="l">2120</TD><TD>                            push(TypeInfo.FLOAT);</TD></TR><TR CLASS="z"><TD CLASS="l">2121</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2122</TD><TD>                        case ConstantPool.CONSTANT_Long:</TD></TR><TR CLASS="z"><TD CLASS="l">2123</TD><TD>                            push(TypeInfo.LONG);</TD></TR><TR CLASS="z"><TD CLASS="l">2124</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2125</TD><TD>                        case ConstantPool.CONSTANT_Integer:</TD></TR><TR CLASS="z"><TD CLASS="l">2126</TD><TD>                            push(TypeInfo.INTEGER);</TD></TR><TR CLASS="z"><TD CLASS="l">2127</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2128</TD><TD>                        case ConstantPool.CONSTANT_String:</TD></TR><TR CLASS="z"><TD CLASS="l">2129</TD><TD>                            push(TypeInfo.OBJECT(&#34;java/lang/String&#34;,</TD></TR><TR><TD CLASS="l">2130</TD><TD>                                                 itsConstantPool));</TD></TR><TR CLASS="z"><TD CLASS="l">2131</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2132</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">2133</TD><TD>                            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">2134</TD><TD>                                &#34;bad const type &#34; + constType);</TD></TR><TR><TD CLASS="l">2135</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2136</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2137</TD><TD>                case ByteCode.NEW:</TD></TR><TR CLASS="z"><TD CLASS="l">2138</TD><TD>                    push(TypeInfo.UNINITIALIZED_VARIABLE(bci));</TD></TR><TR CLASS="z"><TD CLASS="l">2139</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2140</TD><TD>                case ByteCode.NEWARRAY:</TD></TR><TR CLASS="z"><TD CLASS="l">2141</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2142</TD><TD>                    char componentType =</TD></TR><TR><TD CLASS="l">2143</TD><TD>                            arrayTypeToName(itsCodeBuffer[bci + 1]);</TD></TR><TR CLASS="z"><TD CLASS="l">2144</TD><TD>                    index = itsConstantPool.addClass(&#34;[&#34; + componentType);</TD></TR><TR CLASS="z"><TD CLASS="l">2145</TD><TD>                    push(TypeInfo.OBJECT((short) index));</TD></TR><TR CLASS="z"><TD CLASS="l">2146</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2147</TD><TD>                case ByteCode.ANEWARRAY:</TD></TR><TR CLASS="z"><TD CLASS="l">2148</TD><TD>                    index = getOperand(bci + 1, 2);</TD></TR><TR CLASS="z"><TD CLASS="l">2149</TD><TD>                    className = (String) itsConstantPool.getConstantData(index);</TD></TR><TR CLASS="z"><TD CLASS="l">2150</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2151</TD><TD>                    push(TypeInfo.OBJECT(&#34;[L&#34; + className + ';',</TD></TR><TR><TD CLASS="l">2152</TD><TD>                                         itsConstantPool));</TD></TR><TR CLASS="z"><TD CLASS="l">2153</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2154</TD><TD>                case ByteCode.INVOKEVIRTUAL:</TD></TR><TR><TD CLASS="l">2155</TD><TD>                case ByteCode.INVOKESPECIAL:</TD></TR><TR><TD CLASS="l">2156</TD><TD>                case ByteCode.INVOKESTATIC:</TD></TR><TR><TD CLASS="l">2157</TD><TD>                case ByteCode.INVOKEINTERFACE:</TD></TR><TR CLASS="z"><TD CLASS="l">2158</TD><TD>                    index = getOperand(bci + 1, 2);</TD></TR><TR CLASS="z"><TD CLASS="l">2159</TD><TD>                    FieldOrMethodRef m = (FieldOrMethodRef)</TD></TR><TR><TD CLASS="l">2160</TD><TD>                            itsConstantPool.getConstantData(index);</TD></TR><TR CLASS="z"><TD CLASS="l">2161</TD><TD>                    String methodType = m.getType();</TD></TR><TR CLASS="z"><TD CLASS="l">2162</TD><TD>                    String methodName = m.getName();</TD></TR><TR CLASS="z"><TD CLASS="l">2163</TD><TD>                    int parameterCount = sizeOfParameters(methodType) &gt;&gt;&gt; 16;</TD></TR><TR CLASS="z"><TD CLASS="l">2164</TD><TD>                    for (int i = 0; i &lt; parameterCount; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2165</TD><TD>                        pop();</TD></TR><TR><TD CLASS="l">2166</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2167</TD><TD>                    if (bc != ByteCode.INVOKESTATIC) {</TD></TR><TR CLASS="z"><TD CLASS="l">2168</TD><TD>                        int instType = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2169</TD><TD>                        int tag = TypeInfo.getTag(instType);</TD></TR><TR CLASS="z"><TD CLASS="l">2170</TD><TD>                        if (tag == TypeInfo.UNINITIALIZED_VARIABLE(0) ||</TD></TR><TR><TD CLASS="l">2171</TD><TD>                            tag == TypeInfo.UNINITIALIZED_THIS) {</TD></TR><TR CLASS="z"><TD CLASS="l">2172</TD><TD>                            if (&#34;&lt;init&gt;&#34;.equals(methodName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2173</TD><TD>                                int newType =</TD></TR><TR><TD CLASS="l">2174</TD><TD>                                        TypeInfo.OBJECT(itsThisClassIndex);</TD></TR><TR CLASS="z"><TD CLASS="l">2175</TD><TD>                                initializeTypeInfo(instType, newType);</TD></TR><TR CLASS="z"><TD CLASS="l">2176</TD><TD>                            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2177</TD><TD>                                throw new IllegalStateException(&#34;bad instance&#34;);</TD></TR><TR><TD CLASS="l">2178</TD><TD>                            }</TD></TR><TR><TD CLASS="l">2179</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2180</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2181</TD><TD>                    int rParen = methodType.indexOf(')');</TD></TR><TR CLASS="z"><TD CLASS="l">2182</TD><TD>                    String returnType = methodType.substring(rParen + 1);</TD></TR><TR CLASS="z"><TD CLASS="l">2183</TD><TD>                    returnType = descriptorToInternalName(returnType);</TD></TR><TR CLASS="z"><TD CLASS="l">2184</TD><TD>                    if (!returnType.equals(&#34;V&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>                        push(TypeInfo.fromType(returnType, itsConstantPool));</TD></TR><TR><TD CLASS="l">2186</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2187</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2188</TD><TD>                case ByteCode.GETFIELD:</TD></TR><TR CLASS="z"><TD CLASS="l">2189</TD><TD>                    pop();</TD></TR><TR><TD CLASS="l">2190</TD><TD>                case ByteCode.GETSTATIC:</TD></TR><TR CLASS="z"><TD CLASS="l">2191</TD><TD>                    index = getOperand(bci + 1, 2);</TD></TR><TR CLASS="z"><TD CLASS="l">2192</TD><TD>                    FieldOrMethodRef f = (FieldOrMethodRef)</TD></TR><TR><TD CLASS="l">2193</TD><TD>                            itsConstantPool.getConstantData(index);</TD></TR><TR CLASS="z"><TD CLASS="l">2194</TD><TD>                    String fieldType = descriptorToInternalName(f.getType());</TD></TR><TR CLASS="z"><TD CLASS="l">2195</TD><TD>                    push(TypeInfo.fromType(fieldType, itsConstantPool));</TD></TR><TR CLASS="z"><TD CLASS="l">2196</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2197</TD><TD>                case ByteCode.DUP:</TD></TR><TR CLASS="z"><TD CLASS="l">2198</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2200</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2202</TD><TD>                case ByteCode.DUP_X1:</TD></TR><TR CLASS="z"><TD CLASS="l">2203</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2204</TD><TD>                    type2 = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2205</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2206</TD><TD>                    push(type2);</TD></TR><TR CLASS="z"><TD CLASS="l">2207</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2208</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2209</TD><TD>                case ByteCode.DUP_X2:</TD></TR><TR CLASS="z"><TD CLASS="l">2210</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2211</TD><TD>                    lType = pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">2212</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2213</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2214</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2215</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2216</TD><TD>                case ByteCode.DUP2:</TD></TR><TR CLASS="z"><TD CLASS="l">2217</TD><TD>                    lType = pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">2218</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2219</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2220</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2221</TD><TD>                case ByteCode.DUP2_X1:</TD></TR><TR CLASS="z"><TD CLASS="l">2222</TD><TD>                    lType = pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">2223</TD><TD>                    type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2224</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2225</TD><TD>                    push(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2226</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2227</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2228</TD><TD>                case ByteCode.DUP2_X2:</TD></TR><TR CLASS="z"><TD CLASS="l">2229</TD><TD>                    lType = pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">2230</TD><TD>                    lType2 = pop2();</TD></TR><TR CLASS="z"><TD CLASS="l">2231</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2232</TD><TD>                    push2(lType2);</TD></TR><TR CLASS="z"><TD CLASS="l">2233</TD><TD>                    push2(lType);</TD></TR><TR CLASS="z"><TD CLASS="l">2234</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2235</TD><TD>                case ByteCode.TABLESWITCH:</TD></TR><TR CLASS="z"><TD CLASS="l">2236</TD><TD>                    int switchStart = bci + 1 + (3 &amp; ~bci);</TD></TR><TR CLASS="z"><TD CLASS="l">2237</TD><TD>                    int low = getOperand(switchStart + 4, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">2238</TD><TD>                    int high = getOperand(switchStart + 8, 4);</TD></TR><TR CLASS="z"><TD CLASS="l">2239</TD><TD>                    length = 4 * (high - low + 4) + switchStart - bci;</TD></TR><TR CLASS="z"><TD CLASS="l">2240</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2241</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2242</TD><TD>                case ByteCode.AALOAD:</TD></TR><TR CLASS="z"><TD CLASS="l">2243</TD><TD>                    pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2244</TD><TD>                    int typeIndex = pop() &gt;&gt;&gt; 8;</TD></TR><TR CLASS="z"><TD CLASS="l">2245</TD><TD>                    className =</TD></TR><TR><TD CLASS="l">2246</TD><TD>                            (String) itsConstantPool.getConstantData(typeIndex);</TD></TR><TR CLASS="z"><TD CLASS="l">2247</TD><TD>                    String arrayType = className;</TD></TR><TR CLASS="z"><TD CLASS="l">2248</TD><TD>                    if (arrayType.charAt(0) != '[') {</TD></TR><TR CLASS="z"><TD CLASS="l">2249</TD><TD>                        throw new IllegalStateException(&#34;bad array type&#34;);</TD></TR><TR><TD CLASS="l">2250</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2251</TD><TD>                    String elementDesc = arrayType.substring(1);</TD></TR><TR CLASS="z"><TD CLASS="l">2252</TD><TD>                    String elementType = descriptorToInternalName(elementDesc);</TD></TR><TR CLASS="z"><TD CLASS="l">2253</TD><TD>                    typeIndex = itsConstantPool.addClass(elementType);</TD></TR><TR CLASS="z"><TD CLASS="l">2254</TD><TD>                    push(TypeInfo.OBJECT(typeIndex));</TD></TR><TR CLASS="z"><TD CLASS="l">2255</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2256</TD><TD>                case ByteCode.WIDE:</TD></TR><TR><TD CLASS="l">2257</TD><TD>                    // Alters behaviour of next instruction</TD></TR><TR CLASS="z"><TD CLASS="l">2258</TD><TD>                    wide = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2259</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2260</TD><TD>                case ByteCode.MULTIANEWARRAY:</TD></TR><TR><TD CLASS="l">2261</TD><TD>                case ByteCode.LOOKUPSWITCH:</TD></TR><TR><TD CLASS="l">2262</TD><TD>                    // Currently not used in any part of Rhino, so ignore it</TD></TR><TR><TD CLASS="l">2263</TD><TD>                case ByteCode.JSR: // TODO: JSR is deprecated</TD></TR><TR><TD CLASS="l">2264</TD><TD>                case ByteCode.RET:</TD></TR><TR><TD CLASS="l">2265</TD><TD>                case ByteCode.JSR_W:</TD></TR><TR><TD CLASS="l">2266</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>                    throw new IllegalArgumentException(&#34;bad opcode: &#34; + bc);</TD></TR><TR><TD CLASS="l">2268</TD><TD>            }</TD></TR><TR><TD CLASS="l">2269</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2270</TD><TD>            if (length == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2271</TD><TD>                length = opcodeLength(bc, wide);</TD></TR><TR><TD CLASS="l">2272</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2273</TD><TD>            if (wide &amp;&amp; bc != ByteCode.WIDE) {</TD></TR><TR CLASS="z"><TD CLASS="l">2274</TD><TD>                wide = false;</TD></TR><TR><TD CLASS="l">2275</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="9">2276</A></TD><TD>            return length;</TD></TR><TR><TD CLASS="l">2277</TD><TD>        }</TD></TR><TR><TD CLASS="l">2278</TD><TD> </TD></TR><TR><TD CLASS="l">2279</TD><TD>        private void executeALoad(int localIndex) {</TD></TR><TR CLASS="z"><TD CLASS="l">2280</TD><TD>            int type = getLocal(localIndex);</TD></TR><TR CLASS="z"><TD CLASS="l">2281</TD><TD>            int tag = TypeInfo.getTag(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2282</TD><TD>            if (tag == TypeInfo.OBJECT_TAG ||</TD></TR><TR><TD CLASS="l">2283</TD><TD>                tag == TypeInfo.UNINITIALIZED_THIS ||</TD></TR><TR><TD CLASS="l">2284</TD><TD>                tag == TypeInfo.UNINITIALIZED_VAR_TAG ||</TD></TR><TR><TD CLASS="l">2285</TD><TD>                tag == TypeInfo.NULL) {</TD></TR><TR CLASS="z"><TD CLASS="l">2286</TD><TD>                push(type);</TD></TR><TR><TD CLASS="l">2287</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2288</TD><TD>                throw new IllegalStateException(&#34;bad local variable type: &#34; +</TD></TR><TR><TD CLASS="l">2289</TD><TD>                                                type + &#34; at index: &#34; +</TD></TR><TR><TD CLASS="l">2290</TD><TD>                                                localIndex);</TD></TR><TR><TD CLASS="l"><A NAME="a">2291</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2292</TD><TD>        }</TD></TR><TR><TD CLASS="l">2293</TD><TD> </TD></TR><TR><TD CLASS="l">2294</TD><TD>        private void executeAStore(int localIndex) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c">2295</A></TD><TD>            setLocal(localIndex, pop());</TD></TR><TR CLASS="z"><TD CLASS="l">2296</TD><TD>        }</TD></TR><TR><TD CLASS="l">2297</TD><TD> </TD></TR><TR><TD CLASS="l">2298</TD><TD>        private void executeStore(int localIndex, int typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l">2299</TD><TD>            pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2300</TD><TD>            setLocal(localIndex, typeInfo);</TD></TR><TR CLASS="z"><TD CLASS="l">2301</TD><TD>        }</TD></TR><TR><TD CLASS="l">2302</TD><TD> </TD></TR><TR><TD CLASS="l">2303</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2304</TD><TD>         * Change an UNINITIALIZED_OBJECT or UNINITIALIZED_THIS to the proper</TD></TR><TR><TD CLASS="l"><A NAME="17">2305</A></TD><TD>         * type of the object. This occurs when the proper constructor is</TD></TR><TR><TD CLASS="l">2306</TD><TD>         * invoked.</TD></TR><TR><TD CLASS="l">2307</TD><TD>         */</TD></TR><TR><TD CLASS="l">2308</TD><TD>        private void initializeTypeInfo(int prevType, int newType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>            initializeTypeInfo(prevType, newType, locals, localsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>            initializeTypeInfo(prevType, newType, stack, stackTop);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="18">2311</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2312</TD><TD> </TD></TR><TR><TD CLASS="l">2313</TD><TD>        private void initializeTypeInfo(int prevType, int newType, int[] data,</TD></TR><TR><TD CLASS="l">2314</TD><TD>                                        int dataTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>            for (int i = 0; i &lt; dataTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2316</TD><TD>                if (data[i] == prevType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2317</TD><TD>                    data[i] = newType;</TD></TR><TR><TD CLASS="l">2318</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="11">2319</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2320</TD><TD>        }</TD></TR><TR><TD CLASS="l">2321</TD><TD> </TD></TR><TR><TD CLASS="l">2322</TD><TD>        private int getLocal(int localIndex) {</TD></TR><TR CLASS="z"><TD CLASS="l">2323</TD><TD>            if (localIndex &lt; localsTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">2324</TD><TD>                return locals[localIndex];</TD></TR><TR><TD CLASS="l">2325</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2326</TD><TD>                return TypeInfo.TOP;</TD></TR><TR><TD CLASS="l"><A NAME="20">2327</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">2328</TD><TD>        }</TD></TR><TR><TD CLASS="l">2329</TD><TD> </TD></TR><TR><TD CLASS="l">2330</TD><TD>        private void setLocal(int localIndex, int typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l">2331</TD><TD>            if (localIndex &gt;= localsTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">2332</TD><TD>                int[] tmp = new int[localIndex + 1];</TD></TR><TR CLASS="z"><TD CLASS="l">2333</TD><TD>                System.arraycopy(locals, 0, tmp, 0, localsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2334</TD><TD>                locals = tmp;</TD></TR><TR CLASS="z"><TD CLASS="l">2335</TD><TD>                localsTop = localIndex + 1;</TD></TR><TR><TD CLASS="l">2336</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">2337</A></TD><TD>            locals[localIndex] = typeInfo;</TD></TR><TR CLASS="z"><TD CLASS="l">2338</TD><TD>        }</TD></TR><TR><TD CLASS="l">2339</TD><TD> </TD></TR><TR><TD CLASS="l">2340</TD><TD>        private void push(int typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l">2341</TD><TD>            if (stackTop == stack.length) {</TD></TR><TR CLASS="z"><TD CLASS="l">2342</TD><TD>                int[] tmp = new int[Math.max(stackTop * 2, 4)];</TD></TR><TR CLASS="z"><TD CLASS="l">2343</TD><TD>                System.arraycopy(stack, 0, tmp, 0, stackTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2344</TD><TD>                stack = tmp;</TD></TR><TR><TD CLASS="l">2345</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1c">2346</A></TD><TD>            stack[stackTop++] = typeInfo;</TD></TR><TR CLASS="z"><TD CLASS="l">2347</TD><TD>        }</TD></TR><TR><TD CLASS="l">2348</TD><TD> </TD></TR><TR><TD CLASS="l">2349</TD><TD>        private int pop() {</TD></TR><TR CLASS="z"><TD CLASS="l">2350</TD><TD>            return stack[--stackTop];</TD></TR><TR><TD CLASS="l">2351</TD><TD>        }</TD></TR><TR><TD CLASS="l">2352</TD><TD> </TD></TR><TR><TD CLASS="l">2353</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2354</TD><TD>         * Push two words onto the op stack.</TD></TR><TR><TD CLASS="l">2355</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="1f">2356</A></TD><TD>         * This is only meant to be used as a complement to pop2(), and both</TD></TR><TR><TD CLASS="l">2357</TD><TD>         * methods are helpers for the more complex DUP operations.</TD></TR><TR><TD CLASS="l">2358</TD><TD>         */</TD></TR><TR><TD CLASS="l">2359</TD><TD>        private void push2(long typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l">2360</TD><TD>            push((int) (typeInfo &amp; 0xFFFFFF));</TD></TR><TR CLASS="z"><TD CLASS="l">2361</TD><TD>            typeInfo &gt;&gt;&gt;= 32;</TD></TR><TR CLASS="z"><TD CLASS="l">2362</TD><TD>            if (typeInfo != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2363</TD><TD>                push((int) (typeInfo &amp; 0xFFFFFF));</TD></TR><TR><TD CLASS="l">2364</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2365</TD><TD>        }</TD></TR><TR><TD CLASS="l">2366</TD><TD> </TD></TR><TR><TD CLASS="l">2367</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2368</TD><TD>         * Pop two words from the op stack.</TD></TR><TR><TD CLASS="l">2369</TD><TD>         *</TD></TR><TR><TD CLASS="l">2370</TD><TD>         * If the top of the stack is a DOUBLE or LONG, then the bottom 32 bits</TD></TR><TR><TD CLASS="l">2371</TD><TD>         * reflects the appropriate type and the top 32 bits are 0. Otherwise,</TD></TR><TR><TD CLASS="l"><A NAME="1d">2372</A></TD><TD>         * the top 32 bits are the first word on the stack and the lower 32</TD></TR><TR><TD CLASS="l">2373</TD><TD>         * bits are the second word on the stack.</TD></TR><TR><TD CLASS="l">2374</TD><TD>         */</TD></TR><TR><TD CLASS="l">2375</TD><TD>        private long pop2() {</TD></TR><TR CLASS="z"><TD CLASS="l">2376</TD><TD>            long type = pop();</TD></TR><TR CLASS="z"><TD CLASS="l">2377</TD><TD>            if (TypeInfo.isTwoWords((int) type)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2378</TD><TD>                return type;</TD></TR><TR><TD CLASS="l">2379</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2380</TD><TD>                return type &lt;&lt; 32 | (pop() &amp; 0xFFFFFF);</TD></TR><TR><TD CLASS="l"><A NAME="5">2381</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">2382</TD><TD>        }</TD></TR><TR><TD CLASS="l">2383</TD><TD> </TD></TR><TR><TD CLASS="l">2384</TD><TD>        private void clearStack() {</TD></TR><TR CLASS="z"><TD CLASS="l">2385</TD><TD>            stackTop = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2386</TD><TD>        }</TD></TR><TR><TD CLASS="l">2387</TD><TD> </TD></TR><TR><TD CLASS="l">2388</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2389</TD><TD>         * Compute the output size of the stack map table.</TD></TR><TR><TD CLASS="l">2390</TD><TD>         *</TD></TR><TR><TD CLASS="l">2391</TD><TD>         * Because this would share much in common with actual writing of the</TD></TR><TR><TD CLASS="l">2392</TD><TD>         * stack map table, we instead just write the stack map table to a</TD></TR><TR><TD CLASS="l">2393</TD><TD>         * buffer and return the size from it. The buffer is later used in</TD></TR><TR><TD CLASS="l">2394</TD><TD>         * the actual writing of bytecode.</TD></TR><TR><TD CLASS="l"><A NAME="7">2395</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">2396</TD><TD>        int computeWriteSize() {</TD></TR><TR><TD CLASS="l">2397</TD><TD>            // Allocate a buffer that can handle the worst case size of the</TD></TR><TR><TD CLASS="l">2398</TD><TD>            // stack map to prevent lots of reallocations.</TD></TR><TR CLASS="z"><TD CLASS="l">2399</TD><TD>            int writeSize = getWorstCaseWriteSize();</TD></TR><TR CLASS="z"><TD CLASS="l">2400</TD><TD>            rawStackMap = new byte[writeSize];</TD></TR><TR CLASS="z"><TD CLASS="l">2401</TD><TD>            computeRawStackMap();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="22">2402</A></TD><TD>            return rawStackMapTop + 2;</TD></TR><TR><TD CLASS="l">2403</TD><TD>        }</TD></TR><TR><TD CLASS="l">2404</TD><TD> </TD></TR><TR><TD CLASS="l">2405</TD><TD>        int write(byte[] data, int offset) {</TD></TR><TR CLASS="z"><TD CLASS="l">2406</TD><TD>            offset = putInt32(rawStackMapTop + 2, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">2407</TD><TD>            offset = putInt16(superBlocks.length - 1, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">2408</TD><TD>            System.arraycopy(rawStackMap, 0, data, offset, rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2409</TD><TD>            return offset + rawStackMapTop;</TD></TR><TR><TD CLASS="l">2410</TD><TD>        }</TD></TR><TR><TD CLASS="l">2411</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="6">2412</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2413</TD><TD>         * Compute a space-optimal stack map table.</TD></TR><TR><TD CLASS="l">2414</TD><TD>         */</TD></TR><TR><TD CLASS="l">2415</TD><TD>        private void computeRawStackMap() {</TD></TR><TR CLASS="z"><TD CLASS="l">2416</TD><TD>            SuperBlock prev = superBlocks[0];</TD></TR><TR CLASS="z"><TD CLASS="l">2417</TD><TD>            int[] prevLocals = prev.getTrimmedLocals();</TD></TR><TR CLASS="z"><TD CLASS="l">2418</TD><TD>            int prevOffset = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2419</TD><TD>            for (int i = 1; i &lt; superBlocks.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2420</TD><TD>                SuperBlock current = superBlocks[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2421</TD><TD>                int[] currentLocals = current.getTrimmedLocals();</TD></TR><TR CLASS="z"><TD CLASS="l">2422</TD><TD>                int[] currentStack = current.getStack();</TD></TR><TR CLASS="z"><TD CLASS="l">2423</TD><TD>                int offsetDelta = current.getStart() - prevOffset - 1;</TD></TR><TR><TD CLASS="l">2424</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2425</TD><TD>                if (currentStack.length == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2426</TD><TD>                    int last = prevLocals.length &gt; currentLocals.length ?</TD></TR><TR><TD CLASS="l">2427</TD><TD>                            currentLocals.length : prevLocals.length;</TD></TR><TR CLASS="z"><TD CLASS="l">2428</TD><TD>                    int delta = Math.abs(prevLocals.length -</TD></TR><TR><TD CLASS="l">2429</TD><TD>                                         currentLocals.length);</TD></TR><TR><TD CLASS="l">2430</TD><TD>                    int j;</TD></TR><TR><TD CLASS="l">2431</TD><TD>                    // Compare locals until one is different or the end of a</TD></TR><TR><TD CLASS="l">2432</TD><TD>                    // local variable array is reached</TD></TR><TR CLASS="z"><TD CLASS="l">2433</TD><TD>                    for (j = 0; j &lt; last; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2434</TD><TD>                        if (prevLocals[j] != currentLocals[j]) {</TD></TR><TR CLASS="z"><TD CLASS="l">2435</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">2436</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2437</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2438</TD><TD>                    if (j == currentLocals.length &amp;&amp; delta == 0) {</TD></TR><TR><TD CLASS="l">2439</TD><TD>                        // All of the compared locals are equal and the local</TD></TR><TR><TD CLASS="l">2440</TD><TD>                        // arrays are of equal size</TD></TR><TR CLASS="z"><TD CLASS="l">2441</TD><TD>                        writeSameFrame(currentLocals, offsetDelta);</TD></TR><TR CLASS="z"><TD CLASS="l">2442</TD><TD>                    } else if (j == currentLocals.length &amp;&amp; delta &lt;= 3) {</TD></TR><TR><TD CLASS="l">2443</TD><TD>                        // All of the compared locals are equal and the current</TD></TR><TR><TD CLASS="l">2444</TD><TD>                        // frame has less locals than the previous frame</TD></TR><TR CLASS="z"><TD CLASS="l">2445</TD><TD>                        writeChopFrame(delta, offsetDelta);</TD></TR><TR CLASS="z"><TD CLASS="l">2446</TD><TD>                    } else if (j == prevLocals.length &amp;&amp; delta &lt;= 3) {</TD></TR><TR><TD CLASS="l">2447</TD><TD>                        // All of the compared locals are equal and the current</TD></TR><TR><TD CLASS="l">2448</TD><TD>                        // frame has more locals than the previous frame</TD></TR><TR CLASS="z"><TD CLASS="l">2449</TD><TD>                        writeAppendFrame(currentLocals, delta, offsetDelta);</TD></TR><TR><TD CLASS="l">2450</TD><TD>                    } else {</TD></TR><TR><TD CLASS="l">2451</TD><TD>                        // Not all locals were compared were equal, so a full</TD></TR><TR><TD CLASS="l">2452</TD><TD>                        // frame is necessary</TD></TR><TR CLASS="z"><TD CLASS="l">2453</TD><TD>                        writeFullFrame(currentLocals, currentStack,</TD></TR><TR><TD CLASS="l">2454</TD><TD>                                       offsetDelta);</TD></TR><TR><TD CLASS="l">2455</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2456</TD><TD>                } else if (currentStack.length == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2457</TD><TD>                    if (Arrays.equals(prevLocals, currentLocals)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2458</TD><TD>                       writeSameLocalsOneStackItemFrame(currentLocals,</TD></TR><TR><TD CLASS="l">2459</TD><TD>                                                        currentStack,</TD></TR><TR><TD CLASS="l">2460</TD><TD>                                                        offsetDelta);</TD></TR><TR><TD CLASS="l">2461</TD><TD>                    } else {</TD></TR><TR><TD CLASS="l">2462</TD><TD>                        // Output a full frame, since no other frame types have</TD></TR><TR><TD CLASS="l">2463</TD><TD>                        // one operand stack item.</TD></TR><TR CLASS="z"><TD CLASS="l">2464</TD><TD>                        writeFullFrame(currentLocals, currentStack,</TD></TR><TR><TD CLASS="l">2465</TD><TD>                                       offsetDelta);</TD></TR><TR><TD CLASS="l">2466</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2467</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">2468</TD><TD>                    // Any stack map frame that has more than one operand stack</TD></TR><TR><TD CLASS="l">2469</TD><TD>                    // item has to be a full frame. All other frame types have</TD></TR><TR><TD CLASS="l">2470</TD><TD>                    // at most one item on the stack.</TD></TR><TR CLASS="z"><TD CLASS="l">2471</TD><TD>                    writeFullFrame(currentLocals, currentStack, offsetDelta);</TD></TR><TR><TD CLASS="l">2472</TD><TD>                }</TD></TR><TR><TD CLASS="l">2473</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2474</TD><TD>                prev = current;</TD></TR><TR CLASS="z"><TD CLASS="l">2475</TD><TD>                prevLocals = currentLocals;</TD></TR><TR CLASS="z"><TD CLASS="l">2476</TD><TD>                prevOffset = current.getStart();</TD></TR><TR><TD CLASS="l">2477</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2478</TD><TD>        }</TD></TR><TR><TD CLASS="l">2479</TD><TD> </TD></TR><TR><TD CLASS="l">2480</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2481</TD><TD>         * Get the worst case write size of the stack map table.</TD></TR><TR><TD CLASS="l">2482</TD><TD>         *</TD></TR><TR><TD CLASS="l">2483</TD><TD>         * This computes how much full frames would take, if each full frame</TD></TR><TR><TD CLASS="l"><A NAME="16">2484</A></TD><TD>         * contained the maximum number of locals and stack operands, and each</TD></TR><TR><TD CLASS="l">2485</TD><TD>         * verification type was 3 bytes.</TD></TR><TR><TD CLASS="l">2486</TD><TD>         */</TD></TR><TR><TD CLASS="l">2487</TD><TD>        private int getWorstCaseWriteSize() {</TD></TR><TR CLASS="z"><TD CLASS="l">2488</TD><TD>            return (superBlocks.length - 1) * (7 + itsMaxLocals * 3 +</TD></TR><TR><TD CLASS="l"><A NAME="26">2489</A></TD><TD>                                               itsMaxStack * 3);</TD></TR><TR><TD CLASS="l">2490</TD><TD>        }</TD></TR><TR><TD CLASS="l">2491</TD><TD> </TD></TR><TR><TD CLASS="l">2492</TD><TD>        private void writeSameFrame(int[] locals, int offsetDelta) {</TD></TR><TR CLASS="z"><TD CLASS="l">2493</TD><TD>            if (offsetDelta &lt;= 63) {</TD></TR><TR><TD CLASS="l">2494</TD><TD>                // Output a same_frame frame. Despite the name,</TD></TR><TR><TD CLASS="l">2495</TD><TD>                // the operand stack may differ, but the current</TD></TR><TR><TD CLASS="l">2496</TD><TD>                // operand stack must be empty.</TD></TR><TR CLASS="z"><TD CLASS="l">2497</TD><TD>                rawStackMap[rawStackMapTop++] = (byte) offsetDelta;</TD></TR><TR><TD CLASS="l">2498</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">2499</TD><TD>                // Output a same_frame_extended frame. Similar to</TD></TR><TR><TD CLASS="l">2500</TD><TD>                // the above, except with a larger offset delta.</TD></TR><TR CLASS="z"><TD CLASS="l">2501</TD><TD>                rawStackMap[rawStackMapTop++] = (byte) 251;</TD></TR><TR CLASS="z"><TD CLASS="l">2502</TD><TD>                rawStackMapTop = putInt16(offsetDelta, rawStackMap,</TD></TR><TR><TD CLASS="l">2503</TD><TD>                                          rawStackMapTop);</TD></TR><TR><TD CLASS="l">2504</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2505</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="27">2506</A></TD><TD> </TD></TR><TR><TD CLASS="l">2507</TD><TD>        private void writeSameLocalsOneStackItemFrame(int[] locals,</TD></TR><TR><TD CLASS="l">2508</TD><TD>                                                      int[] stack,</TD></TR><TR><TD CLASS="l">2509</TD><TD>                                                      int offsetDelta) {</TD></TR><TR CLASS="z"><TD CLASS="l">2510</TD><TD>            if (offsetDelta &lt;= 63) {</TD></TR><TR><TD CLASS="l">2511</TD><TD>                // Output a same_locals_1_stack_item frame. Similar</TD></TR><TR><TD CLASS="l">2512</TD><TD>                // to same_frame, only with one item on the operand</TD></TR><TR><TD CLASS="l">2513</TD><TD>                // stack instead of zero.</TD></TR><TR CLASS="z"><TD CLASS="l">2514</TD><TD>                rawStackMap[rawStackMapTop++] = (byte) (64 + offsetDelta);</TD></TR><TR><TD CLASS="l">2515</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">2516</TD><TD>                // Output a same_locals_1_stack_item_extended frame.</TD></TR><TR><TD CLASS="l">2517</TD><TD>                // Similar to same_frame_extended, only with one</TD></TR><TR><TD CLASS="l">2518</TD><TD>                // item on the operand stack instead of zero.</TD></TR><TR CLASS="z"><TD CLASS="l">2519</TD><TD>                rawStackMap[rawStackMapTop++] = (byte) 247;</TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>                rawStackMapTop = putInt16(offsetDelta, rawStackMap,</TD></TR><TR><TD CLASS="l">2521</TD><TD>                                          rawStackMapTop);</TD></TR><TR><TD CLASS="l">2522</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2523</TD><TD>            writeType(stack[0]);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="25">2524</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2525</TD><TD> </TD></TR><TR><TD CLASS="l">2526</TD><TD>        private void writeFullFrame(int[] locals, int[] stack,</TD></TR><TR><TD CLASS="l">2527</TD><TD>                                    int offsetDelta) {</TD></TR><TR CLASS="z"><TD CLASS="l">2528</TD><TD>            rawStackMap[rawStackMapTop++] = (byte) 255;</TD></TR><TR CLASS="z"><TD CLASS="l">2529</TD><TD>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2530</TD><TD>            rawStackMapTop = putInt16(locals.length, rawStackMap,</TD></TR><TR><TD CLASS="l">2531</TD><TD>                                      rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2532</TD><TD>            rawStackMapTop = writeTypes(locals);</TD></TR><TR CLASS="z"><TD CLASS="l">2533</TD><TD>            rawStackMapTop = putInt16(stack.length, rawStackMap,</TD></TR><TR><TD CLASS="l">2534</TD><TD>                                      rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2535</TD><TD>            rawStackMapTop = writeTypes(stack);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="23">2536</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2537</TD><TD> </TD></TR><TR><TD CLASS="l">2538</TD><TD>        private void writeAppendFrame(int[] locals, int localsDelta,</TD></TR><TR><TD CLASS="l">2539</TD><TD>                                      int offsetDelta) {</TD></TR><TR CLASS="z"><TD CLASS="l">2540</TD><TD>            int start = locals.length - localsDelta;</TD></TR><TR CLASS="z"><TD CLASS="l">2541</TD><TD>            rawStackMap[rawStackMapTop++] = (byte) (251 + localsDelta);</TD></TR><TR CLASS="z"><TD CLASS="l">2542</TD><TD>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="24">2543</A></TD><TD>            rawStackMapTop = writeTypes(locals, start);</TD></TR><TR CLASS="z"><TD CLASS="l">2544</TD><TD>        }</TD></TR><TR><TD CLASS="l">2545</TD><TD> </TD></TR><TR><TD CLASS="l">2546</TD><TD>        private void writeChopFrame(int localsDelta, int offsetDelta) {</TD></TR><TR CLASS="z"><TD CLASS="l">2547</TD><TD>            rawStackMap[rawStackMapTop++] = (byte) (251 - localsDelta);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="29">2548</A></TD><TD>            rawStackMapTop = putInt16(offsetDelta, rawStackMap, rawStackMapTop);</TD></TR><TR CLASS="z"><TD CLASS="l">2549</TD><TD>        }</TD></TR><TR><TD CLASS="l">2550</TD><TD> </TD></TR><TR><TD CLASS="l">2551</TD><TD>        private int writeTypes(int[] types) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2a">2552</A></TD><TD>            return writeTypes(types, 0);</TD></TR><TR><TD CLASS="l">2553</TD><TD>        }</TD></TR><TR><TD CLASS="l">2554</TD><TD> </TD></TR><TR><TD CLASS="l">2555</TD><TD>        private int writeTypes(int[] types, int start) {</TD></TR><TR CLASS="z"><TD CLASS="l">2556</TD><TD>            int startOffset = rawStackMapTop;</TD></TR><TR CLASS="z"><TD CLASS="l">2557</TD><TD>            for (int i = start; i &lt; types.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2558</TD><TD>                rawStackMapTop = writeType(types[i]);</TD></TR><TR><TD CLASS="l">2559</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="28">2560</A></TD><TD>            return rawStackMapTop;</TD></TR><TR><TD CLASS="l">2561</TD><TD>        }</TD></TR><TR><TD CLASS="l">2562</TD><TD> </TD></TR><TR><TD CLASS="l">2563</TD><TD>        private int writeType(int type) {</TD></TR><TR CLASS="z"><TD CLASS="l">2564</TD><TD>            int tag = type &amp; 0xFF;</TD></TR><TR CLASS="z"><TD CLASS="l">2565</TD><TD>            rawStackMap[rawStackMapTop++] = (byte) tag;</TD></TR><TR CLASS="z"><TD CLASS="l">2566</TD><TD>            if (tag == TypeInfo.OBJECT_TAG ||</TD></TR><TR><TD CLASS="l">2567</TD><TD>                tag == TypeInfo.UNINITIALIZED_VAR_TAG) {</TD></TR><TR CLASS="z"><TD CLASS="l">2568</TD><TD>                rawStackMapTop = putInt16(type &gt;&gt;&gt; 8, rawStackMap,</TD></TR><TR><TD CLASS="l">2569</TD><TD>                                          rawStackMapTop);</TD></TR><TR><TD CLASS="l">2570</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2571</TD><TD>            return rawStackMapTop;</TD></TR><TR><TD CLASS="l">2572</TD><TD>        }</TD></TR><TR><TD CLASS="l">2573</TD><TD> </TD></TR><TR><TD CLASS="l">2574</TD><TD>        // Intermediate operand stack and local variable state. During</TD></TR><TR><TD CLASS="l">2575</TD><TD>        // execution of a block, these are initialized to copies of the initial</TD></TR><TR><TD CLASS="l">2576</TD><TD>        // block type state and are modified by the actual stack/local</TD></TR><TR><TD CLASS="l">2577</TD><TD>        // emulation.</TD></TR><TR><TD CLASS="l">2578</TD><TD>        private int[] locals;</TD></TR><TR><TD CLASS="l">2579</TD><TD>        private int localsTop;</TD></TR><TR><TD CLASS="l">2580</TD><TD>        private int[] stack;</TD></TR><TR><TD CLASS="l">2581</TD><TD>        private int stackTop;</TD></TR><TR><TD CLASS="l">2582</TD><TD> </TD></TR><TR><TD CLASS="l">2583</TD><TD>        private SuperBlock[] workList;</TD></TR><TR><TD CLASS="l">2584</TD><TD>        private int workListTop;</TD></TR><TR><TD CLASS="l">2585</TD><TD> </TD></TR><TR><TD CLASS="l">2586</TD><TD>        private SuperBlock[] superBlocks;</TD></TR><TR><TD CLASS="l">2587</TD><TD>        private SuperBlock[] superBlockDeps;</TD></TR><TR><TD CLASS="l">2588</TD><TD> </TD></TR><TR><TD CLASS="l">2589</TD><TD>        private byte[] rawStackMap;</TD></TR><TR><TD CLASS="l">2590</TD><TD>        private int rawStackMapTop;</TD></TR><TR><TD CLASS="l">2591</TD><TD> </TD></TR><TR><TD CLASS="l">2592</TD><TD>        private boolean wide;</TD></TR><TR><TD CLASS="l">2593</TD><TD> </TD></TR><TR><TD CLASS="l">2594</TD><TD>        static final boolean DEBUGSTACKMAP = false;</TD></TR><TR><TD CLASS="l">2595</TD><TD>    }</TD></TR><TR><TD CLASS="l">2596</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="6a">2597</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">2598</TD><TD>     * Convert a newarray operand into an internal type.</TD></TR><TR><TD CLASS="l">2599</TD><TD>     */</TD></TR><TR><TD CLASS="l">2600</TD><TD>    private static char arrayTypeToName(int type) {</TD></TR><TR CLASS="z"><TD CLASS="l">2601</TD><TD>        switch (type) {</TD></TR><TR><TD CLASS="l">2602</TD><TD>            case ByteCode.T_BOOLEAN:</TD></TR><TR CLASS="z"><TD CLASS="l">2603</TD><TD>                return 'Z';</TD></TR><TR><TD CLASS="l">2604</TD><TD>            case ByteCode.T_CHAR:</TD></TR><TR CLASS="z"><TD CLASS="l">2605</TD><TD>                return 'C';</TD></TR><TR><TD CLASS="l">2606</TD><TD>            case ByteCode.T_FLOAT:</TD></TR><TR CLASS="z"><TD CLASS="l">2607</TD><TD>                return 'F';</TD></TR><TR><TD CLASS="l">2608</TD><TD>            case ByteCode.T_DOUBLE:</TD></TR><TR CLASS="z"><TD CLASS="l">2609</TD><TD>                return 'D';</TD></TR><TR><TD CLASS="l">2610</TD><TD>            case ByteCode.T_BYTE:</TD></TR><TR CLASS="z"><TD CLASS="l">2611</TD><TD>                return 'B';</TD></TR><TR><TD CLASS="l">2612</TD><TD>            case ByteCode.T_SHORT:</TD></TR><TR CLASS="z"><TD CLASS="l">2613</TD><TD>                return 'S';</TD></TR><TR><TD CLASS="l">2614</TD><TD>            case ByteCode.T_INT:</TD></TR><TR CLASS="z"><TD CLASS="l">2615</TD><TD>                return 'I';</TD></TR><TR><TD CLASS="l">2616</TD><TD>            case ByteCode.T_LONG:</TD></TR><TR CLASS="z"><TD CLASS="l">2617</TD><TD>                return 'J';</TD></TR><TR><TD CLASS="l">2618</TD><TD>            default:</TD></TR><TR CLASS="z"><TD CLASS="l">2619</TD><TD>                throw new IllegalArgumentException(&#34;bad operand&#34;);</TD></TR><TR><TD CLASS="l">2620</TD><TD>        }</TD></TR><TR><TD CLASS="l">2621</TD><TD>    }</TD></TR><TR><TD CLASS="l">2622</TD><TD> </TD></TR><TR><TD CLASS="l">2623</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2624</TD><TD>     * Convert a class descriptor into an internal name.</TD></TR><TR><TD CLASS="l"><A NAME="6d">2625</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">2626</TD><TD>     * For example, descriptor Ljava/lang/Object; becomes java/lang/Object.</TD></TR><TR><TD CLASS="l">2627</TD><TD>     */</TD></TR><TR><TD CLASS="l">2628</TD><TD>    private static String classDescriptorToInternalName(String descriptor) {</TD></TR><TR CLASS="z"><TD CLASS="l">2629</TD><TD>        return descriptor.substring(1, descriptor.length() - 1);</TD></TR><TR><TD CLASS="l">2630</TD><TD>    }</TD></TR><TR><TD CLASS="l">2631</TD><TD> </TD></TR><TR><TD CLASS="l">2632</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2633</TD><TD>     * Convert a non-method type descriptor into an internal type.</TD></TR><TR><TD CLASS="l"><A NAME="6f">2634</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">2635</TD><TD>     * @param descriptor the simple type descriptor to convert</TD></TR><TR><TD CLASS="l">2636</TD><TD>     */</TD></TR><TR><TD CLASS="l">2637</TD><TD>    private static String descriptorToInternalName(String descriptor) {</TD></TR><TR CLASS="z"><TD CLASS="l">2638</TD><TD>        switch (descriptor.charAt(0)) {</TD></TR><TR><TD CLASS="l">2639</TD><TD>            case 'B':</TD></TR><TR><TD CLASS="l">2640</TD><TD>            case 'C':</TD></TR><TR><TD CLASS="l">2641</TD><TD>            case 'D':</TD></TR><TR><TD CLASS="l">2642</TD><TD>            case 'F':</TD></TR><TR><TD CLASS="l">2643</TD><TD>            case 'I':</TD></TR><TR><TD CLASS="l">2644</TD><TD>            case 'J':</TD></TR><TR><TD CLASS="l">2645</TD><TD>            case 'S':</TD></TR><TR><TD CLASS="l">2646</TD><TD>            case 'Z':</TD></TR><TR><TD CLASS="l">2647</TD><TD>            case 'V':</TD></TR><TR><TD CLASS="l">2648</TD><TD>            case '[':</TD></TR><TR CLASS="z"><TD CLASS="l">2649</TD><TD>                return descriptor;</TD></TR><TR><TD CLASS="l">2650</TD><TD>            case 'L':</TD></TR><TR CLASS="z"><TD CLASS="l">2651</TD><TD>                return classDescriptorToInternalName(descriptor);</TD></TR><TR><TD CLASS="l">2652</TD><TD>            default:</TD></TR><TR CLASS="z"><TD CLASS="l">2653</TD><TD>                throw new IllegalArgumentException(&#34;bad descriptor:&#34; +</TD></TR><TR><TD CLASS="l">2654</TD><TD>                                                   descriptor);</TD></TR><TR><TD CLASS="l">2655</TD><TD>        }</TD></TR><TR><TD CLASS="l">2656</TD><TD>    }</TD></TR><TR><TD CLASS="l">2657</TD><TD> </TD></TR><TR><TD CLASS="l">2658</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2659</TD><TD>     * Compute the initial local variable array for the current method.</TD></TR><TR><TD CLASS="l">2660</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="6e">2661</A></TD><TD>     * Creates an array of the size of the method's max locals, regardless of</TD></TR><TR><TD CLASS="l">2662</TD><TD>     * the number of parameters in the method.</TD></TR><TR><TD CLASS="l">2663</TD><TD>     */</TD></TR><TR><TD CLASS="l">2664</TD><TD>    private int[] createInitialLocals() {</TD></TR><TR CLASS="z"><TD CLASS="l">2665</TD><TD>        int[] initialLocals = new int[itsMaxLocals];</TD></TR><TR CLASS="z"><TD CLASS="l">2666</TD><TD>        int localsTop = 0;</TD></TR><TR><TD CLASS="l">2667</TD><TD>        // Instance methods require the first local variable in the array</TD></TR><TR><TD CLASS="l">2668</TD><TD>        // to be &#34;this&#34;. However, if the method being created is a</TD></TR><TR><TD CLASS="l">2669</TD><TD>        // constructor, aka the method is &lt;init&gt;, then the type of &#34;this&#34;</TD></TR><TR><TD CLASS="l">2670</TD><TD>        // should be StackMapTable.UNINITIALIZED_THIS</TD></TR><TR CLASS="z"><TD CLASS="l">2671</TD><TD>        if ((itsCurrentMethod.getFlags() &amp; ACC_STATIC) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2672</TD><TD>            if (&#34;&lt;init&gt;&#34;.equals(itsCurrentMethod.getName())) {</TD></TR><TR CLASS="z"><TD CLASS="l">2673</TD><TD>                initialLocals[localsTop++] = TypeInfo.UNINITIALIZED_THIS;</TD></TR><TR><TD CLASS="l">2674</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2675</TD><TD>                initialLocals[localsTop++] = TypeInfo.OBJECT(itsThisClassIndex);</TD></TR><TR><TD CLASS="l">2676</TD><TD>            }</TD></TR><TR><TD CLASS="l">2677</TD><TD>        }</TD></TR><TR><TD CLASS="l">2678</TD><TD> </TD></TR><TR><TD CLASS="l">2679</TD><TD>        // No error checking should be necessary, sizeOfParameters does this</TD></TR><TR CLASS="z"><TD CLASS="l">2680</TD><TD>        String type = itsCurrentMethod.getType();</TD></TR><TR CLASS="z"><TD CLASS="l">2681</TD><TD>        int lParenIndex = type.indexOf('(');</TD></TR><TR CLASS="z"><TD CLASS="l">2682</TD><TD>        int rParenIndex = type.indexOf(')');</TD></TR><TR CLASS="z"><TD CLASS="l">2683</TD><TD>        if (lParenIndex != 0 || rParenIndex &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2684</TD><TD>            throw new IllegalArgumentException(&#34;bad method type&#34;);</TD></TR><TR><TD CLASS="l">2685</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2686</TD><TD>        int start = lParenIndex + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2687</TD><TD>        StringBuilder paramType = new StringBuilder();</TD></TR><TR CLASS="z"><TD CLASS="l">2688</TD><TD>        while (start &lt; rParenIndex) {</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>            switch (type.charAt(start)) {</TD></TR><TR><TD CLASS="l">2690</TD><TD>                case 'B':</TD></TR><TR><TD CLASS="l">2691</TD><TD>                case 'C':</TD></TR><TR><TD CLASS="l">2692</TD><TD>                case 'D':</TD></TR><TR><TD CLASS="l">2693</TD><TD>                case 'F':</TD></TR><TR><TD CLASS="l">2694</TD><TD>                case 'I':</TD></TR><TR><TD CLASS="l">2695</TD><TD>                case 'J':</TD></TR><TR><TD CLASS="l">2696</TD><TD>                case 'S':</TD></TR><TR><TD CLASS="l">2697</TD><TD>                case 'Z':</TD></TR><TR CLASS="z"><TD CLASS="l">2698</TD><TD>                    paramType.append(type.charAt(start));</TD></TR><TR CLASS="z"><TD CLASS="l">2699</TD><TD>                    ++start;</TD></TR><TR CLASS="z"><TD CLASS="l">2700</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2701</TD><TD>                case 'L':</TD></TR><TR CLASS="z"><TD CLASS="l">2702</TD><TD>                    int end = type.indexOf(';', start) + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2703</TD><TD>                    String name = type.substring(start, end);</TD></TR><TR CLASS="z"><TD CLASS="l">2704</TD><TD>                    paramType.append(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2705</TD><TD>                    start = end;</TD></TR><TR CLASS="z"><TD CLASS="l">2706</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">2707</TD><TD>                case '[':</TD></TR><TR CLASS="z"><TD CLASS="l">2708</TD><TD>                    paramType.append('[');</TD></TR><TR CLASS="z"><TD CLASS="l">2709</TD><TD>                    ++start;</TD></TR><TR CLASS="z"><TD CLASS="l">2710</TD><TD>                    continue;</TD></TR><TR><TD CLASS="l">2711</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2712</TD><TD>            String internalType =</TD></TR><TR><TD CLASS="l">2713</TD><TD>                    descriptorToInternalName(paramType.toString());</TD></TR><TR CLASS="z"><TD CLASS="l">2714</TD><TD>            int typeInfo = TypeInfo.fromType(internalType, itsConstantPool);</TD></TR><TR CLASS="z"><TD CLASS="l">2715</TD><TD>            initialLocals[localsTop++] = typeInfo;</TD></TR><TR CLASS="z"><TD CLASS="l">2716</TD><TD>            if (TypeInfo.isTwoWords(typeInfo)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2717</TD><TD>                localsTop++;</TD></TR><TR><TD CLASS="l">2718</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2719</TD><TD>            paramType.setLength(0);</TD></TR><TR CLASS="z"><TD CLASS="l">2720</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2721</TD><TD>        return initialLocals;</TD></TR><TR><TD CLASS="l">2722</TD><TD>    }</TD></TR><TR><TD CLASS="l">2723</TD><TD> </TD></TR><TR><TD CLASS="l">2724</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2725</TD><TD>     * Write the class file to the OutputStream.</TD></TR><TR><TD CLASS="l">2726</TD><TD>     *</TD></TR><TR><TD CLASS="l">2727</TD><TD>     * @param oStream the stream to write to</TD></TR><TR><TD CLASS="l">2728</TD><TD>     * @throws IOException if writing to the stream produces an exception</TD></TR><TR><TD CLASS="l"><A NAME="74">2729</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">2730</TD><TD>    public void write(OutputStream oStream)</TD></TR><TR><TD CLASS="l">2731</TD><TD>        throws IOException</TD></TR><TR><TD CLASS="l">2732</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2733</TD><TD>        byte[] array = toByteArray();</TD></TR><TR CLASS="z"><TD CLASS="l">2734</TD><TD>        oStream.write(array);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a9">2735</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2736</TD><TD> </TD></TR><TR><TD CLASS="l">2737</TD><TD>    private int getWriteSize()</TD></TR><TR><TD CLASS="l">2738</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2739</TD><TD>        int size = 0;</TD></TR><TR><TD CLASS="l">2740</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2741</TD><TD>        if (itsSourceFileNameIndex != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2742</TD><TD>            itsConstantPool.addUtf8(&#34;SourceFile&#34;);</TD></TR><TR><TD CLASS="l">2743</TD><TD>        }</TD></TR><TR><TD CLASS="l">2744</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2745</TD><TD>        size += 8; //writeLong(FileHeaderConstant);</TD></TR><TR CLASS="c"><TD CLASS="l">2746</TD><TD>        size += itsConstantPool.getWriteSize();</TD></TR><TR CLASS="c"><TD CLASS="l">2747</TD><TD>        size += 2; //writeShort(itsFlags);</TD></TR><TR CLASS="c"><TD CLASS="l">2748</TD><TD>        size += 2; //writeShort(itsThisClassIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">2749</TD><TD>        size += 2; //writeShort(itsSuperClassIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">2750</TD><TD>        size += 2; //writeShort(itsInterfaces.size());</TD></TR><TR CLASS="c"><TD CLASS="l">2751</TD><TD>        size += 2 * itsInterfaces.size();</TD></TR><TR><TD CLASS="l">2752</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2753</TD><TD>        size += 2; //writeShort(itsFields.size());</TD></TR><TR CLASS="c"><TD CLASS="l">2754</TD><TD>        for (int i = 0; i &lt; itsFields.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2755</TD><TD>            size += ((ClassFileField)(itsFields.get(i))).getWriteSize();</TD></TR><TR><TD CLASS="l">2756</TD><TD>        }</TD></TR><TR><TD CLASS="l">2757</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2758</TD><TD>        size += 2; //writeShort(itsMethods.size());</TD></TR><TR CLASS="c"><TD CLASS="l">2759</TD><TD>        for (int i = 0; i &lt; itsMethods.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2760</TD><TD>            size += ((ClassFileMethod)(itsMethods.get(i))).getWriteSize();</TD></TR><TR><TD CLASS="l">2761</TD><TD>        }</TD></TR><TR><TD CLASS="l">2762</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2763</TD><TD>        if (itsSourceFileNameIndex != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2764</TD><TD>            size += 2; //writeShort(1);  attributes count</TD></TR><TR CLASS="c"><TD CLASS="l">2765</TD><TD>            size += 2; //writeShort(sourceFileAttributeNameIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">2766</TD><TD>            size += 4; //writeInt(2);</TD></TR><TR CLASS="c"><TD CLASS="l">2767</TD><TD>            size += 2; //writeShort(itsSourceFileNameIndex);</TD></TR><TR><TD CLASS="l">2768</TD><TD>        }else {</TD></TR><TR CLASS="c"><TD CLASS="l">2769</TD><TD>            size += 2; //out.writeShort(0);  no attributes</TD></TR><TR><TD CLASS="l">2770</TD><TD>        }</TD></TR><TR><TD CLASS="l">2771</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2772</TD><TD>        return size;</TD></TR><TR><TD CLASS="l">2773</TD><TD>    }</TD></TR><TR><TD CLASS="l">2774</TD><TD> </TD></TR><TR><TD CLASS="l">2775</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="8c">2776</A></TD><TD>     * Get the class file as array of bytesto the OutputStream.</TD></TR><TR><TD CLASS="l">2777</TD><TD>     */</TD></TR><TR><TD CLASS="l">2778</TD><TD>    public byte[] toByteArray()</TD></TR><TR><TD CLASS="l">2779</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2780</TD><TD>        int dataSize = getWriteSize();</TD></TR><TR CLASS="c"><TD CLASS="l">2781</TD><TD>        byte[] data = new byte[dataSize];</TD></TR><TR CLASS="c"><TD CLASS="l">2782</TD><TD>        int offset = 0;</TD></TR><TR><TD CLASS="l">2783</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2784</TD><TD>        short sourceFileAttributeNameIndex = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">2785</TD><TD>        if (itsSourceFileNameIndex != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2786</TD><TD>            sourceFileAttributeNameIndex = itsConstantPool.addUtf8(</TD></TR><TR><TD CLASS="l">2787</TD><TD>                                               &#34;SourceFile&#34;);</TD></TR><TR><TD CLASS="l">2788</TD><TD>        }</TD></TR><TR><TD CLASS="l">2789</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2790</TD><TD>        offset = putInt32(FileHeaderConstant, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2791</TD><TD>        offset = putInt16(MinorVersion, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2792</TD><TD>        offset = putInt16(MajorVersion, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2793</TD><TD>        offset = itsConstantPool.write(data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2794</TD><TD>        offset = putInt16(itsFlags, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2795</TD><TD>        offset = putInt16(itsThisClassIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2796</TD><TD>        offset = putInt16(itsSuperClassIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2797</TD><TD>        offset = putInt16(itsInterfaces.size(), data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2798</TD><TD>        for (int i = 0; i &lt; itsInterfaces.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2799</TD><TD>            int interfaceIndex = ((Short)(itsInterfaces.get(i))).shortValue();</TD></TR><TR CLASS="c"><TD CLASS="l">2800</TD><TD>            offset = putInt16(interfaceIndex, data, offset);</TD></TR><TR><TD CLASS="l">2801</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2802</TD><TD>        offset = putInt16(itsFields.size(), data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2803</TD><TD>        for (int i = 0; i &lt; itsFields.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2804</TD><TD>            ClassFileField field = (ClassFileField)itsFields.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">2805</TD><TD>            offset = field.write(data, offset);</TD></TR><TR><TD CLASS="l">2806</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2807</TD><TD>        offset = putInt16(itsMethods.size(), data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2808</TD><TD>        for (int i = 0; i &lt; itsMethods.size(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2809</TD><TD>            ClassFileMethod method = (ClassFileMethod)itsMethods.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">2810</TD><TD>            offset = method.write(data, offset);</TD></TR><TR><TD CLASS="l">2811</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2812</TD><TD>        if (itsSourceFileNameIndex != 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">2813</TD><TD>            offset = putInt16(1, data, offset); // attributes count</TD></TR><TR CLASS="c"><TD CLASS="l">2814</TD><TD>            offset = putInt16(sourceFileAttributeNameIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2815</TD><TD>            offset = putInt32(2, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2816</TD><TD>            offset = putInt16(itsSourceFileNameIndex, data, offset);</TD></TR><TR><TD CLASS="l">2817</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2818</TD><TD>            offset = putInt16(0, data, offset); // no attributes</TD></TR><TR><TD CLASS="l">2819</TD><TD>        }</TD></TR><TR><TD CLASS="l">2820</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2821</TD><TD>        if (offset != dataSize) {</TD></TR><TR><TD CLASS="l">2822</TD><TD>            // Check getWriteSize is consistent with write!</TD></TR><TR CLASS="z"><TD CLASS="l">2823</TD><TD>            throw new RuntimeException();</TD></TR><TR><TD CLASS="l">2824</TD><TD>        }</TD></TR><TR><TD CLASS="l">2825</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2826</TD><TD>        return data;</TD></TR><TR><TD CLASS="l"><A NAME="b0">2827</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2828</TD><TD> </TD></TR><TR><TD CLASS="l">2829</TD><TD>    static int putInt64(long value, byte[] array, int offset)</TD></TR><TR><TD CLASS="l">2830</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2831</TD><TD>        offset = putInt32((int)(value &gt;&gt;&gt; 32), array, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">2832</TD><TD>        return putInt32((int)value, array, offset);</TD></TR><TR><TD CLASS="l">2833</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="6b">2834</A></TD><TD> </TD></TR><TR><TD CLASS="l">2835</TD><TD>    private static void badStack(int value)</TD></TR><TR><TD CLASS="l">2836</TD><TD>    {</TD></TR><TR><TD CLASS="l">2837</TD><TD>        String s;</TD></TR><TR CLASS="z"><TD CLASS="l">2838</TD><TD>        if (value &lt; 0) { s = &#34;Stack underflow: &#34;+value; }</TD></TR><TR CLASS="z"><TD CLASS="l">2839</TD><TD>        else { s = &#34;Too big stack: &#34;+value; }</TD></TR><TR CLASS="z"><TD CLASS="l">2840</TD><TD>        throw new IllegalStateException(s);</TD></TR><TR><TD CLASS="l">2841</TD><TD>    }</TD></TR><TR><TD CLASS="l">2842</TD><TD> </TD></TR><TR><TD CLASS="l">2843</TD><TD>    /*</TD></TR><TR><TD CLASS="l">2844</TD><TD>        Really weird. Returns an int with # parameters in hi 16 bits, and</TD></TR><TR><TD CLASS="l">2845</TD><TD>        stack difference removal of parameters from stack and pushing the</TD></TR><TR><TD CLASS="l">2846</TD><TD>        result (it does not take into account removal of this in case of</TD></TR><TR><TD CLASS="l">2847</TD><TD>        non-static methods).</TD></TR><TR><TD CLASS="l">2848</TD><TD>        If Java really supported references we wouldn't have to be this</TD></TR><TR><TD CLASS="l"><A NAME="7f">2849</A></TD><TD>        perverted.</TD></TR><TR><TD CLASS="l">2850</TD><TD>    */</TD></TR><TR><TD CLASS="l">2851</TD><TD>    private static int sizeOfParameters(String pString)</TD></TR><TR><TD CLASS="l">2852</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2853</TD><TD>        int length = pString.length();</TD></TR><TR CLASS="c"><TD CLASS="l">2854</TD><TD>        int rightParenthesis = pString.lastIndexOf(')');</TD></TR><TR CLASS="c"><TD CLASS="l">2855</TD><TD>        if (3 &lt;= length /* minimal signature takes at least 3 chars: ()V */</TD></TR><TR><TD CLASS="l">2856</TD><TD>            &amp;&amp; pString.charAt(0) == '('</TD></TR><TR><TD CLASS="l">2857</TD><TD>            &amp;&amp; 1 &lt;= rightParenthesis &amp;&amp; rightParenthesis + 1 &lt; length)</TD></TR><TR><TD CLASS="l">2858</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">2859</TD><TD>            boolean ok = true;</TD></TR><TR CLASS="c"><TD CLASS="l">2860</TD><TD>            int index = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">2861</TD><TD>            int stackDiff = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">2862</TD><TD>            int count = 0;</TD></TR><TR><TD CLASS="l">2863</TD><TD>        stringLoop:</TD></TR><TR CLASS="c"><TD CLASS="l">2864</TD><TD>            while (index != rightParenthesis) {</TD></TR><TR CLASS="c"><TD CLASS="l">2865</TD><TD>                switch (pString.charAt(index)) {</TD></TR><TR><TD CLASS="l">2866</TD><TD>                    default:</TD></TR><TR CLASS="z"><TD CLASS="l">2867</TD><TD>                        ok = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2868</TD><TD>                        break stringLoop;</TD></TR><TR><TD CLASS="l">2869</TD><TD>                    case 'J' :</TD></TR><TR><TD CLASS="l">2870</TD><TD>                    case 'D' :</TD></TR><TR CLASS="c"><TD CLASS="l">2871</TD><TD>                        --stackDiff;</TD></TR><TR><TD CLASS="l">2872</TD><TD>                        // fall thru</TD></TR><TR><TD CLASS="l">2873</TD><TD>                    case 'B' :</TD></TR><TR><TD CLASS="l">2874</TD><TD>                    case 'S' :</TD></TR><TR><TD CLASS="l">2875</TD><TD>                    case 'C' :</TD></TR><TR><TD CLASS="l">2876</TD><TD>                    case 'I' :</TD></TR><TR><TD CLASS="l">2877</TD><TD>                    case 'Z' :</TD></TR><TR><TD CLASS="l">2878</TD><TD>                    case 'F' :</TD></TR><TR CLASS="c"><TD CLASS="l">2879</TD><TD>                        --stackDiff;</TD></TR><TR CLASS="c"><TD CLASS="l">2880</TD><TD>                        ++count;</TD></TR><TR CLASS="c"><TD CLASS="l">2881</TD><TD>                        ++index;</TD></TR><TR CLASS="c"><TD CLASS="l">2882</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">2883</TD><TD>                    case '[' :</TD></TR><TR CLASS="c"><TD CLASS="l">2884</TD><TD>                        ++index;</TD></TR><TR CLASS="c"><TD CLASS="l">2885</TD><TD>                        int c = pString.charAt(index);</TD></TR><TR CLASS="c"><TD CLASS="l">2886</TD><TD>                        while (c == '[') {</TD></TR><TR CLASS="z"><TD CLASS="l">2887</TD><TD>                            ++index;</TD></TR><TR CLASS="z"><TD CLASS="l">2888</TD><TD>                            c = pString.charAt(index);</TD></TR><TR><TD CLASS="l">2889</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">2890</TD><TD>                        switch (c) {</TD></TR><TR><TD CLASS="l">2891</TD><TD>                            default:</TD></TR><TR CLASS="z"><TD CLASS="l">2892</TD><TD>                                ok = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2893</TD><TD>                                break stringLoop;</TD></TR><TR><TD CLASS="l">2894</TD><TD>                            case 'J' :</TD></TR><TR><TD CLASS="l">2895</TD><TD>                            case 'D' :</TD></TR><TR><TD CLASS="l">2896</TD><TD>                            case 'B' :</TD></TR><TR><TD CLASS="l">2897</TD><TD>                            case 'S' :</TD></TR><TR><TD CLASS="l">2898</TD><TD>                            case 'C' :</TD></TR><TR><TD CLASS="l">2899</TD><TD>                            case 'I' :</TD></TR><TR><TD CLASS="l">2900</TD><TD>                            case 'Z' :</TD></TR><TR><TD CLASS="l">2901</TD><TD>                            case 'F' :</TD></TR><TR CLASS="c"><TD CLASS="l">2902</TD><TD>                                --stackDiff;</TD></TR><TR CLASS="c"><TD CLASS="l">2903</TD><TD>                                ++count;</TD></TR><TR CLASS="c"><TD CLASS="l">2904</TD><TD>                                ++index;</TD></TR><TR CLASS="c"><TD CLASS="l">2905</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">2906</TD><TD>                            case 'L':</TD></TR><TR><TD CLASS="l">2907</TD><TD>                                // fall thru</TD></TR><TR><TD CLASS="l">2908</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2909</TD><TD>                          // fall thru</TD></TR><TR><TD CLASS="l">2910</TD><TD>                    case 'L' : {</TD></TR><TR CLASS="c"><TD CLASS="l">2911</TD><TD>                        --stackDiff;</TD></TR><TR CLASS="c"><TD CLASS="l">2912</TD><TD>                        ++count;</TD></TR><TR CLASS="c"><TD CLASS="l">2913</TD><TD>                        ++index;</TD></TR><TR CLASS="c"><TD CLASS="l">2914</TD><TD>                        int semicolon = pString.indexOf(';',  index);</TD></TR><TR CLASS="c"><TD CLASS="l">2915</TD><TD>                        if (!(index + 1 &lt;= semicolon</TD></TR><TR><TD CLASS="l">2916</TD><TD>                            &amp;&amp; semicolon &lt; rightParenthesis))</TD></TR><TR><TD CLASS="l">2917</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2918</TD><TD>                            ok = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2919</TD><TD>                            break stringLoop;</TD></TR><TR><TD CLASS="l">2920</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">2921</TD><TD>                        index = semicolon + 1;</TD></TR><TR CLASS="c"><TD CLASS="l">2922</TD><TD>                        continue;</TD></TR><TR><TD CLASS="l">2923</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2924</TD><TD>                }</TD></TR><TR><TD CLASS="l">2925</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">2926</TD><TD>            if (ok) {</TD></TR><TR CLASS="c"><TD CLASS="l">2927</TD><TD>                switch (pString.charAt(rightParenthesis + 1)) {</TD></TR><TR><TD CLASS="l">2928</TD><TD>                    default:</TD></TR><TR CLASS="z"><TD CLASS="l">2929</TD><TD>                        ok = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2930</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">2931</TD><TD>                    case 'J' :</TD></TR><TR><TD CLASS="l">2932</TD><TD>                    case 'D' :</TD></TR><TR CLASS="c"><TD CLASS="l">2933</TD><TD>                        ++stackDiff;</TD></TR><TR><TD CLASS="l">2934</TD><TD>                        // fall thru</TD></TR><TR><TD CLASS="l">2935</TD><TD>                    case 'B' :</TD></TR><TR><TD CLASS="l">2936</TD><TD>                    case 'S' :</TD></TR><TR><TD CLASS="l">2937</TD><TD>                    case 'C' :</TD></TR><TR><TD CLASS="l">2938</TD><TD>                    case 'I' :</TD></TR><TR><TD CLASS="l">2939</TD><TD>                    case 'Z' :</TD></TR><TR><TD CLASS="l">2940</TD><TD>                    case 'F' :</TD></TR><TR><TD CLASS="l">2941</TD><TD>                    case 'L' :</TD></TR><TR><TD CLASS="l">2942</TD><TD>                    case '[' :</TD></TR><TR CLASS="c"><TD CLASS="l">2943</TD><TD>                        ++stackDiff;</TD></TR><TR><TD CLASS="l">2944</TD><TD>                        // fall thru</TD></TR><TR><TD CLASS="l">2945</TD><TD>                    case 'V' :</TD></TR><TR><TD CLASS="l">2946</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">2947</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2948</TD><TD>                if (ok) {</TD></TR><TR CLASS="c"><TD CLASS="l">2949</TD><TD>                    return ((count &lt;&lt; 16) | (0xFFFF &amp; stackDiff));</TD></TR><TR><TD CLASS="l">2950</TD><TD>                }</TD></TR><TR><TD CLASS="l">2951</TD><TD>            }</TD></TR><TR><TD CLASS="l">2952</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2953</TD><TD>        throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">2954</TD><TD>            &#34;Bad parameter signature: &#34;+pString);</TD></TR><TR><TD CLASS="l"><A NAME="ae">2955</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2956</TD><TD> </TD></TR><TR><TD CLASS="l">2957</TD><TD>    static int putInt16(int value, byte[] array, int offset)</TD></TR><TR><TD CLASS="l">2958</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2959</TD><TD>        array[offset + 0] = (byte)(value &gt;&gt;&gt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">2960</TD><TD>        array[offset + 1] = (byte)value;</TD></TR><TR CLASS="c"><TD CLASS="l">2961</TD><TD>        return offset + 2;</TD></TR><TR><TD CLASS="l"><A NAME="af">2962</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2963</TD><TD> </TD></TR><TR><TD CLASS="l">2964</TD><TD>    static int putInt32(int value, byte[] array, int offset)</TD></TR><TR><TD CLASS="l">2965</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2966</TD><TD>        array[offset + 0] = (byte)(value &gt;&gt;&gt; 24);</TD></TR><TR CLASS="c"><TD CLASS="l">2967</TD><TD>        array[offset + 1] = (byte)(value &gt;&gt;&gt; 16);</TD></TR><TR CLASS="c"><TD CLASS="l">2968</TD><TD>        array[offset + 2] = (byte)(value &gt;&gt;&gt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">2969</TD><TD>        array[offset + 3] = (byte)value;</TD></TR><TR CLASS="c"><TD CLASS="l">2970</TD><TD>        return offset + 4;</TD></TR><TR><TD CLASS="l">2971</TD><TD>    }</TD></TR><TR><TD CLASS="l">2972</TD><TD> </TD></TR><TR><TD CLASS="l">2973</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2974</TD><TD>     * Size of a bytecode instruction, counting the opcode and its operands.</TD></TR><TR><TD CLASS="l">2975</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="72">2976</A></TD><TD>     * This is different from opcodeCount, since opcodeCount counts logical</TD></TR><TR><TD CLASS="l">2977</TD><TD>     * operands.</TD></TR><TR><TD CLASS="l">2978</TD><TD>     */</TD></TR><TR><TD CLASS="l">2979</TD><TD>    static int opcodeLength(int opcode, boolean wide) {</TD></TR><TR CLASS="z"><TD CLASS="l">2980</TD><TD>        switch (opcode) {</TD></TR><TR><TD CLASS="l">2981</TD><TD>            case ByteCode.AALOAD:</TD></TR><TR><TD CLASS="l">2982</TD><TD>            case ByteCode.AASTORE:</TD></TR><TR><TD CLASS="l">2983</TD><TD>            case ByteCode.ACONST_NULL:</TD></TR><TR><TD CLASS="l">2984</TD><TD>            case ByteCode.ALOAD_0:</TD></TR><TR><TD CLASS="l">2985</TD><TD>            case ByteCode.ALOAD_1:</TD></TR><TR><TD CLASS="l">2986</TD><TD>            case ByteCode.ALOAD_2:</TD></TR><TR><TD CLASS="l">2987</TD><TD>            case ByteCode.ALOAD_3:</TD></TR><TR><TD CLASS="l">2988</TD><TD>            case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">2989</TD><TD>            case ByteCode.ARRAYLENGTH:</TD></TR><TR><TD CLASS="l">2990</TD><TD>            case ByteCode.ASTORE_0:</TD></TR><TR><TD CLASS="l">2991</TD><TD>            case ByteCode.ASTORE_1:</TD></TR><TR><TD CLASS="l">2992</TD><TD>            case ByteCode.ASTORE_2:</TD></TR><TR><TD CLASS="l">2993</TD><TD>            case ByteCode.ASTORE_3:</TD></TR><TR><TD CLASS="l">2994</TD><TD>            case ByteCode.ATHROW:</TD></TR><TR><TD CLASS="l">2995</TD><TD>            case ByteCode.BALOAD:</TD></TR><TR><TD CLASS="l">2996</TD><TD>            case ByteCode.BASTORE:</TD></TR><TR><TD CLASS="l">2997</TD><TD>            case ByteCode.BREAKPOINT:</TD></TR><TR><TD CLASS="l">2998</TD><TD>            case ByteCode.CALOAD:</TD></TR><TR><TD CLASS="l">2999</TD><TD>            case ByteCode.CASTORE:</TD></TR><TR><TD CLASS="l">3000</TD><TD>            case ByteCode.D2F:</TD></TR><TR><TD CLASS="l">3001</TD><TD>            case ByteCode.D2I:</TD></TR><TR><TD CLASS="l">3002</TD><TD>            case ByteCode.D2L:</TD></TR><TR><TD CLASS="l">3003</TD><TD>            case ByteCode.DADD:</TD></TR><TR><TD CLASS="l">3004</TD><TD>            case ByteCode.DALOAD:</TD></TR><TR><TD CLASS="l">3005</TD><TD>            case ByteCode.DASTORE:</TD></TR><TR><TD CLASS="l">3006</TD><TD>            case ByteCode.DCMPG:</TD></TR><TR><TD CLASS="l">3007</TD><TD>            case ByteCode.DCMPL:</TD></TR><TR><TD CLASS="l">3008</TD><TD>            case ByteCode.DCONST_0:</TD></TR><TR><TD CLASS="l">3009</TD><TD>            case ByteCode.DCONST_1:</TD></TR><TR><TD CLASS="l">3010</TD><TD>            case ByteCode.DDIV:</TD></TR><TR><TD CLASS="l">3011</TD><TD>            case ByteCode.DLOAD_0:</TD></TR><TR><TD CLASS="l">3012</TD><TD>            case ByteCode.DLOAD_1:</TD></TR><TR><TD CLASS="l">3013</TD><TD>            case ByteCode.DLOAD_2:</TD></TR><TR><TD CLASS="l">3014</TD><TD>            case ByteCode.DLOAD_3:</TD></TR><TR><TD CLASS="l">3015</TD><TD>            case ByteCode.DMUL:</TD></TR><TR><TD CLASS="l">3016</TD><TD>            case ByteCode.DNEG:</TD></TR><TR><TD CLASS="l">3017</TD><TD>            case ByteCode.DREM:</TD></TR><TR><TD CLASS="l">3018</TD><TD>            case ByteCode.DRETURN:</TD></TR><TR><TD CLASS="l">3019</TD><TD>            case ByteCode.DSTORE_0:</TD></TR><TR><TD CLASS="l">3020</TD><TD>            case ByteCode.DSTORE_1:</TD></TR><TR><TD CLASS="l">3021</TD><TD>            case ByteCode.DSTORE_2:</TD></TR><TR><TD CLASS="l">3022</TD><TD>            case ByteCode.DSTORE_3:</TD></TR><TR><TD CLASS="l">3023</TD><TD>            case ByteCode.DSUB:</TD></TR><TR><TD CLASS="l">3024</TD><TD>            case ByteCode.DUP:</TD></TR><TR><TD CLASS="l">3025</TD><TD>            case ByteCode.DUP2:</TD></TR><TR><TD CLASS="l">3026</TD><TD>            case ByteCode.DUP2_X1:</TD></TR><TR><TD CLASS="l">3027</TD><TD>            case ByteCode.DUP2_X2:</TD></TR><TR><TD CLASS="l">3028</TD><TD>            case ByteCode.DUP_X1:</TD></TR><TR><TD CLASS="l">3029</TD><TD>            case ByteCode.DUP_X2:</TD></TR><TR><TD CLASS="l">3030</TD><TD>            case ByteCode.F2D:</TD></TR><TR><TD CLASS="l">3031</TD><TD>            case ByteCode.F2I:</TD></TR><TR><TD CLASS="l">3032</TD><TD>            case ByteCode.F2L:</TD></TR><TR><TD CLASS="l">3033</TD><TD>            case ByteCode.FADD:</TD></TR><TR><TD CLASS="l">3034</TD><TD>            case ByteCode.FALOAD:</TD></TR><TR><TD CLASS="l">3035</TD><TD>            case ByteCode.FASTORE:</TD></TR><TR><TD CLASS="l">3036</TD><TD>            case ByteCode.FCMPG:</TD></TR><TR><TD CLASS="l">3037</TD><TD>            case ByteCode.FCMPL:</TD></TR><TR><TD CLASS="l">3038</TD><TD>            case ByteCode.FCONST_0:</TD></TR><TR><TD CLASS="l">3039</TD><TD>            case ByteCode.FCONST_1:</TD></TR><TR><TD CLASS="l">3040</TD><TD>            case ByteCode.FCONST_2:</TD></TR><TR><TD CLASS="l">3041</TD><TD>            case ByteCode.FDIV:</TD></TR><TR><TD CLASS="l">3042</TD><TD>            case ByteCode.FLOAD_0:</TD></TR><TR><TD CLASS="l">3043</TD><TD>            case ByteCode.FLOAD_1:</TD></TR><TR><TD CLASS="l">3044</TD><TD>            case ByteCode.FLOAD_2:</TD></TR><TR><TD CLASS="l">3045</TD><TD>            case ByteCode.FLOAD_3:</TD></TR><TR><TD CLASS="l">3046</TD><TD>            case ByteCode.FMUL:</TD></TR><TR><TD CLASS="l">3047</TD><TD>            case ByteCode.FNEG:</TD></TR><TR><TD CLASS="l">3048</TD><TD>            case ByteCode.FREM:</TD></TR><TR><TD CLASS="l">3049</TD><TD>            case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">3050</TD><TD>            case ByteCode.FSTORE_0:</TD></TR><TR><TD CLASS="l">3051</TD><TD>            case ByteCode.FSTORE_1:</TD></TR><TR><TD CLASS="l">3052</TD><TD>            case ByteCode.FSTORE_2:</TD></TR><TR><TD CLASS="l">3053</TD><TD>            case ByteCode.FSTORE_3:</TD></TR><TR><TD CLASS="l">3054</TD><TD>            case ByteCode.FSUB:</TD></TR><TR><TD CLASS="l">3055</TD><TD>            case ByteCode.I2B:</TD></TR><TR><TD CLASS="l">3056</TD><TD>            case ByteCode.I2C:</TD></TR><TR><TD CLASS="l">3057</TD><TD>            case ByteCode.I2D:</TD></TR><TR><TD CLASS="l">3058</TD><TD>            case ByteCode.I2F:</TD></TR><TR><TD CLASS="l">3059</TD><TD>            case ByteCode.I2L:</TD></TR><TR><TD CLASS="l">3060</TD><TD>            case ByteCode.I2S:</TD></TR><TR><TD CLASS="l">3061</TD><TD>            case ByteCode.IADD:</TD></TR><TR><TD CLASS="l">3062</TD><TD>            case ByteCode.IALOAD:</TD></TR><TR><TD CLASS="l">3063</TD><TD>            case ByteCode.IAND:</TD></TR><TR><TD CLASS="l">3064</TD><TD>            case ByteCode.IASTORE:</TD></TR><TR><TD CLASS="l">3065</TD><TD>            case ByteCode.ICONST_0:</TD></TR><TR><TD CLASS="l">3066</TD><TD>            case ByteCode.ICONST_1:</TD></TR><TR><TD CLASS="l">3067</TD><TD>            case ByteCode.ICONST_2:</TD></TR><TR><TD CLASS="l">3068</TD><TD>            case ByteCode.ICONST_3:</TD></TR><TR><TD CLASS="l">3069</TD><TD>            case ByteCode.ICONST_4:</TD></TR><TR><TD CLASS="l">3070</TD><TD>            case ByteCode.ICONST_5:</TD></TR><TR><TD CLASS="l">3071</TD><TD>            case ByteCode.ICONST_M1:</TD></TR><TR><TD CLASS="l">3072</TD><TD>            case ByteCode.IDIV:</TD></TR><TR><TD CLASS="l">3073</TD><TD>            case ByteCode.ILOAD_0:</TD></TR><TR><TD CLASS="l">3074</TD><TD>            case ByteCode.ILOAD_1:</TD></TR><TR><TD CLASS="l">3075</TD><TD>            case ByteCode.ILOAD_2:</TD></TR><TR><TD CLASS="l">3076</TD><TD>            case ByteCode.ILOAD_3:</TD></TR><TR><TD CLASS="l">3077</TD><TD>            case ByteCode.IMPDEP1:</TD></TR><TR><TD CLASS="l">3078</TD><TD>            case ByteCode.IMPDEP2:</TD></TR><TR><TD CLASS="l">3079</TD><TD>            case ByteCode.IMUL:</TD></TR><TR><TD CLASS="l">3080</TD><TD>            case ByteCode.INEG:</TD></TR><TR><TD CLASS="l">3081</TD><TD>            case ByteCode.IOR:</TD></TR><TR><TD CLASS="l">3082</TD><TD>            case ByteCode.IREM:</TD></TR><TR><TD CLASS="l">3083</TD><TD>            case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">3084</TD><TD>            case ByteCode.ISHL:</TD></TR><TR><TD CLASS="l">3085</TD><TD>            case ByteCode.ISHR:</TD></TR><TR><TD CLASS="l">3086</TD><TD>            case ByteCode.ISTORE_0:</TD></TR><TR><TD CLASS="l">3087</TD><TD>            case ByteCode.ISTORE_1:</TD></TR><TR><TD CLASS="l">3088</TD><TD>            case ByteCode.ISTORE_2:</TD></TR><TR><TD CLASS="l">3089</TD><TD>            case ByteCode.ISTORE_3:</TD></TR><TR><TD CLASS="l">3090</TD><TD>            case ByteCode.ISUB:</TD></TR><TR><TD CLASS="l">3091</TD><TD>            case ByteCode.IUSHR:</TD></TR><TR><TD CLASS="l">3092</TD><TD>            case ByteCode.IXOR:</TD></TR><TR><TD CLASS="l">3093</TD><TD>            case ByteCode.L2D:</TD></TR><TR><TD CLASS="l">3094</TD><TD>            case ByteCode.L2F:</TD></TR><TR><TD CLASS="l">3095</TD><TD>            case ByteCode.L2I:</TD></TR><TR><TD CLASS="l">3096</TD><TD>            case ByteCode.LADD:</TD></TR><TR><TD CLASS="l">3097</TD><TD>            case ByteCode.LALOAD:</TD></TR><TR><TD CLASS="l">3098</TD><TD>            case ByteCode.LAND:</TD></TR><TR><TD CLASS="l">3099</TD><TD>            case ByteCode.LASTORE:</TD></TR><TR><TD CLASS="l">3100</TD><TD>            case ByteCode.LCMP:</TD></TR><TR><TD CLASS="l">3101</TD><TD>            case ByteCode.LCONST_0:</TD></TR><TR><TD CLASS="l">3102</TD><TD>            case ByteCode.LCONST_1:</TD></TR><TR><TD CLASS="l">3103</TD><TD>            case ByteCode.LDIV:</TD></TR><TR><TD CLASS="l">3104</TD><TD>            case ByteCode.LLOAD_0:</TD></TR><TR><TD CLASS="l">3105</TD><TD>            case ByteCode.LLOAD_1:</TD></TR><TR><TD CLASS="l">3106</TD><TD>            case ByteCode.LLOAD_2:</TD></TR><TR><TD CLASS="l">3107</TD><TD>            case ByteCode.LLOAD_3:</TD></TR><TR><TD CLASS="l">3108</TD><TD>            case ByteCode.LMUL:</TD></TR><TR><TD CLASS="l">3109</TD><TD>            case ByteCode.LNEG:</TD></TR><TR><TD CLASS="l">3110</TD><TD>            case ByteCode.LOR:</TD></TR><TR><TD CLASS="l">3111</TD><TD>            case ByteCode.LREM:</TD></TR><TR><TD CLASS="l">3112</TD><TD>            case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">3113</TD><TD>            case ByteCode.LSHL:</TD></TR><TR><TD CLASS="l">3114</TD><TD>            case ByteCode.LSHR:</TD></TR><TR><TD CLASS="l">3115</TD><TD>            case ByteCode.LSTORE_0:</TD></TR><TR><TD CLASS="l">3116</TD><TD>            case ByteCode.LSTORE_1:</TD></TR><TR><TD CLASS="l">3117</TD><TD>            case ByteCode.LSTORE_2:</TD></TR><TR><TD CLASS="l">3118</TD><TD>            case ByteCode.LSTORE_3:</TD></TR><TR><TD CLASS="l">3119</TD><TD>            case ByteCode.LSUB:</TD></TR><TR><TD CLASS="l">3120</TD><TD>            case ByteCode.LUSHR:</TD></TR><TR><TD CLASS="l">3121</TD><TD>            case ByteCode.LXOR:</TD></TR><TR><TD CLASS="l">3122</TD><TD>            case ByteCode.MONITORENTER:</TD></TR><TR><TD CLASS="l">3123</TD><TD>            case ByteCode.MONITOREXIT:</TD></TR><TR><TD CLASS="l">3124</TD><TD>            case ByteCode.NOP:</TD></TR><TR><TD CLASS="l">3125</TD><TD>            case ByteCode.POP:</TD></TR><TR><TD CLASS="l">3126</TD><TD>            case ByteCode.POP2:</TD></TR><TR><TD CLASS="l">3127</TD><TD>            case ByteCode.RETURN:</TD></TR><TR><TD CLASS="l">3128</TD><TD>            case ByteCode.SALOAD:</TD></TR><TR><TD CLASS="l">3129</TD><TD>            case ByteCode.SASTORE:</TD></TR><TR><TD CLASS="l">3130</TD><TD>            case ByteCode.SWAP:</TD></TR><TR><TD CLASS="l">3131</TD><TD>            case ByteCode.WIDE:</TD></TR><TR CLASS="z"><TD CLASS="l">3132</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">3133</TD><TD>            case ByteCode.BIPUSH:</TD></TR><TR><TD CLASS="l">3134</TD><TD>            case ByteCode.LDC:</TD></TR><TR><TD CLASS="l">3135</TD><TD>            case ByteCode.NEWARRAY:</TD></TR><TR CLASS="z"><TD CLASS="l">3136</TD><TD>                return 2;</TD></TR><TR><TD CLASS="l">3137</TD><TD>            case ByteCode.ALOAD:</TD></TR><TR><TD CLASS="l">3138</TD><TD>            case ByteCode.ASTORE:</TD></TR><TR><TD CLASS="l">3139</TD><TD>            case ByteCode.DLOAD:</TD></TR><TR><TD CLASS="l">3140</TD><TD>            case ByteCode.DSTORE:</TD></TR><TR><TD CLASS="l">3141</TD><TD>            case ByteCode.FLOAD:</TD></TR><TR><TD CLASS="l">3142</TD><TD>            case ByteCode.FSTORE:</TD></TR><TR><TD CLASS="l">3143</TD><TD>            case ByteCode.ILOAD:</TD></TR><TR><TD CLASS="l">3144</TD><TD>            case ByteCode.ISTORE:</TD></TR><TR><TD CLASS="l">3145</TD><TD>            case ByteCode.LLOAD:</TD></TR><TR><TD CLASS="l">3146</TD><TD>            case ByteCode.LSTORE:</TD></TR><TR><TD CLASS="l">3147</TD><TD>            case ByteCode.RET:</TD></TR><TR CLASS="z"><TD CLASS="l">3148</TD><TD>                return wide ? 3 : 2;</TD></TR><TR><TD CLASS="l">3149</TD><TD> </TD></TR><TR><TD CLASS="l">3150</TD><TD>            case ByteCode.ANEWARRAY:</TD></TR><TR><TD CLASS="l">3151</TD><TD>            case ByteCode.CHECKCAST:</TD></TR><TR><TD CLASS="l">3152</TD><TD>            case ByteCode.GETFIELD:</TD></TR><TR><TD CLASS="l">3153</TD><TD>            case ByteCode.GETSTATIC:</TD></TR><TR><TD CLASS="l">3154</TD><TD>            case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">3155</TD><TD>            case ByteCode.IFEQ:</TD></TR><TR><TD CLASS="l">3156</TD><TD>            case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">3157</TD><TD>            case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">3158</TD><TD>            case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">3159</TD><TD>            case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">3160</TD><TD>            case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">3161</TD><TD>            case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">3162</TD><TD>            case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">3163</TD><TD>            case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">3164</TD><TD>            case ByteCode.IF_ACMPNE:</TD></TR><TR><TD CLASS="l">3165</TD><TD>            case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">3166</TD><TD>            case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">3167</TD><TD>            case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">3168</TD><TD>            case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">3169</TD><TD>            case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">3170</TD><TD>            case ByteCode.IF_ICMPNE:</TD></TR><TR><TD CLASS="l">3171</TD><TD>            case ByteCode.INSTANCEOF:</TD></TR><TR><TD CLASS="l">3172</TD><TD>            case ByteCode.INVOKESPECIAL:</TD></TR><TR><TD CLASS="l">3173</TD><TD>            case ByteCode.INVOKESTATIC:</TD></TR><TR><TD CLASS="l">3174</TD><TD>            case ByteCode.INVOKEVIRTUAL:</TD></TR><TR><TD CLASS="l">3175</TD><TD>            case ByteCode.JSR:</TD></TR><TR><TD CLASS="l">3176</TD><TD>            case ByteCode.LDC_W:</TD></TR><TR><TD CLASS="l">3177</TD><TD>            case ByteCode.LDC2_W:</TD></TR><TR><TD CLASS="l">3178</TD><TD>            case ByteCode.NEW:</TD></TR><TR><TD CLASS="l">3179</TD><TD>            case ByteCode.PUTFIELD:</TD></TR><TR><TD CLASS="l">3180</TD><TD>            case ByteCode.PUTSTATIC:</TD></TR><TR><TD CLASS="l">3181</TD><TD>            case ByteCode.SIPUSH:</TD></TR><TR CLASS="z"><TD CLASS="l">3182</TD><TD>                return 3;</TD></TR><TR><TD CLASS="l">3183</TD><TD> </TD></TR><TR><TD CLASS="l">3184</TD><TD>            case ByteCode.IINC:</TD></TR><TR CLASS="z"><TD CLASS="l">3185</TD><TD>                return wide ? 5 : 3;</TD></TR><TR><TD CLASS="l">3186</TD><TD> </TD></TR><TR><TD CLASS="l">3187</TD><TD>            case ByteCode.MULTIANEWARRAY:</TD></TR><TR CLASS="z"><TD CLASS="l">3188</TD><TD>                return 4;</TD></TR><TR><TD CLASS="l">3189</TD><TD> </TD></TR><TR><TD CLASS="l">3190</TD><TD>            case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">3191</TD><TD>            case ByteCode.INVOKEINTERFACE:</TD></TR><TR><TD CLASS="l">3192</TD><TD>            case ByteCode.JSR_W:</TD></TR><TR CLASS="z"><TD CLASS="l">3193</TD><TD>                return 5;</TD></TR><TR><TD CLASS="l">3194</TD><TD> </TD></TR><TR><TD CLASS="l">3195</TD><TD>            /*</TD></TR><TR><TD CLASS="l">3196</TD><TD>            case ByteCode.LOOKUPSWITCH:</TD></TR><TR><TD CLASS="l">3197</TD><TD>            case ByteCode.TABLESWITCH:</TD></TR><TR><TD CLASS="l">3198</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">3199</TD><TD>            */</TD></TR><TR><TD CLASS="l">3200</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3201</TD><TD>        throw new IllegalArgumentException(&#34;Bad opcode: &#34; + opcode);</TD></TR><TR><TD CLASS="l">3202</TD><TD>    }</TD></TR><TR><TD CLASS="l">3203</TD><TD> </TD></TR><TR><TD CLASS="l">3204</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="76">3205</A></TD><TD>     * Number of operands accompanying the opcode.</TD></TR><TR><TD CLASS="l">3206</TD><TD>     */</TD></TR><TR><TD CLASS="l">3207</TD><TD>    static int opcodeCount(int opcode)</TD></TR><TR><TD CLASS="l">3208</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">3209</TD><TD>        switch (opcode) {</TD></TR><TR><TD CLASS="l">3210</TD><TD>            case ByteCode.AALOAD:</TD></TR><TR><TD CLASS="l">3211</TD><TD>            case ByteCode.AASTORE:</TD></TR><TR><TD CLASS="l">3212</TD><TD>            case ByteCode.ACONST_NULL:</TD></TR><TR><TD CLASS="l">3213</TD><TD>            case ByteCode.ALOAD_0:</TD></TR><TR><TD CLASS="l">3214</TD><TD>            case ByteCode.ALOAD_1:</TD></TR><TR><TD CLASS="l">3215</TD><TD>            case ByteCode.ALOAD_2:</TD></TR><TR><TD CLASS="l">3216</TD><TD>            case ByteCode.ALOAD_3:</TD></TR><TR><TD CLASS="l">3217</TD><TD>            case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">3218</TD><TD>            case ByteCode.ARRAYLENGTH:</TD></TR><TR><TD CLASS="l">3219</TD><TD>            case ByteCode.ASTORE_0:</TD></TR><TR><TD CLASS="l">3220</TD><TD>            case ByteCode.ASTORE_1:</TD></TR><TR><TD CLASS="l">3221</TD><TD>            case ByteCode.ASTORE_2:</TD></TR><TR><TD CLASS="l">3222</TD><TD>            case ByteCode.ASTORE_3:</TD></TR><TR><TD CLASS="l">3223</TD><TD>            case ByteCode.ATHROW:</TD></TR><TR><TD CLASS="l">3224</TD><TD>            case ByteCode.BALOAD:</TD></TR><TR><TD CLASS="l">3225</TD><TD>            case ByteCode.BASTORE:</TD></TR><TR><TD CLASS="l">3226</TD><TD>            case ByteCode.BREAKPOINT:</TD></TR><TR><TD CLASS="l">3227</TD><TD>            case ByteCode.CALOAD:</TD></TR><TR><TD CLASS="l">3228</TD><TD>            case ByteCode.CASTORE:</TD></TR><TR><TD CLASS="l">3229</TD><TD>            case ByteCode.D2F:</TD></TR><TR><TD CLASS="l">3230</TD><TD>            case ByteCode.D2I:</TD></TR><TR><TD CLASS="l">3231</TD><TD>            case ByteCode.D2L:</TD></TR><TR><TD CLASS="l">3232</TD><TD>            case ByteCode.DADD:</TD></TR><TR><TD CLASS="l">3233</TD><TD>            case ByteCode.DALOAD:</TD></TR><TR><TD CLASS="l">3234</TD><TD>            case ByteCode.DASTORE:</TD></TR><TR><TD CLASS="l">3235</TD><TD>            case ByteCode.DCMPG:</TD></TR><TR><TD CLASS="l">3236</TD><TD>            case ByteCode.DCMPL:</TD></TR><TR><TD CLASS="l">3237</TD><TD>            case ByteCode.DCONST_0:</TD></TR><TR><TD CLASS="l">3238</TD><TD>            case ByteCode.DCONST_1:</TD></TR><TR><TD CLASS="l">3239</TD><TD>            case ByteCode.DDIV:</TD></TR><TR><TD CLASS="l">3240</TD><TD>            case ByteCode.DLOAD_0:</TD></TR><TR><TD CLASS="l">3241</TD><TD>            case ByteCode.DLOAD_1:</TD></TR><TR><TD CLASS="l">3242</TD><TD>            case ByteCode.DLOAD_2:</TD></TR><TR><TD CLASS="l">3243</TD><TD>            case ByteCode.DLOAD_3:</TD></TR><TR><TD CLASS="l">3244</TD><TD>            case ByteCode.DMUL:</TD></TR><TR><TD CLASS="l">3245</TD><TD>            case ByteCode.DNEG:</TD></TR><TR><TD CLASS="l">3246</TD><TD>            case ByteCode.DREM:</TD></TR><TR><TD CLASS="l">3247</TD><TD>            case ByteCode.DRETURN:</TD></TR><TR><TD CLASS="l">3248</TD><TD>            case ByteCode.DSTORE_0:</TD></TR><TR><TD CLASS="l">3249</TD><TD>            case ByteCode.DSTORE_1:</TD></TR><TR><TD CLASS="l">3250</TD><TD>            case ByteCode.DSTORE_2:</TD></TR><TR><TD CLASS="l">3251</TD><TD>            case ByteCode.DSTORE_3:</TD></TR><TR><TD CLASS="l">3252</TD><TD>            case ByteCode.DSUB:</TD></TR><TR><TD CLASS="l">3253</TD><TD>            case ByteCode.DUP:</TD></TR><TR><TD CLASS="l">3254</TD><TD>            case ByteCode.DUP2:</TD></TR><TR><TD CLASS="l">3255</TD><TD>            case ByteCode.DUP2_X1:</TD></TR><TR><TD CLASS="l">3256</TD><TD>            case ByteCode.DUP2_X2:</TD></TR><TR><TD CLASS="l">3257</TD><TD>            case ByteCode.DUP_X1:</TD></TR><TR><TD CLASS="l">3258</TD><TD>            case ByteCode.DUP_X2:</TD></TR><TR><TD CLASS="l">3259</TD><TD>            case ByteCode.F2D:</TD></TR><TR><TD CLASS="l">3260</TD><TD>            case ByteCode.F2I:</TD></TR><TR><TD CLASS="l">3261</TD><TD>            case ByteCode.F2L:</TD></TR><TR><TD CLASS="l">3262</TD><TD>            case ByteCode.FADD:</TD></TR><TR><TD CLASS="l">3263</TD><TD>            case ByteCode.FALOAD:</TD></TR><TR><TD CLASS="l">3264</TD><TD>            case ByteCode.FASTORE:</TD></TR><TR><TD CLASS="l">3265</TD><TD>            case ByteCode.FCMPG:</TD></TR><TR><TD CLASS="l">3266</TD><TD>            case ByteCode.FCMPL:</TD></TR><TR><TD CLASS="l">3267</TD><TD>            case ByteCode.FCONST_0:</TD></TR><TR><TD CLASS="l">3268</TD><TD>            case ByteCode.FCONST_1:</TD></TR><TR><TD CLASS="l">3269</TD><TD>            case ByteCode.FCONST_2:</TD></TR><TR><TD CLASS="l">3270</TD><TD>            case ByteCode.FDIV:</TD></TR><TR><TD CLASS="l">3271</TD><TD>            case ByteCode.FLOAD_0:</TD></TR><TR><TD CLASS="l">3272</TD><TD>            case ByteCode.FLOAD_1:</TD></TR><TR><TD CLASS="l">3273</TD><TD>            case ByteCode.FLOAD_2:</TD></TR><TR><TD CLASS="l">3274</TD><TD>            case ByteCode.FLOAD_3:</TD></TR><TR><TD CLASS="l">3275</TD><TD>            case ByteCode.FMUL:</TD></TR><TR><TD CLASS="l">3276</TD><TD>            case ByteCode.FNEG:</TD></TR><TR><TD CLASS="l">3277</TD><TD>            case ByteCode.FREM:</TD></TR><TR><TD CLASS="l">3278</TD><TD>            case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">3279</TD><TD>            case ByteCode.FSTORE_0:</TD></TR><TR><TD CLASS="l">3280</TD><TD>            case ByteCode.FSTORE_1:</TD></TR><TR><TD CLASS="l">3281</TD><TD>            case ByteCode.FSTORE_2:</TD></TR><TR><TD CLASS="l">3282</TD><TD>            case ByteCode.FSTORE_3:</TD></TR><TR><TD CLASS="l">3283</TD><TD>            case ByteCode.FSUB:</TD></TR><TR><TD CLASS="l">3284</TD><TD>            case ByteCode.I2B:</TD></TR><TR><TD CLASS="l">3285</TD><TD>            case ByteCode.I2C:</TD></TR><TR><TD CLASS="l">3286</TD><TD>            case ByteCode.I2D:</TD></TR><TR><TD CLASS="l">3287</TD><TD>            case ByteCode.I2F:</TD></TR><TR><TD CLASS="l">3288</TD><TD>            case ByteCode.I2L:</TD></TR><TR><TD CLASS="l">3289</TD><TD>            case ByteCode.I2S:</TD></TR><TR><TD CLASS="l">3290</TD><TD>            case ByteCode.IADD:</TD></TR><TR><TD CLASS="l">3291</TD><TD>            case ByteCode.IALOAD:</TD></TR><TR><TD CLASS="l">3292</TD><TD>            case ByteCode.IAND:</TD></TR><TR><TD CLASS="l">3293</TD><TD>            case ByteCode.IASTORE:</TD></TR><TR><TD CLASS="l">3294</TD><TD>            case ByteCode.ICONST_0:</TD></TR><TR><TD CLASS="l">3295</TD><TD>            case ByteCode.ICONST_1:</TD></TR><TR><TD CLASS="l">3296</TD><TD>            case ByteCode.ICONST_2:</TD></TR><TR><TD CLASS="l">3297</TD><TD>            case ByteCode.ICONST_3:</TD></TR><TR><TD CLASS="l">3298</TD><TD>            case ByteCode.ICONST_4:</TD></TR><TR><TD CLASS="l">3299</TD><TD>            case ByteCode.ICONST_5:</TD></TR><TR><TD CLASS="l">3300</TD><TD>            case ByteCode.ICONST_M1:</TD></TR><TR><TD CLASS="l">3301</TD><TD>            case ByteCode.IDIV:</TD></TR><TR><TD CLASS="l">3302</TD><TD>            case ByteCode.ILOAD_0:</TD></TR><TR><TD CLASS="l">3303</TD><TD>            case ByteCode.ILOAD_1:</TD></TR><TR><TD CLASS="l">3304</TD><TD>            case ByteCode.ILOAD_2:</TD></TR><TR><TD CLASS="l">3305</TD><TD>            case ByteCode.ILOAD_3:</TD></TR><TR><TD CLASS="l">3306</TD><TD>            case ByteCode.IMPDEP1:</TD></TR><TR><TD CLASS="l">3307</TD><TD>            case ByteCode.IMPDEP2:</TD></TR><TR><TD CLASS="l">3308</TD><TD>            case ByteCode.IMUL:</TD></TR><TR><TD CLASS="l">3309</TD><TD>            case ByteCode.INEG:</TD></TR><TR><TD CLASS="l">3310</TD><TD>            case ByteCode.IOR:</TD></TR><TR><TD CLASS="l">3311</TD><TD>            case ByteCode.IREM:</TD></TR><TR><TD CLASS="l">3312</TD><TD>            case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">3313</TD><TD>            case ByteCode.ISHL:</TD></TR><TR><TD CLASS="l">3314</TD><TD>            case ByteCode.ISHR:</TD></TR><TR><TD CLASS="l">3315</TD><TD>            case ByteCode.ISTORE_0:</TD></TR><TR><TD CLASS="l">3316</TD><TD>            case ByteCode.ISTORE_1:</TD></TR><TR><TD CLASS="l">3317</TD><TD>            case ByteCode.ISTORE_2:</TD></TR><TR><TD CLASS="l">3318</TD><TD>            case ByteCode.ISTORE_3:</TD></TR><TR><TD CLASS="l">3319</TD><TD>            case ByteCode.ISUB:</TD></TR><TR><TD CLASS="l">3320</TD><TD>            case ByteCode.IUSHR:</TD></TR><TR><TD CLASS="l">3321</TD><TD>            case ByteCode.IXOR:</TD></TR><TR><TD CLASS="l">3322</TD><TD>            case ByteCode.L2D:</TD></TR><TR><TD CLASS="l">3323</TD><TD>            case ByteCode.L2F:</TD></TR><TR><TD CLASS="l">3324</TD><TD>            case ByteCode.L2I:</TD></TR><TR><TD CLASS="l">3325</TD><TD>            case ByteCode.LADD:</TD></TR><TR><TD CLASS="l">3326</TD><TD>            case ByteCode.LALOAD:</TD></TR><TR><TD CLASS="l">3327</TD><TD>            case ByteCode.LAND:</TD></TR><TR><TD CLASS="l">3328</TD><TD>            case ByteCode.LASTORE:</TD></TR><TR><TD CLASS="l">3329</TD><TD>            case ByteCode.LCMP:</TD></TR><TR><TD CLASS="l">3330</TD><TD>            case ByteCode.LCONST_0:</TD></TR><TR><TD CLASS="l">3331</TD><TD>            case ByteCode.LCONST_1:</TD></TR><TR><TD CLASS="l">3332</TD><TD>            case ByteCode.LDIV:</TD></TR><TR><TD CLASS="l">3333</TD><TD>            case ByteCode.LLOAD_0:</TD></TR><TR><TD CLASS="l">3334</TD><TD>            case ByteCode.LLOAD_1:</TD></TR><TR><TD CLASS="l">3335</TD><TD>            case ByteCode.LLOAD_2:</TD></TR><TR><TD CLASS="l">3336</TD><TD>            case ByteCode.LLOAD_3:</TD></TR><TR><TD CLASS="l">3337</TD><TD>            case ByteCode.LMUL:</TD></TR><TR><TD CLASS="l">3338</TD><TD>            case ByteCode.LNEG:</TD></TR><TR><TD CLASS="l">3339</TD><TD>            case ByteCode.LOR:</TD></TR><TR><TD CLASS="l">3340</TD><TD>            case ByteCode.LREM:</TD></TR><TR><TD CLASS="l">3341</TD><TD>            case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">3342</TD><TD>            case ByteCode.LSHL:</TD></TR><TR><TD CLASS="l">3343</TD><TD>            case ByteCode.LSHR:</TD></TR><TR><TD CLASS="l">3344</TD><TD>            case ByteCode.LSTORE_0:</TD></TR><TR><TD CLASS="l">3345</TD><TD>            case ByteCode.LSTORE_1:</TD></TR><TR><TD CLASS="l">3346</TD><TD>            case ByteCode.LSTORE_2:</TD></TR><TR><TD CLASS="l">3347</TD><TD>            case ByteCode.LSTORE_3:</TD></TR><TR><TD CLASS="l">3348</TD><TD>            case ByteCode.LSUB:</TD></TR><TR><TD CLASS="l">3349</TD><TD>            case ByteCode.LUSHR:</TD></TR><TR><TD CLASS="l">3350</TD><TD>            case ByteCode.LXOR:</TD></TR><TR><TD CLASS="l">3351</TD><TD>            case ByteCode.MONITORENTER:</TD></TR><TR><TD CLASS="l">3352</TD><TD>            case ByteCode.MONITOREXIT:</TD></TR><TR><TD CLASS="l">3353</TD><TD>            case ByteCode.NOP:</TD></TR><TR><TD CLASS="l">3354</TD><TD>            case ByteCode.POP:</TD></TR><TR><TD CLASS="l">3355</TD><TD>            case ByteCode.POP2:</TD></TR><TR><TD CLASS="l">3356</TD><TD>            case ByteCode.RETURN:</TD></TR><TR><TD CLASS="l">3357</TD><TD>            case ByteCode.SALOAD:</TD></TR><TR><TD CLASS="l">3358</TD><TD>            case ByteCode.SASTORE:</TD></TR><TR><TD CLASS="l">3359</TD><TD>            case ByteCode.SWAP:</TD></TR><TR><TD CLASS="l">3360</TD><TD>            case ByteCode.WIDE:</TD></TR><TR CLASS="c"><TD CLASS="l">3361</TD><TD>                return 0;</TD></TR><TR><TD CLASS="l">3362</TD><TD>            case ByteCode.ALOAD:</TD></TR><TR><TD CLASS="l">3363</TD><TD>            case ByteCode.ANEWARRAY:</TD></TR><TR><TD CLASS="l">3364</TD><TD>            case ByteCode.ASTORE:</TD></TR><TR><TD CLASS="l">3365</TD><TD>            case ByteCode.BIPUSH:</TD></TR><TR><TD CLASS="l">3366</TD><TD>            case ByteCode.CHECKCAST:</TD></TR><TR><TD CLASS="l">3367</TD><TD>            case ByteCode.DLOAD:</TD></TR><TR><TD CLASS="l">3368</TD><TD>            case ByteCode.DSTORE:</TD></TR><TR><TD CLASS="l">3369</TD><TD>            case ByteCode.FLOAD:</TD></TR><TR><TD CLASS="l">3370</TD><TD>            case ByteCode.FSTORE:</TD></TR><TR><TD CLASS="l">3371</TD><TD>            case ByteCode.GETFIELD:</TD></TR><TR><TD CLASS="l">3372</TD><TD>            case ByteCode.GETSTATIC:</TD></TR><TR><TD CLASS="l">3373</TD><TD>            case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">3374</TD><TD>            case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">3375</TD><TD>            case ByteCode.IFEQ:</TD></TR><TR><TD CLASS="l">3376</TD><TD>            case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">3377</TD><TD>            case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">3378</TD><TD>            case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">3379</TD><TD>            case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">3380</TD><TD>            case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">3381</TD><TD>            case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">3382</TD><TD>            case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">3383</TD><TD>            case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">3384</TD><TD>            case ByteCode.IF_ACMPNE:</TD></TR><TR><TD CLASS="l">3385</TD><TD>            case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">3386</TD><TD>            case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">3387</TD><TD>            case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">3388</TD><TD>            case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">3389</TD><TD>            case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">3390</TD><TD>            case ByteCode.IF_ICMPNE:</TD></TR><TR><TD CLASS="l">3391</TD><TD>            case ByteCode.ILOAD:</TD></TR><TR><TD CLASS="l">3392</TD><TD>            case ByteCode.INSTANCEOF:</TD></TR><TR><TD CLASS="l">3393</TD><TD>            case ByteCode.INVOKEINTERFACE:</TD></TR><TR><TD CLASS="l">3394</TD><TD>            case ByteCode.INVOKESPECIAL:</TD></TR><TR><TD CLASS="l">3395</TD><TD>            case ByteCode.INVOKESTATIC:</TD></TR><TR><TD CLASS="l">3396</TD><TD>            case ByteCode.INVOKEVIRTUAL:</TD></TR><TR><TD CLASS="l">3397</TD><TD>            case ByteCode.ISTORE:</TD></TR><TR><TD CLASS="l">3398</TD><TD>            case ByteCode.JSR:</TD></TR><TR><TD CLASS="l">3399</TD><TD>            case ByteCode.JSR_W:</TD></TR><TR><TD CLASS="l">3400</TD><TD>            case ByteCode.LDC:</TD></TR><TR><TD CLASS="l">3401</TD><TD>            case ByteCode.LDC2_W:</TD></TR><TR><TD CLASS="l">3402</TD><TD>            case ByteCode.LDC_W:</TD></TR><TR><TD CLASS="l">3403</TD><TD>            case ByteCode.LLOAD:</TD></TR><TR><TD CLASS="l">3404</TD><TD>            case ByteCode.LSTORE:</TD></TR><TR><TD CLASS="l">3405</TD><TD>            case ByteCode.NEW:</TD></TR><TR><TD CLASS="l">3406</TD><TD>            case ByteCode.NEWARRAY:</TD></TR><TR><TD CLASS="l">3407</TD><TD>            case ByteCode.PUTFIELD:</TD></TR><TR><TD CLASS="l">3408</TD><TD>            case ByteCode.PUTSTATIC:</TD></TR><TR><TD CLASS="l">3409</TD><TD>            case ByteCode.RET:</TD></TR><TR><TD CLASS="l">3410</TD><TD>            case ByteCode.SIPUSH:</TD></TR><TR CLASS="z"><TD CLASS="l">3411</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">3412</TD><TD> </TD></TR><TR><TD CLASS="l">3413</TD><TD>            case ByteCode.IINC:</TD></TR><TR><TD CLASS="l">3414</TD><TD>            case ByteCode.MULTIANEWARRAY:</TD></TR><TR CLASS="z"><TD CLASS="l">3415</TD><TD>                return 2;</TD></TR><TR><TD CLASS="l">3416</TD><TD> </TD></TR><TR><TD CLASS="l">3417</TD><TD>            case ByteCode.LOOKUPSWITCH:</TD></TR><TR><TD CLASS="l">3418</TD><TD>            case ByteCode.TABLESWITCH:</TD></TR><TR CLASS="z"><TD CLASS="l">3419</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">3420</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3421</TD><TD>        throw new IllegalArgumentException(&#34;Bad opcode: &#34;+opcode);</TD></TR><TR><TD CLASS="l">3422</TD><TD>    }</TD></TR><TR><TD CLASS="l">3423</TD><TD> </TD></TR><TR><TD CLASS="l">3424</TD><TD>    /**</TD></TR><TR><TD CLASS="l">3425</TD><TD>     *  The effect on the operand stack of a given opcode.</TD></TR><TR><TD CLASS="l">3426</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="77">3427</A></TD><TD>    static int stackChange(int opcode)</TD></TR><TR><TD CLASS="l">3428</TD><TD>    {</TD></TR><TR><TD CLASS="l">3429</TD><TD>        // For INVOKE... accounts only for popping this (unless static),</TD></TR><TR><TD CLASS="l">3430</TD><TD>        // ignoring parameters and return type</TD></TR><TR CLASS="c"><TD CLASS="l">3431</TD><TD>        switch (opcode) {</TD></TR><TR><TD CLASS="l">3432</TD><TD>            case ByteCode.DASTORE:</TD></TR><TR><TD CLASS="l">3433</TD><TD>            case ByteCode.LASTORE:</TD></TR><TR CLASS="z"><TD CLASS="l">3434</TD><TD>                return -4;</TD></TR><TR><TD CLASS="l">3435</TD><TD> </TD></TR><TR><TD CLASS="l">3436</TD><TD>            case ByteCode.AASTORE:</TD></TR><TR><TD CLASS="l">3437</TD><TD>            case ByteCode.BASTORE:</TD></TR><TR><TD CLASS="l">3438</TD><TD>            case ByteCode.CASTORE:</TD></TR><TR><TD CLASS="l">3439</TD><TD>            case ByteCode.DCMPG:</TD></TR><TR><TD CLASS="l">3440</TD><TD>            case ByteCode.DCMPL:</TD></TR><TR><TD CLASS="l">3441</TD><TD>            case ByteCode.FASTORE:</TD></TR><TR><TD CLASS="l">3442</TD><TD>            case ByteCode.IASTORE:</TD></TR><TR><TD CLASS="l">3443</TD><TD>            case ByteCode.LCMP:</TD></TR><TR><TD CLASS="l">3444</TD><TD>            case ByteCode.SASTORE:</TD></TR><TR CLASS="c"><TD CLASS="l">3445</TD><TD>                return -3;</TD></TR><TR><TD CLASS="l">3446</TD><TD> </TD></TR><TR><TD CLASS="l">3447</TD><TD>            case ByteCode.DADD:</TD></TR><TR><TD CLASS="l">3448</TD><TD>            case ByteCode.DDIV:</TD></TR><TR><TD CLASS="l">3449</TD><TD>            case ByteCode.DMUL:</TD></TR><TR><TD CLASS="l">3450</TD><TD>            case ByteCode.DREM:</TD></TR><TR><TD CLASS="l">3451</TD><TD>            case ByteCode.DRETURN:</TD></TR><TR><TD CLASS="l">3452</TD><TD>            case ByteCode.DSTORE:</TD></TR><TR><TD CLASS="l">3453</TD><TD>            case ByteCode.DSTORE_0:</TD></TR><TR><TD CLASS="l">3454</TD><TD>            case ByteCode.DSTORE_1:</TD></TR><TR><TD CLASS="l">3455</TD><TD>            case ByteCode.DSTORE_2:</TD></TR><TR><TD CLASS="l">3456</TD><TD>            case ByteCode.DSTORE_3:</TD></TR><TR><TD CLASS="l">3457</TD><TD>            case ByteCode.DSUB:</TD></TR><TR><TD CLASS="l">3458</TD><TD>            case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">3459</TD><TD>            case ByteCode.IF_ACMPNE:</TD></TR><TR><TD CLASS="l">3460</TD><TD>            case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">3461</TD><TD>            case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">3462</TD><TD>            case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">3463</TD><TD>            case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">3464</TD><TD>            case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">3465</TD><TD>            case ByteCode.IF_ICMPNE:</TD></TR><TR><TD CLASS="l">3466</TD><TD>            case ByteCode.LADD:</TD></TR><TR><TD CLASS="l">3467</TD><TD>            case ByteCode.LAND:</TD></TR><TR><TD CLASS="l">3468</TD><TD>            case ByteCode.LDIV:</TD></TR><TR><TD CLASS="l">3469</TD><TD>            case ByteCode.LMUL:</TD></TR><TR><TD CLASS="l">3470</TD><TD>            case ByteCode.LOR:</TD></TR><TR><TD CLASS="l">3471</TD><TD>            case ByteCode.LREM:</TD></TR><TR><TD CLASS="l">3472</TD><TD>            case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">3473</TD><TD>            case ByteCode.LSTORE:</TD></TR><TR><TD CLASS="l">3474</TD><TD>            case ByteCode.LSTORE_0:</TD></TR><TR><TD CLASS="l">3475</TD><TD>            case ByteCode.LSTORE_1:</TD></TR><TR><TD CLASS="l">3476</TD><TD>            case ByteCode.LSTORE_2:</TD></TR><TR><TD CLASS="l">3477</TD><TD>            case ByteCode.LSTORE_3:</TD></TR><TR><TD CLASS="l">3478</TD><TD>            case ByteCode.LSUB:</TD></TR><TR><TD CLASS="l">3479</TD><TD>            case ByteCode.LXOR:</TD></TR><TR><TD CLASS="l">3480</TD><TD>            case ByteCode.POP2:</TD></TR><TR CLASS="c"><TD CLASS="l">3481</TD><TD>                return -2;</TD></TR><TR><TD CLASS="l">3482</TD><TD> </TD></TR><TR><TD CLASS="l">3483</TD><TD>            case ByteCode.AALOAD:</TD></TR><TR><TD CLASS="l">3484</TD><TD>            case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">3485</TD><TD>            case ByteCode.ASTORE:</TD></TR><TR><TD CLASS="l">3486</TD><TD>            case ByteCode.ASTORE_0:</TD></TR><TR><TD CLASS="l">3487</TD><TD>            case ByteCode.ASTORE_1:</TD></TR><TR><TD CLASS="l">3488</TD><TD>            case ByteCode.ASTORE_2:</TD></TR><TR><TD CLASS="l">3489</TD><TD>            case ByteCode.ASTORE_3:</TD></TR><TR><TD CLASS="l">3490</TD><TD>            case ByteCode.ATHROW:</TD></TR><TR><TD CLASS="l">3491</TD><TD>            case ByteCode.BALOAD:</TD></TR><TR><TD CLASS="l">3492</TD><TD>            case ByteCode.CALOAD:</TD></TR><TR><TD CLASS="l">3493</TD><TD>            case ByteCode.D2F:</TD></TR><TR><TD CLASS="l">3494</TD><TD>            case ByteCode.D2I:</TD></TR><TR><TD CLASS="l">3495</TD><TD>            case ByteCode.FADD:</TD></TR><TR><TD CLASS="l">3496</TD><TD>            case ByteCode.FALOAD:</TD></TR><TR><TD CLASS="l">3497</TD><TD>            case ByteCode.FCMPG:</TD></TR><TR><TD CLASS="l">3498</TD><TD>            case ByteCode.FCMPL:</TD></TR><TR><TD CLASS="l">3499</TD><TD>            case ByteCode.FDIV:</TD></TR><TR><TD CLASS="l">3500</TD><TD>            case ByteCode.FMUL:</TD></TR><TR><TD CLASS="l">3501</TD><TD>            case ByteCode.FREM:</TD></TR><TR><TD CLASS="l">3502</TD><TD>            case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">3503</TD><TD>            case ByteCode.FSTORE:</TD></TR><TR><TD CLASS="l">3504</TD><TD>            case ByteCode.FSTORE_0:</TD></TR><TR><TD CLASS="l">3505</TD><TD>            case ByteCode.FSTORE_1:</TD></TR><TR><TD CLASS="l">3506</TD><TD>            case ByteCode.FSTORE_2:</TD></TR><TR><TD CLASS="l">3507</TD><TD>            case ByteCode.FSTORE_3:</TD></TR><TR><TD CLASS="l">3508</TD><TD>            case ByteCode.FSUB:</TD></TR><TR><TD CLASS="l">3509</TD><TD>            case ByteCode.GETFIELD:</TD></TR><TR><TD CLASS="l">3510</TD><TD>            case ByteCode.IADD:</TD></TR><TR><TD CLASS="l">3511</TD><TD>            case ByteCode.IALOAD:</TD></TR><TR><TD CLASS="l">3512</TD><TD>            case ByteCode.IAND:</TD></TR><TR><TD CLASS="l">3513</TD><TD>            case ByteCode.IDIV:</TD></TR><TR><TD CLASS="l">3514</TD><TD>            case ByteCode.IFEQ:</TD></TR><TR><TD CLASS="l">3515</TD><TD>            case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">3516</TD><TD>            case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">3517</TD><TD>            case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">3518</TD><TD>            case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">3519</TD><TD>            case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">3520</TD><TD>            case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">3521</TD><TD>            case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">3522</TD><TD>            case ByteCode.IMUL:</TD></TR><TR><TD CLASS="l">3523</TD><TD>            case ByteCode.INVOKEINTERFACE:       //</TD></TR><TR><TD CLASS="l">3524</TD><TD>            case ByteCode.INVOKESPECIAL:         // but needs to account for</TD></TR><TR><TD CLASS="l">3525</TD><TD>            case ByteCode.INVOKEVIRTUAL:         // pops 'this' (unless static)</TD></TR><TR><TD CLASS="l">3526</TD><TD>            case ByteCode.IOR:</TD></TR><TR><TD CLASS="l">3527</TD><TD>            case ByteCode.IREM:</TD></TR><TR><TD CLASS="l">3528</TD><TD>            case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">3529</TD><TD>            case ByteCode.ISHL:</TD></TR><TR><TD CLASS="l">3530</TD><TD>            case ByteCode.ISHR:</TD></TR><TR><TD CLASS="l">3531</TD><TD>            case ByteCode.ISTORE:</TD></TR><TR><TD CLASS="l">3532</TD><TD>            case ByteCode.ISTORE_0:</TD></TR><TR><TD CLASS="l">3533</TD><TD>            case ByteCode.ISTORE_1:</TD></TR><TR><TD CLASS="l">3534</TD><TD>            case ByteCode.ISTORE_2:</TD></TR><TR><TD CLASS="l">3535</TD><TD>            case ByteCode.ISTORE_3:</TD></TR><TR><TD CLASS="l">3536</TD><TD>            case ByteCode.ISUB:</TD></TR><TR><TD CLASS="l">3537</TD><TD>            case ByteCode.IUSHR:</TD></TR><TR><TD CLASS="l">3538</TD><TD>            case ByteCode.IXOR:</TD></TR><TR><TD CLASS="l">3539</TD><TD>            case ByteCode.L2F:</TD></TR><TR><TD CLASS="l">3540</TD><TD>            case ByteCode.L2I:</TD></TR><TR><TD CLASS="l">3541</TD><TD>            case ByteCode.LOOKUPSWITCH:</TD></TR><TR><TD CLASS="l">3542</TD><TD>            case ByteCode.LSHL:</TD></TR><TR><TD CLASS="l">3543</TD><TD>            case ByteCode.LSHR:</TD></TR><TR><TD CLASS="l">3544</TD><TD>            case ByteCode.LUSHR:</TD></TR><TR><TD CLASS="l">3545</TD><TD>            case ByteCode.MONITORENTER:</TD></TR><TR><TD CLASS="l">3546</TD><TD>            case ByteCode.MONITOREXIT:</TD></TR><TR><TD CLASS="l">3547</TD><TD>            case ByteCode.POP:</TD></TR><TR><TD CLASS="l">3548</TD><TD>            case ByteCode.PUTFIELD:</TD></TR><TR><TD CLASS="l">3549</TD><TD>            case ByteCode.SALOAD:</TD></TR><TR><TD CLASS="l">3550</TD><TD>            case ByteCode.TABLESWITCH:</TD></TR><TR CLASS="c"><TD CLASS="l">3551</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">3552</TD><TD> </TD></TR><TR><TD CLASS="l">3553</TD><TD>            case ByteCode.ANEWARRAY:</TD></TR><TR><TD CLASS="l">3554</TD><TD>            case ByteCode.ARRAYLENGTH:</TD></TR><TR><TD CLASS="l">3555</TD><TD>            case ByteCode.BREAKPOINT:</TD></TR><TR><TD CLASS="l">3556</TD><TD>            case ByteCode.CHECKCAST:</TD></TR><TR><TD CLASS="l">3557</TD><TD>            case ByteCode.D2L:</TD></TR><TR><TD CLASS="l">3558</TD><TD>            case ByteCode.DALOAD:</TD></TR><TR><TD CLASS="l">3559</TD><TD>            case ByteCode.DNEG:</TD></TR><TR><TD CLASS="l">3560</TD><TD>            case ByteCode.F2I:</TD></TR><TR><TD CLASS="l">3561</TD><TD>            case ByteCode.FNEG:</TD></TR><TR><TD CLASS="l">3562</TD><TD>            case ByteCode.GETSTATIC:</TD></TR><TR><TD CLASS="l">3563</TD><TD>            case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">3564</TD><TD>            case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">3565</TD><TD>            case ByteCode.I2B:</TD></TR><TR><TD CLASS="l">3566</TD><TD>            case ByteCode.I2C:</TD></TR><TR><TD CLASS="l">3567</TD><TD>            case ByteCode.I2F:</TD></TR><TR><TD CLASS="l">3568</TD><TD>            case ByteCode.I2S:</TD></TR><TR><TD CLASS="l">3569</TD><TD>            case ByteCode.IINC:</TD></TR><TR><TD CLASS="l">3570</TD><TD>            case ByteCode.IMPDEP1:</TD></TR><TR><TD CLASS="l">3571</TD><TD>            case ByteCode.IMPDEP2:</TD></TR><TR><TD CLASS="l">3572</TD><TD>            case ByteCode.INEG:</TD></TR><TR><TD CLASS="l">3573</TD><TD>            case ByteCode.INSTANCEOF:</TD></TR><TR><TD CLASS="l">3574</TD><TD>            case ByteCode.INVOKESTATIC:</TD></TR><TR><TD CLASS="l">3575</TD><TD>            case ByteCode.L2D:</TD></TR><TR><TD CLASS="l">3576</TD><TD>            case ByteCode.LALOAD:</TD></TR><TR><TD CLASS="l">3577</TD><TD>            case ByteCode.LNEG:</TD></TR><TR><TD CLASS="l">3578</TD><TD>            case ByteCode.NEWARRAY:</TD></TR><TR><TD CLASS="l">3579</TD><TD>            case ByteCode.NOP:</TD></TR><TR><TD CLASS="l">3580</TD><TD>            case ByteCode.PUTSTATIC:</TD></TR><TR><TD CLASS="l">3581</TD><TD>            case ByteCode.RET:</TD></TR><TR><TD CLASS="l">3582</TD><TD>            case ByteCode.RETURN:</TD></TR><TR><TD CLASS="l">3583</TD><TD>            case ByteCode.SWAP:</TD></TR><TR><TD CLASS="l">3584</TD><TD>            case ByteCode.WIDE:</TD></TR><TR CLASS="c"><TD CLASS="l">3585</TD><TD>                return 0;</TD></TR><TR><TD CLASS="l">3586</TD><TD> </TD></TR><TR><TD CLASS="l">3587</TD><TD>            case ByteCode.ACONST_NULL:</TD></TR><TR><TD CLASS="l">3588</TD><TD>            case ByteCode.ALOAD:</TD></TR><TR><TD CLASS="l">3589</TD><TD>            case ByteCode.ALOAD_0:</TD></TR><TR><TD CLASS="l">3590</TD><TD>            case ByteCode.ALOAD_1:</TD></TR><TR><TD CLASS="l">3591</TD><TD>            case ByteCode.ALOAD_2:</TD></TR><TR><TD CLASS="l">3592</TD><TD>            case ByteCode.ALOAD_3:</TD></TR><TR><TD CLASS="l">3593</TD><TD>            case ByteCode.BIPUSH:</TD></TR><TR><TD CLASS="l">3594</TD><TD>            case ByteCode.DUP:</TD></TR><TR><TD CLASS="l">3595</TD><TD>            case ByteCode.DUP_X1:</TD></TR><TR><TD CLASS="l">3596</TD><TD>            case ByteCode.DUP_X2:</TD></TR><TR><TD CLASS="l">3597</TD><TD>            case ByteCode.F2D:</TD></TR><TR><TD CLASS="l">3598</TD><TD>            case ByteCode.F2L:</TD></TR><TR><TD CLASS="l">3599</TD><TD>            case ByteCode.FCONST_0:</TD></TR><TR><TD CLASS="l">3600</TD><TD>            case ByteCode.FCONST_1:</TD></TR><TR><TD CLASS="l">3601</TD><TD>            case ByteCode.FCONST_2:</TD></TR><TR><TD CLASS="l">3602</TD><TD>            case ByteCode.FLOAD:</TD></TR><TR><TD CLASS="l">3603</TD><TD>            case ByteCode.FLOAD_0:</TD></TR><TR><TD CLASS="l">3604</TD><TD>            case ByteCode.FLOAD_1:</TD></TR><TR><TD CLASS="l">3605</TD><TD>            case ByteCode.FLOAD_2:</TD></TR><TR><TD CLASS="l">3606</TD><TD>            case ByteCode.FLOAD_3:</TD></TR><TR><TD CLASS="l">3607</TD><TD>            case ByteCode.I2D:</TD></TR><TR><TD CLASS="l">3608</TD><TD>            case ByteCode.I2L:</TD></TR><TR><TD CLASS="l">3609</TD><TD>            case ByteCode.ICONST_0:</TD></TR><TR><TD CLASS="l">3610</TD><TD>            case ByteCode.ICONST_1:</TD></TR><TR><TD CLASS="l">3611</TD><TD>            case ByteCode.ICONST_2:</TD></TR><TR><TD CLASS="l">3612</TD><TD>            case ByteCode.ICONST_3:</TD></TR><TR><TD CLASS="l">3613</TD><TD>            case ByteCode.ICONST_4:</TD></TR><TR><TD CLASS="l">3614</TD><TD>            case ByteCode.ICONST_5:</TD></TR><TR><TD CLASS="l">3615</TD><TD>            case ByteCode.ICONST_M1:</TD></TR><TR><TD CLASS="l">3616</TD><TD>            case ByteCode.ILOAD:</TD></TR><TR><TD CLASS="l">3617</TD><TD>            case ByteCode.ILOAD_0:</TD></TR><TR><TD CLASS="l">3618</TD><TD>            case ByteCode.ILOAD_1:</TD></TR><TR><TD CLASS="l">3619</TD><TD>            case ByteCode.ILOAD_2:</TD></TR><TR><TD CLASS="l">3620</TD><TD>            case ByteCode.ILOAD_3:</TD></TR><TR><TD CLASS="l">3621</TD><TD>            case ByteCode.JSR:</TD></TR><TR><TD CLASS="l">3622</TD><TD>            case ByteCode.JSR_W:</TD></TR><TR><TD CLASS="l">3623</TD><TD>            case ByteCode.LDC:</TD></TR><TR><TD CLASS="l">3624</TD><TD>            case ByteCode.LDC_W:</TD></TR><TR><TD CLASS="l">3625</TD><TD>            case ByteCode.MULTIANEWARRAY:</TD></TR><TR><TD CLASS="l">3626</TD><TD>            case ByteCode.NEW:</TD></TR><TR><TD CLASS="l">3627</TD><TD>            case ByteCode.SIPUSH:</TD></TR><TR CLASS="c"><TD CLASS="l">3628</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">3629</TD><TD> </TD></TR><TR><TD CLASS="l">3630</TD><TD>            case ByteCode.DCONST_0:</TD></TR><TR><TD CLASS="l">3631</TD><TD>            case ByteCode.DCONST_1:</TD></TR><TR><TD CLASS="l">3632</TD><TD>            case ByteCode.DLOAD:</TD></TR><TR><TD CLASS="l">3633</TD><TD>            case ByteCode.DLOAD_0:</TD></TR><TR><TD CLASS="l">3634</TD><TD>            case ByteCode.DLOAD_1:</TD></TR><TR><TD CLASS="l">3635</TD><TD>            case ByteCode.DLOAD_2:</TD></TR><TR><TD CLASS="l">3636</TD><TD>            case ByteCode.DLOAD_3:</TD></TR><TR><TD CLASS="l">3637</TD><TD>            case ByteCode.DUP2:</TD></TR><TR><TD CLASS="l">3638</TD><TD>            case ByteCode.DUP2_X1:</TD></TR><TR><TD CLASS="l">3639</TD><TD>            case ByteCode.DUP2_X2:</TD></TR><TR><TD CLASS="l">3640</TD><TD>            case ByteCode.LCONST_0:</TD></TR><TR><TD CLASS="l">3641</TD><TD>            case ByteCode.LCONST_1:</TD></TR><TR><TD CLASS="l">3642</TD><TD>            case ByteCode.LDC2_W:</TD></TR><TR><TD CLASS="l">3643</TD><TD>            case ByteCode.LLOAD:</TD></TR><TR><TD CLASS="l">3644</TD><TD>            case ByteCode.LLOAD_0:</TD></TR><TR><TD CLASS="l">3645</TD><TD>            case ByteCode.LLOAD_1:</TD></TR><TR><TD CLASS="l">3646</TD><TD>            case ByteCode.LLOAD_2:</TD></TR><TR><TD CLASS="l">3647</TD><TD>            case ByteCode.LLOAD_3:</TD></TR><TR CLASS="c"><TD CLASS="l">3648</TD><TD>                return 2;</TD></TR><TR><TD CLASS="l">3649</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">3650</TD><TD>        throw new IllegalArgumentException(&#34;Bad opcode: &#34;+opcode);</TD></TR><TR><TD CLASS="l">3651</TD><TD>    }</TD></TR><TR><TD CLASS="l">3652</TD><TD> </TD></TR><TR><TD CLASS="l">3653</TD><TD>        /*</TD></TR><TR><TD CLASS="l">3654</TD><TD>         * Number of bytes of operands generated after the opcode.</TD></TR><TR><TD CLASS="l">3655</TD><TD>         * Not in use currently.</TD></TR><TR><TD CLASS="l">3656</TD><TD>         */</TD></TR><TR><TD CLASS="l">3657</TD><TD>/*</TD></TR><TR><TD CLASS="l">3658</TD><TD>    int extra(int opcode)</TD></TR><TR><TD CLASS="l">3659</TD><TD>    {</TD></TR><TR><TD CLASS="l">3660</TD><TD>        switch (opcode) {</TD></TR><TR><TD CLASS="l">3661</TD><TD>            case ByteCode.AALOAD:</TD></TR><TR><TD CLASS="l">3662</TD><TD>            case ByteCode.AASTORE:</TD></TR><TR><TD CLASS="l">3663</TD><TD>            case ByteCode.ACONST_NULL:</TD></TR><TR><TD CLASS="l">3664</TD><TD>            case ByteCode.ALOAD_0:</TD></TR><TR><TD CLASS="l">3665</TD><TD>            case ByteCode.ALOAD_1:</TD></TR><TR><TD CLASS="l">3666</TD><TD>            case ByteCode.ALOAD_2:</TD></TR><TR><TD CLASS="l">3667</TD><TD>            case ByteCode.ALOAD_3:</TD></TR><TR><TD CLASS="l">3668</TD><TD>            case ByteCode.ARETURN:</TD></TR><TR><TD CLASS="l">3669</TD><TD>            case ByteCode.ARRAYLENGTH:</TD></TR><TR><TD CLASS="l">3670</TD><TD>            case ByteCode.ASTORE_0:</TD></TR><TR><TD CLASS="l">3671</TD><TD>            case ByteCode.ASTORE_1:</TD></TR><TR><TD CLASS="l">3672</TD><TD>            case ByteCode.ASTORE_2:</TD></TR><TR><TD CLASS="l">3673</TD><TD>            case ByteCode.ASTORE_3:</TD></TR><TR><TD CLASS="l">3674</TD><TD>            case ByteCode.ATHROW:</TD></TR><TR><TD CLASS="l">3675</TD><TD>            case ByteCode.BALOAD:</TD></TR><TR><TD CLASS="l">3676</TD><TD>            case ByteCode.BASTORE:</TD></TR><TR><TD CLASS="l">3677</TD><TD>            case ByteCode.BREAKPOINT:</TD></TR><TR><TD CLASS="l">3678</TD><TD>            case ByteCode.CALOAD:</TD></TR><TR><TD CLASS="l">3679</TD><TD>            case ByteCode.CASTORE:</TD></TR><TR><TD CLASS="l">3680</TD><TD>            case ByteCode.D2F:</TD></TR><TR><TD CLASS="l">3681</TD><TD>            case ByteCode.D2I:</TD></TR><TR><TD CLASS="l">3682</TD><TD>            case ByteCode.D2L:</TD></TR><TR><TD CLASS="l">3683</TD><TD>            case ByteCode.DADD:</TD></TR><TR><TD CLASS="l">3684</TD><TD>            case ByteCode.DALOAD:</TD></TR><TR><TD CLASS="l">3685</TD><TD>            case ByteCode.DASTORE:</TD></TR><TR><TD CLASS="l">3686</TD><TD>            case ByteCode.DCMPG:</TD></TR><TR><TD CLASS="l">3687</TD><TD>            case ByteCode.DCMPL:</TD></TR><TR><TD CLASS="l">3688</TD><TD>            case ByteCode.DCONST_0:</TD></TR><TR><TD CLASS="l">3689</TD><TD>            case ByteCode.DCONST_1:</TD></TR><TR><TD CLASS="l">3690</TD><TD>            case ByteCode.DDIV:</TD></TR><TR><TD CLASS="l">3691</TD><TD>            case ByteCode.DLOAD_0:</TD></TR><TR><TD CLASS="l">3692</TD><TD>            case ByteCode.DLOAD_1:</TD></TR><TR><TD CLASS="l">3693</TD><TD>            case ByteCode.DLOAD_2:</TD></TR><TR><TD CLASS="l">3694</TD><TD>            case ByteCode.DLOAD_3:</TD></TR><TR><TD CLASS="l">3695</TD><TD>            case ByteCode.DMUL:</TD></TR><TR><TD CLASS="l">3696</TD><TD>            case ByteCode.DNEG:</TD></TR><TR><TD CLASS="l">3697</TD><TD>            case ByteCode.DREM:</TD></TR><TR><TD CLASS="l">3698</TD><TD>            case ByteCode.DRETURN:</TD></TR><TR><TD CLASS="l">3699</TD><TD>            case ByteCode.DSTORE_0:</TD></TR><TR><TD CLASS="l">3700</TD><TD>            case ByteCode.DSTORE_1:</TD></TR><TR><TD CLASS="l">3701</TD><TD>            case ByteCode.DSTORE_2:</TD></TR><TR><TD CLASS="l">3702</TD><TD>            case ByteCode.DSTORE_3:</TD></TR><TR><TD CLASS="l">3703</TD><TD>            case ByteCode.DSUB:</TD></TR><TR><TD CLASS="l">3704</TD><TD>            case ByteCode.DUP2:</TD></TR><TR><TD CLASS="l">3705</TD><TD>            case ByteCode.DUP2_X1:</TD></TR><TR><TD CLASS="l">3706</TD><TD>            case ByteCode.DUP2_X2:</TD></TR><TR><TD CLASS="l">3707</TD><TD>            case ByteCode.DUP:</TD></TR><TR><TD CLASS="l">3708</TD><TD>            case ByteCode.DUP_X1:</TD></TR><TR><TD CLASS="l">3709</TD><TD>            case ByteCode.DUP_X2:</TD></TR><TR><TD CLASS="l">3710</TD><TD>            case ByteCode.F2D:</TD></TR><TR><TD CLASS="l">3711</TD><TD>            case ByteCode.F2I:</TD></TR><TR><TD CLASS="l">3712</TD><TD>            case ByteCode.F2L:</TD></TR><TR><TD CLASS="l">3713</TD><TD>            case ByteCode.FADD:</TD></TR><TR><TD CLASS="l">3714</TD><TD>            case ByteCode.FALOAD:</TD></TR><TR><TD CLASS="l">3715</TD><TD>            case ByteCode.FASTORE:</TD></TR><TR><TD CLASS="l">3716</TD><TD>            case ByteCode.FCMPG:</TD></TR><TR><TD CLASS="l">3717</TD><TD>            case ByteCode.FCMPL:</TD></TR><TR><TD CLASS="l">3718</TD><TD>            case ByteCode.FCONST_0:</TD></TR><TR><TD CLASS="l">3719</TD><TD>            case ByteCode.FCONST_1:</TD></TR><TR><TD CLASS="l">3720</TD><TD>            case ByteCode.FCONST_2:</TD></TR><TR><TD CLASS="l">3721</TD><TD>            case ByteCode.FDIV:</TD></TR><TR><TD CLASS="l">3722</TD><TD>            case ByteCode.FLOAD_0:</TD></TR><TR><TD CLASS="l">3723</TD><TD>            case ByteCode.FLOAD_1:</TD></TR><TR><TD CLASS="l">3724</TD><TD>            case ByteCode.FLOAD_2:</TD></TR><TR><TD CLASS="l">3725</TD><TD>            case ByteCode.FLOAD_3:</TD></TR><TR><TD CLASS="l">3726</TD><TD>            case ByteCode.FMUL:</TD></TR><TR><TD CLASS="l">3727</TD><TD>            case ByteCode.FNEG:</TD></TR><TR><TD CLASS="l">3728</TD><TD>            case ByteCode.FREM:</TD></TR><TR><TD CLASS="l">3729</TD><TD>            case ByteCode.FRETURN:</TD></TR><TR><TD CLASS="l">3730</TD><TD>            case ByteCode.FSTORE_0:</TD></TR><TR><TD CLASS="l">3731</TD><TD>            case ByteCode.FSTORE_1:</TD></TR><TR><TD CLASS="l">3732</TD><TD>            case ByteCode.FSTORE_2:</TD></TR><TR><TD CLASS="l">3733</TD><TD>            case ByteCode.FSTORE_3:</TD></TR><TR><TD CLASS="l">3734</TD><TD>            case ByteCode.FSUB:</TD></TR><TR><TD CLASS="l">3735</TD><TD>            case ByteCode.I2B:</TD></TR><TR><TD CLASS="l">3736</TD><TD>            case ByteCode.I2C:</TD></TR><TR><TD CLASS="l">3737</TD><TD>            case ByteCode.I2D:</TD></TR><TR><TD CLASS="l">3738</TD><TD>            case ByteCode.I2F:</TD></TR><TR><TD CLASS="l">3739</TD><TD>            case ByteCode.I2L:</TD></TR><TR><TD CLASS="l">3740</TD><TD>            case ByteCode.I2S:</TD></TR><TR><TD CLASS="l">3741</TD><TD>            case ByteCode.IADD:</TD></TR><TR><TD CLASS="l">3742</TD><TD>            case ByteCode.IALOAD:</TD></TR><TR><TD CLASS="l">3743</TD><TD>            case ByteCode.IAND:</TD></TR><TR><TD CLASS="l">3744</TD><TD>            case ByteCode.IASTORE:</TD></TR><TR><TD CLASS="l">3745</TD><TD>            case ByteCode.ICONST_0:</TD></TR><TR><TD CLASS="l">3746</TD><TD>            case ByteCode.ICONST_1:</TD></TR><TR><TD CLASS="l">3747</TD><TD>            case ByteCode.ICONST_2:</TD></TR><TR><TD CLASS="l">3748</TD><TD>            case ByteCode.ICONST_3:</TD></TR><TR><TD CLASS="l">3749</TD><TD>            case ByteCode.ICONST_4:</TD></TR><TR><TD CLASS="l">3750</TD><TD>            case ByteCode.ICONST_5:</TD></TR><TR><TD CLASS="l">3751</TD><TD>            case ByteCode.ICONST_M1:</TD></TR><TR><TD CLASS="l">3752</TD><TD>            case ByteCode.IDIV:</TD></TR><TR><TD CLASS="l">3753</TD><TD>            case ByteCode.ILOAD_0:</TD></TR><TR><TD CLASS="l">3754</TD><TD>            case ByteCode.ILOAD_1:</TD></TR><TR><TD CLASS="l">3755</TD><TD>            case ByteCode.ILOAD_2:</TD></TR><TR><TD CLASS="l">3756</TD><TD>            case ByteCode.ILOAD_3:</TD></TR><TR><TD CLASS="l">3757</TD><TD>            case ByteCode.IMPDEP1:</TD></TR><TR><TD CLASS="l">3758</TD><TD>            case ByteCode.IMPDEP2:</TD></TR><TR><TD CLASS="l">3759</TD><TD>            case ByteCode.IMUL:</TD></TR><TR><TD CLASS="l">3760</TD><TD>            case ByteCode.INEG:</TD></TR><TR><TD CLASS="l">3761</TD><TD>            case ByteCode.IOR:</TD></TR><TR><TD CLASS="l">3762</TD><TD>            case ByteCode.IREM:</TD></TR><TR><TD CLASS="l">3763</TD><TD>            case ByteCode.IRETURN:</TD></TR><TR><TD CLASS="l">3764</TD><TD>            case ByteCode.ISHL:</TD></TR><TR><TD CLASS="l">3765</TD><TD>            case ByteCode.ISHR:</TD></TR><TR><TD CLASS="l">3766</TD><TD>            case ByteCode.ISTORE_0:</TD></TR><TR><TD CLASS="l">3767</TD><TD>            case ByteCode.ISTORE_1:</TD></TR><TR><TD CLASS="l">3768</TD><TD>            case ByteCode.ISTORE_2:</TD></TR><TR><TD CLASS="l">3769</TD><TD>            case ByteCode.ISTORE_3:</TD></TR><TR><TD CLASS="l">3770</TD><TD>            case ByteCode.ISUB:</TD></TR><TR><TD CLASS="l">3771</TD><TD>            case ByteCode.IUSHR:</TD></TR><TR><TD CLASS="l">3772</TD><TD>            case ByteCode.IXOR:</TD></TR><TR><TD CLASS="l">3773</TD><TD>            case ByteCode.L2D:</TD></TR><TR><TD CLASS="l">3774</TD><TD>            case ByteCode.L2F:</TD></TR><TR><TD CLASS="l">3775</TD><TD>            case ByteCode.L2I:</TD></TR><TR><TD CLASS="l">3776</TD><TD>            case ByteCode.LADD:</TD></TR><TR><TD CLASS="l">3777</TD><TD>            case ByteCode.LALOAD:</TD></TR><TR><TD CLASS="l">3778</TD><TD>            case ByteCode.LAND:</TD></TR><TR><TD CLASS="l">3779</TD><TD>            case ByteCode.LASTORE:</TD></TR><TR><TD CLASS="l">3780</TD><TD>            case ByteCode.LCMP:</TD></TR><TR><TD CLASS="l">3781</TD><TD>            case ByteCode.LCONST_0:</TD></TR><TR><TD CLASS="l">3782</TD><TD>            case ByteCode.LCONST_1:</TD></TR><TR><TD CLASS="l">3783</TD><TD>            case ByteCode.LDIV:</TD></TR><TR><TD CLASS="l">3784</TD><TD>            case ByteCode.LLOAD_0:</TD></TR><TR><TD CLASS="l">3785</TD><TD>            case ByteCode.LLOAD_1:</TD></TR><TR><TD CLASS="l">3786</TD><TD>            case ByteCode.LLOAD_2:</TD></TR><TR><TD CLASS="l">3787</TD><TD>            case ByteCode.LLOAD_3:</TD></TR><TR><TD CLASS="l">3788</TD><TD>            case ByteCode.LMUL:</TD></TR><TR><TD CLASS="l">3789</TD><TD>            case ByteCode.LNEG:</TD></TR><TR><TD CLASS="l">3790</TD><TD>            case ByteCode.LOR:</TD></TR><TR><TD CLASS="l">3791</TD><TD>            case ByteCode.LREM:</TD></TR><TR><TD CLASS="l">3792</TD><TD>            case ByteCode.LRETURN:</TD></TR><TR><TD CLASS="l">3793</TD><TD>            case ByteCode.LSHL:</TD></TR><TR><TD CLASS="l">3794</TD><TD>            case ByteCode.LSHR:</TD></TR><TR><TD CLASS="l">3795</TD><TD>            case ByteCode.LSTORE_0:</TD></TR><TR><TD CLASS="l">3796</TD><TD>            case ByteCode.LSTORE_1:</TD></TR><TR><TD CLASS="l">3797</TD><TD>            case ByteCode.LSTORE_2:</TD></TR><TR><TD CLASS="l">3798</TD><TD>            case ByteCode.LSTORE_3:</TD></TR><TR><TD CLASS="l">3799</TD><TD>            case ByteCode.LSUB:</TD></TR><TR><TD CLASS="l">3800</TD><TD>            case ByteCode.LUSHR:</TD></TR><TR><TD CLASS="l">3801</TD><TD>            case ByteCode.LXOR:</TD></TR><TR><TD CLASS="l">3802</TD><TD>            case ByteCode.MONITORENTER:</TD></TR><TR><TD CLASS="l">3803</TD><TD>            case ByteCode.MONITOREXIT:</TD></TR><TR><TD CLASS="l">3804</TD><TD>            case ByteCode.NOP:</TD></TR><TR><TD CLASS="l">3805</TD><TD>            case ByteCode.POP2:</TD></TR><TR><TD CLASS="l">3806</TD><TD>            case ByteCode.POP:</TD></TR><TR><TD CLASS="l">3807</TD><TD>            case ByteCode.RETURN:</TD></TR><TR><TD CLASS="l">3808</TD><TD>            case ByteCode.SALOAD:</TD></TR><TR><TD CLASS="l">3809</TD><TD>            case ByteCode.SASTORE:</TD></TR><TR><TD CLASS="l">3810</TD><TD>            case ByteCode.SWAP:</TD></TR><TR><TD CLASS="l">3811</TD><TD>            case ByteCode.WIDE:</TD></TR><TR><TD CLASS="l">3812</TD><TD>                return 0;</TD></TR><TR><TD CLASS="l">3813</TD><TD> </TD></TR><TR><TD CLASS="l">3814</TD><TD>            case ByteCode.ALOAD:</TD></TR><TR><TD CLASS="l">3815</TD><TD>            case ByteCode.ASTORE:</TD></TR><TR><TD CLASS="l">3816</TD><TD>            case ByteCode.BIPUSH:</TD></TR><TR><TD CLASS="l">3817</TD><TD>            case ByteCode.DLOAD:</TD></TR><TR><TD CLASS="l">3818</TD><TD>            case ByteCode.DSTORE:</TD></TR><TR><TD CLASS="l">3819</TD><TD>            case ByteCode.FLOAD:</TD></TR><TR><TD CLASS="l">3820</TD><TD>            case ByteCode.FSTORE:</TD></TR><TR><TD CLASS="l">3821</TD><TD>            case ByteCode.ILOAD:</TD></TR><TR><TD CLASS="l">3822</TD><TD>            case ByteCode.ISTORE:</TD></TR><TR><TD CLASS="l">3823</TD><TD>            case ByteCode.LDC:</TD></TR><TR><TD CLASS="l">3824</TD><TD>            case ByteCode.LLOAD:</TD></TR><TR><TD CLASS="l">3825</TD><TD>            case ByteCode.LSTORE:</TD></TR><TR><TD CLASS="l">3826</TD><TD>            case ByteCode.NEWARRAY:</TD></TR><TR><TD CLASS="l">3827</TD><TD>            case ByteCode.RET:</TD></TR><TR><TD CLASS="l">3828</TD><TD>                return 1;</TD></TR><TR><TD CLASS="l">3829</TD><TD> </TD></TR><TR><TD CLASS="l">3830</TD><TD>            case ByteCode.ANEWARRAY:</TD></TR><TR><TD CLASS="l">3831</TD><TD>            case ByteCode.CHECKCAST:</TD></TR><TR><TD CLASS="l">3832</TD><TD>            case ByteCode.GETFIELD:</TD></TR><TR><TD CLASS="l">3833</TD><TD>            case ByteCode.GETSTATIC:</TD></TR><TR><TD CLASS="l">3834</TD><TD>            case ByteCode.GOTO:</TD></TR><TR><TD CLASS="l">3835</TD><TD>            case ByteCode.IFEQ:</TD></TR><TR><TD CLASS="l">3836</TD><TD>            case ByteCode.IFGE:</TD></TR><TR><TD CLASS="l">3837</TD><TD>            case ByteCode.IFGT:</TD></TR><TR><TD CLASS="l">3838</TD><TD>            case ByteCode.IFLE:</TD></TR><TR><TD CLASS="l">3839</TD><TD>            case ByteCode.IFLT:</TD></TR><TR><TD CLASS="l">3840</TD><TD>            case ByteCode.IFNE:</TD></TR><TR><TD CLASS="l">3841</TD><TD>            case ByteCode.IFNONNULL:</TD></TR><TR><TD CLASS="l">3842</TD><TD>            case ByteCode.IFNULL:</TD></TR><TR><TD CLASS="l">3843</TD><TD>            case ByteCode.IF_ACMPEQ:</TD></TR><TR><TD CLASS="l">3844</TD><TD>            case ByteCode.IF_ACMPNE:</TD></TR><TR><TD CLASS="l">3845</TD><TD>            case ByteCode.IF_ICMPEQ:</TD></TR><TR><TD CLASS="l">3846</TD><TD>            case ByteCode.IF_ICMPGE:</TD></TR><TR><TD CLASS="l">3847</TD><TD>            case ByteCode.IF_ICMPGT:</TD></TR><TR><TD CLASS="l">3848</TD><TD>            case ByteCode.IF_ICMPLE:</TD></TR><TR><TD CLASS="l">3849</TD><TD>            case ByteCode.IF_ICMPLT:</TD></TR><TR><TD CLASS="l">3850</TD><TD>            case ByteCode.IF_ICMPNE:</TD></TR><TR><TD CLASS="l">3851</TD><TD>            case ByteCode.IINC:</TD></TR><TR><TD CLASS="l">3852</TD><TD>            case ByteCode.INSTANCEOF:</TD></TR><TR><TD CLASS="l">3853</TD><TD>            case ByteCode.INVOKEINTERFACE:</TD></TR><TR><TD CLASS="l">3854</TD><TD>            case ByteCode.INVOKESPECIAL:</TD></TR><TR><TD CLASS="l">3855</TD><TD>            case ByteCode.INVOKESTATIC:</TD></TR><TR><TD CLASS="l">3856</TD><TD>            case ByteCode.INVOKEVIRTUAL:</TD></TR><TR><TD CLASS="l">3857</TD><TD>            case ByteCode.JSR:</TD></TR><TR><TD CLASS="l">3858</TD><TD>            case ByteCode.LDC2_W:</TD></TR><TR><TD CLASS="l">3859</TD><TD>            case ByteCode.LDC_W:</TD></TR><TR><TD CLASS="l">3860</TD><TD>            case ByteCode.NEW:</TD></TR><TR><TD CLASS="l">3861</TD><TD>            case ByteCode.PUTFIELD:</TD></TR><TR><TD CLASS="l">3862</TD><TD>            case ByteCode.PUTSTATIC:</TD></TR><TR><TD CLASS="l">3863</TD><TD>            case ByteCode.SIPUSH:</TD></TR><TR><TD CLASS="l">3864</TD><TD>                return 2;</TD></TR><TR><TD CLASS="l">3865</TD><TD> </TD></TR><TR><TD CLASS="l">3866</TD><TD>            case ByteCode.MULTIANEWARRAY:</TD></TR><TR><TD CLASS="l">3867</TD><TD>                return 3;</TD></TR><TR><TD CLASS="l">3868</TD><TD> </TD></TR><TR><TD CLASS="l">3869</TD><TD>            case ByteCode.GOTO_W:</TD></TR><TR><TD CLASS="l">3870</TD><TD>            case ByteCode.JSR_W:</TD></TR><TR><TD CLASS="l">3871</TD><TD>                return 4;</TD></TR><TR><TD CLASS="l">3872</TD><TD> </TD></TR><TR><TD CLASS="l">3873</TD><TD>            case ByteCode.LOOKUPSWITCH:    // depends on alignment</TD></TR><TR><TD CLASS="l">3874</TD><TD>            case ByteCode.TABLESWITCH: // depends on alignment</TD></TR><TR><TD CLASS="l">3875</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">3876</TD><TD>        }</TD></TR><TR><TD CLASS="l">3877</TD><TD>        throw new IllegalArgumentException(&#34;Bad opcode: &#34;+opcode);</TD></TR><TR><TD CLASS="l">3878</TD><TD>    }</TD></TR><TR><TD CLASS="l">3879</TD><TD>*/</TD></TR><TR><TD CLASS="l">3880</TD><TD>    private static String bytecodeStr(int code)</TD></TR><TR><TD CLASS="l">3881</TD><TD>    {</TD></TR><TR><TD CLASS="l">3882</TD><TD>        if (DEBUGSTACK || DEBUGCODE) {</TD></TR><TR><TD CLASS="l">3883</TD><TD>            switch (code) {</TD></TR><TR><TD CLASS="l">3884</TD><TD>                case ByteCode.NOP:              return &#34;nop&#34;;</TD></TR><TR><TD CLASS="l">3885</TD><TD>                case ByteCode.ACONST_NULL:      return &#34;aconst_null&#34;;</TD></TR><TR><TD CLASS="l">3886</TD><TD>                case ByteCode.ICONST_M1:        return &#34;iconst_m1&#34;;</TD></TR><TR><TD CLASS="l">3887</TD><TD>                case ByteCode.ICONST_0:         return &#34;iconst_0&#34;;</TD></TR><TR><TD CLASS="l">3888</TD><TD>                case ByteCode.ICONST_1:         return &#34;iconst_1&#34;;</TD></TR><TR><TD CLASS="l">3889</TD><TD>                case ByteCode.ICONST_2:         return &#34;iconst_2&#34;;</TD></TR><TR><TD CLASS="l">3890</TD><TD>                case ByteCode.ICONST_3:         return &#34;iconst_3&#34;;</TD></TR><TR><TD CLASS="l">3891</TD><TD>                case ByteCode.ICONST_4:         return &#34;iconst_4&#34;;</TD></TR><TR><TD CLASS="l">3892</TD><TD>                case ByteCode.ICONST_5:         return &#34;iconst_5&#34;;</TD></TR><TR><TD CLASS="l">3893</TD><TD>                case ByteCode.LCONST_0:         return &#34;lconst_0&#34;;</TD></TR><TR><TD CLASS="l">3894</TD><TD>                case ByteCode.LCONST_1:         return &#34;lconst_1&#34;;</TD></TR><TR><TD CLASS="l">3895</TD><TD>                case ByteCode.FCONST_0:         return &#34;fconst_0&#34;;</TD></TR><TR><TD CLASS="l">3896</TD><TD>                case ByteCode.FCONST_1:         return &#34;fconst_1&#34;;</TD></TR><TR><TD CLASS="l">3897</TD><TD>                case ByteCode.FCONST_2:         return &#34;fconst_2&#34;;</TD></TR><TR><TD CLASS="l">3898</TD><TD>                case ByteCode.DCONST_0:         return &#34;dconst_0&#34;;</TD></TR><TR><TD CLASS="l">3899</TD><TD>                case ByteCode.DCONST_1:         return &#34;dconst_1&#34;;</TD></TR><TR><TD CLASS="l">3900</TD><TD>                case ByteCode.BIPUSH:           return &#34;bipush&#34;;</TD></TR><TR><TD CLASS="l">3901</TD><TD>                case ByteCode.SIPUSH:           return &#34;sipush&#34;;</TD></TR><TR><TD CLASS="l">3902</TD><TD>                case ByteCode.LDC:              return &#34;ldc&#34;;</TD></TR><TR><TD CLASS="l">3903</TD><TD>                case ByteCode.LDC_W:            return &#34;ldc_w&#34;;</TD></TR><TR><TD CLASS="l">3904</TD><TD>                case ByteCode.LDC2_W:           return &#34;ldc2_w&#34;;</TD></TR><TR><TD CLASS="l">3905</TD><TD>                case ByteCode.ILOAD:            return &#34;iload&#34;;</TD></TR><TR><TD CLASS="l">3906</TD><TD>                case ByteCode.LLOAD:            return &#34;lload&#34;;</TD></TR><TR><TD CLASS="l">3907</TD><TD>                case ByteCode.FLOAD:            return &#34;fload&#34;;</TD></TR><TR><TD CLASS="l">3908</TD><TD>                case ByteCode.DLOAD:            return &#34;dload&#34;;</TD></TR><TR><TD CLASS="l">3909</TD><TD>                case ByteCode.ALOAD:            return &#34;aload&#34;;</TD></TR><TR><TD CLASS="l">3910</TD><TD>                case ByteCode.ILOAD_0:          return &#34;iload_0&#34;;</TD></TR><TR><TD CLASS="l">3911</TD><TD>                case ByteCode.ILOAD_1:          return &#34;iload_1&#34;;</TD></TR><TR><TD CLASS="l">3912</TD><TD>                case ByteCode.ILOAD_2:          return &#34;iload_2&#34;;</TD></TR><TR><TD CLASS="l">3913</TD><TD>                case ByteCode.ILOAD_3:          return &#34;iload_3&#34;;</TD></TR><TR><TD CLASS="l">3914</TD><TD>                case ByteCode.LLOAD_0:          return &#34;lload_0&#34;;</TD></TR><TR><TD CLASS="l">3915</TD><TD>                case ByteCode.LLOAD_1:          return &#34;lload_1&#34;;</TD></TR><TR><TD CLASS="l">3916</TD><TD>                case ByteCode.LLOAD_2:          return &#34;lload_2&#34;;</TD></TR><TR><TD CLASS="l">3917</TD><TD>                case ByteCode.LLOAD_3:          return &#34;lload_3&#34;;</TD></TR><TR><TD CLASS="l">3918</TD><TD>                case ByteCode.FLOAD_0:          return &#34;fload_0&#34;;</TD></TR><TR><TD CLASS="l">3919</TD><TD>                case ByteCode.FLOAD_1:          return &#34;fload_1&#34;;</TD></TR><TR><TD CLASS="l">3920</TD><TD>                case ByteCode.FLOAD_2:          return &#34;fload_2&#34;;</TD></TR><TR><TD CLASS="l">3921</TD><TD>                case ByteCode.FLOAD_3:          return &#34;fload_3&#34;;</TD></TR><TR><TD CLASS="l">3922</TD><TD>                case ByteCode.DLOAD_0:          return &#34;dload_0&#34;;</TD></TR><TR><TD CLASS="l">3923</TD><TD>                case ByteCode.DLOAD_1:          return &#34;dload_1&#34;;</TD></TR><TR><TD CLASS="l">3924</TD><TD>                case ByteCode.DLOAD_2:          return &#34;dload_2&#34;;</TD></TR><TR><TD CLASS="l">3925</TD><TD>                case ByteCode.DLOAD_3:          return &#34;dload_3&#34;;</TD></TR><TR><TD CLASS="l">3926</TD><TD>                case ByteCode.ALOAD_0:          return &#34;aload_0&#34;;</TD></TR><TR><TD CLASS="l">3927</TD><TD>                case ByteCode.ALOAD_1:          return &#34;aload_1&#34;;</TD></TR><TR><TD CLASS="l">3928</TD><TD>                case ByteCode.ALOAD_2:          return &#34;aload_2&#34;;</TD></TR><TR><TD CLASS="l">3929</TD><TD>                case ByteCode.ALOAD_3:          return &#34;aload_3&#34;;</TD></TR><TR><TD CLASS="l">3930</TD><TD>                case ByteCode.IALOAD:           return &#34;iaload&#34;;</TD></TR><TR><TD CLASS="l">3931</TD><TD>                case ByteCode.LALOAD:           return &#34;laload&#34;;</TD></TR><TR><TD CLASS="l">3932</TD><TD>                case ByteCode.FALOAD:           return &#34;faload&#34;;</TD></TR><TR><TD CLASS="l">3933</TD><TD>                case ByteCode.DALOAD:           return &#34;daload&#34;;</TD></TR><TR><TD CLASS="l">3934</TD><TD>                case ByteCode.AALOAD:           return &#34;aaload&#34;;</TD></TR><TR><TD CLASS="l">3935</TD><TD>                case ByteCode.BALOAD:           return &#34;baload&#34;;</TD></TR><TR><TD CLASS="l">3936</TD><TD>                case ByteCode.CALOAD:           return &#34;caload&#34;;</TD></TR><TR><TD CLASS="l">3937</TD><TD>                case ByteCode.SALOAD:           return &#34;saload&#34;;</TD></TR><TR><TD CLASS="l">3938</TD><TD>                case ByteCode.ISTORE:           return &#34;istore&#34;;</TD></TR><TR><TD CLASS="l">3939</TD><TD>                case ByteCode.LSTORE:           return &#34;lstore&#34;;</TD></TR><TR><TD CLASS="l">3940</TD><TD>                case ByteCode.FSTORE:           return &#34;fstore&#34;;</TD></TR><TR><TD CLASS="l">3941</TD><TD>                case ByteCode.DSTORE:           return &#34;dstore&#34;;</TD></TR><TR><TD CLASS="l">3942</TD><TD>                case ByteCode.ASTORE:           return &#34;astore&#34;;</TD></TR><TR><TD CLASS="l">3943</TD><TD>                case ByteCode.ISTORE_0:         return &#34;istore_0&#34;;</TD></TR><TR><TD CLASS="l">3944</TD><TD>                case ByteCode.ISTORE_1:         return &#34;istore_1&#34;;</TD></TR><TR><TD CLASS="l">3945</TD><TD>                case ByteCode.ISTORE_2:         return &#34;istore_2&#34;;</TD></TR><TR><TD CLASS="l">3946</TD><TD>                case ByteCode.ISTORE_3:         return &#34;istore_3&#34;;</TD></TR><TR><TD CLASS="l">3947</TD><TD>                case ByteCode.LSTORE_0:         return &#34;lstore_0&#34;;</TD></TR><TR><TD CLASS="l">3948</TD><TD>                case ByteCode.LSTORE_1:         return &#34;lstore_1&#34;;</TD></TR><TR><TD CLASS="l">3949</TD><TD>                case ByteCode.LSTORE_2:         return &#34;lstore_2&#34;;</TD></TR><TR><TD CLASS="l">3950</TD><TD>                case ByteCode.LSTORE_3:         return &#34;lstore_3&#34;;</TD></TR><TR><TD CLASS="l">3951</TD><TD>                case ByteCode.FSTORE_0:         return &#34;fstore_0&#34;;</TD></TR><TR><TD CLASS="l">3952</TD><TD>                case ByteCode.FSTORE_1:         return &#34;fstore_1&#34;;</TD></TR><TR><TD CLASS="l">3953</TD><TD>                case ByteCode.FSTORE_2:         return &#34;fstore_2&#34;;</TD></TR><TR><TD CLASS="l">3954</TD><TD>                case ByteCode.FSTORE_3:         return &#34;fstore_3&#34;;</TD></TR><TR><TD CLASS="l">3955</TD><TD>                case ByteCode.DSTORE_0:         return &#34;dstore_0&#34;;</TD></TR><TR><TD CLASS="l">3956</TD><TD>                case ByteCode.DSTORE_1:         return &#34;dstore_1&#34;;</TD></TR><TR><TD CLASS="l">3957</TD><TD>                case ByteCode.DSTORE_2:         return &#34;dstore_2&#34;;</TD></TR><TR><TD CLASS="l">3958</TD><TD>                case ByteCode.DSTORE_3:         return &#34;dstore_3&#34;;</TD></TR><TR><TD CLASS="l">3959</TD><TD>                case ByteCode.ASTORE_0:         return &#34;astore_0&#34;;</TD></TR><TR><TD CLASS="l">3960</TD><TD>                case ByteCode.ASTORE_1:         return &#34;astore_1&#34;;</TD></TR><TR><TD CLASS="l">3961</TD><TD>                case ByteCode.ASTORE_2:         return &#34;astore_2&#34;;</TD></TR><TR><TD CLASS="l">3962</TD><TD>                case ByteCode.ASTORE_3:         return &#34;astore_3&#34;;</TD></TR><TR><TD CLASS="l">3963</TD><TD>                case ByteCode.IASTORE:          return &#34;iastore&#34;;</TD></TR><TR><TD CLASS="l">3964</TD><TD>                case ByteCode.LASTORE:          return &#34;lastore&#34;;</TD></TR><TR><TD CLASS="l">3965</TD><TD>                case ByteCode.FASTORE:          return &#34;fastore&#34;;</TD></TR><TR><TD CLASS="l">3966</TD><TD>                case ByteCode.DASTORE:          return &#34;dastore&#34;;</TD></TR><TR><TD CLASS="l">3967</TD><TD>                case ByteCode.AASTORE:          return &#34;aastore&#34;;</TD></TR><TR><TD CLASS="l">3968</TD><TD>                case ByteCode.BASTORE:          return &#34;bastore&#34;;</TD></TR><TR><TD CLASS="l">3969</TD><TD>                case ByteCode.CASTORE:          return &#34;castore&#34;;</TD></TR><TR><TD CLASS="l">3970</TD><TD>                case ByteCode.SASTORE:          return &#34;sastore&#34;;</TD></TR><TR><TD CLASS="l">3971</TD><TD>                case ByteCode.POP:              return &#34;pop&#34;;</TD></TR><TR><TD CLASS="l">3972</TD><TD>                case ByteCode.POP2:             return &#34;pop2&#34;;</TD></TR><TR><TD CLASS="l">3973</TD><TD>                case ByteCode.DUP:              return &#34;dup&#34;;</TD></TR><TR><TD CLASS="l">3974</TD><TD>                case ByteCode.DUP_X1:           return &#34;dup_x1&#34;;</TD></TR><TR><TD CLASS="l">3975</TD><TD>                case ByteCode.DUP_X2:           return &#34;dup_x2&#34;;</TD></TR><TR><TD CLASS="l">3976</TD><TD>                case ByteCode.DUP2:             return &#34;dup2&#34;;</TD></TR><TR><TD CLASS="l">3977</TD><TD>                case ByteCode.DUP2_X1:          return &#34;dup2_x1&#34;;</TD></TR><TR><TD CLASS="l">3978</TD><TD>                case ByteCode.DUP2_X2:          return &#34;dup2_x2&#34;;</TD></TR><TR><TD CLASS="l">3979</TD><TD>                case ByteCode.SWAP:             return &#34;swap&#34;;</TD></TR><TR><TD CLASS="l">3980</TD><TD>                case ByteCode.IADD:             return &#34;iadd&#34;;</TD></TR><TR><TD CLASS="l">3981</TD><TD>                case ByteCode.LADD:             return &#34;ladd&#34;;</TD></TR><TR><TD CLASS="l">3982</TD><TD>                case ByteCode.FADD:             return &#34;fadd&#34;;</TD></TR><TR><TD CLASS="l">3983</TD><TD>                case ByteCode.DADD:             return &#34;dadd&#34;;</TD></TR><TR><TD CLASS="l">3984</TD><TD>                case ByteCode.ISUB:             return &#34;isub&#34;;</TD></TR><TR><TD CLASS="l">3985</TD><TD>                case ByteCode.LSUB:             return &#34;lsub&#34;;</TD></TR><TR><TD CLASS="l">3986</TD><TD>                case ByteCode.FSUB:             return &#34;fsub&#34;;</TD></TR><TR><TD CLASS="l">3987</TD><TD>                case ByteCode.DSUB:             return &#34;dsub&#34;;</TD></TR><TR><TD CLASS="l">3988</TD><TD>                case ByteCode.IMUL:             return &#34;imul&#34;;</TD></TR><TR><TD CLASS="l">3989</TD><TD>                case ByteCode.LMUL:             return &#34;lmul&#34;;</TD></TR><TR><TD CLASS="l">3990</TD><TD>                case ByteCode.FMUL:             return &#34;fmul&#34;;</TD></TR><TR><TD CLASS="l">3991</TD><TD>                case ByteCode.DMUL:             return &#34;dmul&#34;;</TD></TR><TR><TD CLASS="l">3992</TD><TD>                case ByteCode.IDIV:             return &#34;idiv&#34;;</TD></TR><TR><TD CLASS="l">3993</TD><TD>                case ByteCode.LDIV:             return &#34;ldiv&#34;;</TD></TR><TR><TD CLASS="l">3994</TD><TD>                case ByteCode.FDIV:             return &#34;fdiv&#34;;</TD></TR><TR><TD CLASS="l">3995</TD><TD>                case ByteCode.DDIV:             return &#34;ddiv&#34;;</TD></TR><TR><TD CLASS="l">3996</TD><TD>                case ByteCode.IREM:             return &#34;irem&#34;;</TD></TR><TR><TD CLASS="l">3997</TD><TD>                case ByteCode.LREM:             return &#34;lrem&#34;;</TD></TR><TR><TD CLASS="l">3998</TD><TD>                case ByteCode.FREM:             return &#34;frem&#34;;</TD></TR><TR><TD CLASS="l">3999</TD><TD>                case ByteCode.DREM:             return &#34;drem&#34;;</TD></TR><TR><TD CLASS="l">4000</TD><TD>                case ByteCode.INEG:             return &#34;ineg&#34;;</TD></TR><TR><TD CLASS="l">4001</TD><TD>                case ByteCode.LNEG:             return &#34;lneg&#34;;</TD></TR><TR><TD CLASS="l">4002</TD><TD>                case ByteCode.FNEG:             return &#34;fneg&#34;;</TD></TR><TR><TD CLASS="l">4003</TD><TD>                case ByteCode.DNEG:             return &#34;dneg&#34;;</TD></TR><TR><TD CLASS="l">4004</TD><TD>                case ByteCode.ISHL:             return &#34;ishl&#34;;</TD></TR><TR><TD CLASS="l">4005</TD><TD>                case ByteCode.LSHL:             return &#34;lshl&#34;;</TD></TR><TR><TD CLASS="l">4006</TD><TD>                case ByteCode.ISHR:             return &#34;ishr&#34;;</TD></TR><TR><TD CLASS="l">4007</TD><TD>                case ByteCode.LSHR:             return &#34;lshr&#34;;</TD></TR><TR><TD CLASS="l">4008</TD><TD>                case ByteCode.IUSHR:            return &#34;iushr&#34;;</TD></TR><TR><TD CLASS="l">4009</TD><TD>                case ByteCode.LUSHR:            return &#34;lushr&#34;;</TD></TR><TR><TD CLASS="l">4010</TD><TD>                case ByteCode.IAND:             return &#34;iand&#34;;</TD></TR><TR><TD CLASS="l">4011</TD><TD>                case ByteCode.LAND:             return &#34;land&#34;;</TD></TR><TR><TD CLASS="l">4012</TD><TD>                case ByteCode.IOR:              return &#34;ior&#34;;</TD></TR><TR><TD CLASS="l">4013</TD><TD>                case ByteCode.LOR:              return &#34;lor&#34;;</TD></TR><TR><TD CLASS="l">4014</TD><TD>                case ByteCode.IXOR:             return &#34;ixor&#34;;</TD></TR><TR><TD CLASS="l">4015</TD><TD>                case ByteCode.LXOR:             return &#34;lxor&#34;;</TD></TR><TR><TD CLASS="l">4016</TD><TD>                case ByteCode.IINC:             return &#34;iinc&#34;;</TD></TR><TR><TD CLASS="l">4017</TD><TD>                case ByteCode.I2L:              return &#34;i2l&#34;;</TD></TR><TR><TD CLASS="l">4018</TD><TD>                case ByteCode.I2F:              return &#34;i2f&#34;;</TD></TR><TR><TD CLASS="l">4019</TD><TD>                case ByteCode.I2D:              return &#34;i2d&#34;;</TD></TR><TR><TD CLASS="l">4020</TD><TD>                case ByteCode.L2I:              return &#34;l2i&#34;;</TD></TR><TR><TD CLASS="l">4021</TD><TD>                case ByteCode.L2F:              return &#34;l2f&#34;;</TD></TR><TR><TD CLASS="l">4022</TD><TD>                case ByteCode.L2D:              return &#34;l2d&#34;;</TD></TR><TR><TD CLASS="l">4023</TD><TD>                case ByteCode.F2I:              return &#34;f2i&#34;;</TD></TR><TR><TD CLASS="l">4024</TD><TD>                case ByteCode.F2L:              return &#34;f2l&#34;;</TD></TR><TR><TD CLASS="l">4025</TD><TD>                case ByteCode.F2D:              return &#34;f2d&#34;;</TD></TR><TR><TD CLASS="l">4026</TD><TD>                case ByteCode.D2I:              return &#34;d2i&#34;;</TD></TR><TR><TD CLASS="l">4027</TD><TD>                case ByteCode.D2L:              return &#34;d2l&#34;;</TD></TR><TR><TD CLASS="l">4028</TD><TD>                case ByteCode.D2F:              return &#34;d2f&#34;;</TD></TR><TR><TD CLASS="l">4029</TD><TD>                case ByteCode.I2B:              return &#34;i2b&#34;;</TD></TR><TR><TD CLASS="l">4030</TD><TD>                case ByteCode.I2C:              return &#34;i2c&#34;;</TD></TR><TR><TD CLASS="l">4031</TD><TD>                case ByteCode.I2S:              return &#34;i2s&#34;;</TD></TR><TR><TD CLASS="l">4032</TD><TD>                case ByteCode.LCMP:             return &#34;lcmp&#34;;</TD></TR><TR><TD CLASS="l">4033</TD><TD>                case ByteCode.FCMPL:            return &#34;fcmpl&#34;;</TD></TR><TR><TD CLASS="l">4034</TD><TD>                case ByteCode.FCMPG:            return &#34;fcmpg&#34;;</TD></TR><TR><TD CLASS="l">4035</TD><TD>                case ByteCode.DCMPL:            return &#34;dcmpl&#34;;</TD></TR><TR><TD CLASS="l">4036</TD><TD>                case ByteCode.DCMPG:            return &#34;dcmpg&#34;;</TD></TR><TR><TD CLASS="l">4037</TD><TD>                case ByteCode.IFEQ:             return &#34;ifeq&#34;;</TD></TR><TR><TD CLASS="l">4038</TD><TD>                case ByteCode.IFNE:             return &#34;ifne&#34;;</TD></TR><TR><TD CLASS="l">4039</TD><TD>                case ByteCode.IFLT:             return &#34;iflt&#34;;</TD></TR><TR><TD CLASS="l">4040</TD><TD>                case ByteCode.IFGE:             return &#34;ifge&#34;;</TD></TR><TR><TD CLASS="l">4041</TD><TD>                case ByteCode.IFGT:             return &#34;ifgt&#34;;</TD></TR><TR><TD CLASS="l">4042</TD><TD>                case ByteCode.IFLE:             return &#34;ifle&#34;;</TD></TR><TR><TD CLASS="l">4043</TD><TD>                case ByteCode.IF_ICMPEQ:        return &#34;if_icmpeq&#34;;</TD></TR><TR><TD CLASS="l">4044</TD><TD>                case ByteCode.IF_ICMPNE:        return &#34;if_icmpne&#34;;</TD></TR><TR><TD CLASS="l">4045</TD><TD>                case ByteCode.IF_ICMPLT:        return &#34;if_icmplt&#34;;</TD></TR><TR><TD CLASS="l">4046</TD><TD>                case ByteCode.IF_ICMPGE:        return &#34;if_icmpge&#34;;</TD></TR><TR><TD CLASS="l">4047</TD><TD>                case ByteCode.IF_ICMPGT:        return &#34;if_icmpgt&#34;;</TD></TR><TR><TD CLASS="l">4048</TD><TD>                case ByteCode.IF_ICMPLE:        return &#34;if_icmple&#34;;</TD></TR><TR><TD CLASS="l">4049</TD><TD>                case ByteCode.IF_ACMPEQ:        return &#34;if_acmpeq&#34;;</TD></TR><TR><TD CLASS="l">4050</TD><TD>                case ByteCode.IF_ACMPNE:        return &#34;if_acmpne&#34;;</TD></TR><TR><TD CLASS="l">4051</TD><TD>                case ByteCode.GOTO:             return &#34;goto&#34;;</TD></TR><TR><TD CLASS="l">4052</TD><TD>                case ByteCode.JSR:              return &#34;jsr&#34;;</TD></TR><TR><TD CLASS="l">4053</TD><TD>                case ByteCode.RET:              return &#34;ret&#34;;</TD></TR><TR><TD CLASS="l">4054</TD><TD>                case ByteCode.TABLESWITCH:      return &#34;tableswitch&#34;;</TD></TR><TR><TD CLASS="l">4055</TD><TD>                case ByteCode.LOOKUPSWITCH:     return &#34;lookupswitch&#34;;</TD></TR><TR><TD CLASS="l">4056</TD><TD>                case ByteCode.IRETURN:          return &#34;ireturn&#34;;</TD></TR><TR><TD CLASS="l">4057</TD><TD>                case ByteCode.LRETURN:          return &#34;lreturn&#34;;</TD></TR><TR><TD CLASS="l">4058</TD><TD>                case ByteCode.FRETURN:          return &#34;freturn&#34;;</TD></TR><TR><TD CLASS="l">4059</TD><TD>                case ByteCode.DRETURN:          return &#34;dreturn&#34;;</TD></TR><TR><TD CLASS="l">4060</TD><TD>                case ByteCode.ARETURN:          return &#34;areturn&#34;;</TD></TR><TR><TD CLASS="l">4061</TD><TD>                case ByteCode.RETURN:           return &#34;return&#34;;</TD></TR><TR><TD CLASS="l">4062</TD><TD>                case ByteCode.GETSTATIC:        return &#34;getstatic&#34;;</TD></TR><TR><TD CLASS="l">4063</TD><TD>                case ByteCode.PUTSTATIC:        return &#34;putstatic&#34;;</TD></TR><TR><TD CLASS="l">4064</TD><TD>                case ByteCode.GETFIELD:         return &#34;getfield&#34;;</TD></TR><TR><TD CLASS="l">4065</TD><TD>                case ByteCode.PUTFIELD:         return &#34;putfield&#34;;</TD></TR><TR><TD CLASS="l">4066</TD><TD>                case ByteCode.INVOKEVIRTUAL:    return &#34;invokevirtual&#34;;</TD></TR><TR><TD CLASS="l">4067</TD><TD>                case ByteCode.INVOKESPECIAL:    return &#34;invokespecial&#34;;</TD></TR><TR><TD CLASS="l">4068</TD><TD>                case ByteCode.INVOKESTATIC:     return &#34;invokestatic&#34;;</TD></TR><TR><TD CLASS="l">4069</TD><TD>                case ByteCode.INVOKEINTERFACE:  return &#34;invokeinterface&#34;;</TD></TR><TR><TD CLASS="l">4070</TD><TD>                case ByteCode.NEW:              return &#34;new&#34;;</TD></TR><TR><TD CLASS="l">4071</TD><TD>                case ByteCode.NEWARRAY:         return &#34;newarray&#34;;</TD></TR><TR><TD CLASS="l">4072</TD><TD>                case ByteCode.ANEWARRAY:        return &#34;anewarray&#34;;</TD></TR><TR><TD CLASS="l">4073</TD><TD>                case ByteCode.ARRAYLENGTH:      return &#34;arraylength&#34;;</TD></TR><TR><TD CLASS="l">4074</TD><TD>                case ByteCode.ATHROW:           return &#34;athrow&#34;;</TD></TR><TR><TD CLASS="l">4075</TD><TD>                case ByteCode.CHECKCAST:        return &#34;checkcast&#34;;</TD></TR><TR><TD CLASS="l">4076</TD><TD>                case ByteCode.INSTANCEOF:       return &#34;instanceof&#34;;</TD></TR><TR><TD CLASS="l">4077</TD><TD>                case ByteCode.MONITORENTER:     return &#34;monitorenter&#34;;</TD></TR><TR><TD CLASS="l">4078</TD><TD>                case ByteCode.MONITOREXIT:      return &#34;monitorexit&#34;;</TD></TR><TR><TD CLASS="l">4079</TD><TD>                case ByteCode.WIDE:             return &#34;wide&#34;;</TD></TR><TR><TD CLASS="l">4080</TD><TD>                case ByteCode.MULTIANEWARRAY:   return &#34;multianewarray&#34;;</TD></TR><TR><TD CLASS="l">4081</TD><TD>                case ByteCode.IFNULL:           return &#34;ifnull&#34;;</TD></TR><TR><TD CLASS="l">4082</TD><TD>                case ByteCode.IFNONNULL:        return &#34;ifnonnull&#34;;</TD></TR><TR><TD CLASS="l">4083</TD><TD>                case ByteCode.GOTO_W:           return &#34;goto_w&#34;;</TD></TR><TR><TD CLASS="l">4084</TD><TD>                case ByteCode.JSR_W:            return &#34;jsr_w&#34;;</TD></TR><TR><TD CLASS="l">4085</TD><TD>                case ByteCode.BREAKPOINT:       return &#34;breakpoint&#34;;</TD></TR><TR><TD CLASS="l">4086</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="6c">4087</A></TD><TD>                case ByteCode.IMPDEP1:          return &#34;impdep1&#34;;</TD></TR><TR><TD CLASS="l">4088</TD><TD>                case ByteCode.IMPDEP2:          return &#34;impdep2&#34;;</TD></TR><TR><TD CLASS="l">4089</TD><TD>            }</TD></TR><TR><TD CLASS="l">4090</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4091</TD><TD>        return &#34;&#34;;</TD></TR><TR><TD CLASS="l"><A NAME="a4">4092</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4093</TD><TD> </TD></TR><TR><TD CLASS="l">4094</TD><TD>    final char[] getCharBuffer(int minimalSize)</TD></TR><TR><TD CLASS="l">4095</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4096</TD><TD>        if (minimalSize &gt; tmpCharBuffer.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">4097</TD><TD>            int newSize = tmpCharBuffer.length * 2;</TD></TR><TR CLASS="c"><TD CLASS="l">4098</TD><TD>            if (minimalSize &gt; newSize) { newSize = minimalSize; }</TD></TR><TR CLASS="c"><TD CLASS="l">4099</TD><TD>            tmpCharBuffer = new char[newSize];</TD></TR><TR><TD CLASS="l">4100</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4101</TD><TD>        return tmpCharBuffer;</TD></TR><TR><TD CLASS="l">4102</TD><TD>    }</TD></TR><TR><TD CLASS="l">4103</TD><TD> </TD></TR><TR><TD CLASS="l">4104</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4105</TD><TD>     * Add a pc as the start of super block.</TD></TR><TR><TD CLASS="l">4106</TD><TD>     *</TD></TR><TR><TD CLASS="l">4107</TD><TD>     * A pc is the beginning of a super block if:</TD></TR><TR><TD CLASS="l">4108</TD><TD>     * - pc == 0</TD></TR><TR><TD CLASS="l">4109</TD><TD>     * - it is the target of a branch instruction</TD></TR><TR><TD CLASS="l"><A NAME="75">4110</A></TD><TD>     * - it is the beginning of an exception handler</TD></TR><TR><TD CLASS="l">4111</TD><TD>     * - it is directly after an unconditional jump</TD></TR><TR><TD CLASS="l">4112</TD><TD>     */</TD></TR><TR><TD CLASS="l">4113</TD><TD>    private void addSuperBlockStart(int pc) {</TD></TR><TR CLASS="c"><TD CLASS="l">4114</TD><TD>        if (GenerateStackMap) {</TD></TR><TR CLASS="z"><TD CLASS="l">4115</TD><TD>            if (itsSuperBlockStarts == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4116</TD><TD>                itsSuperBlockStarts = new int[SuperBlockStartsSize];</TD></TR><TR CLASS="z"><TD CLASS="l">4117</TD><TD>            } else if (itsSuperBlockStarts.length == itsSuperBlockStartsTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">4118</TD><TD>                int[] tmp = new int[itsSuperBlockStartsTop * 2];</TD></TR><TR CLASS="z"><TD CLASS="l">4119</TD><TD>                System.arraycopy(itsSuperBlockStarts, 0, tmp, 0,</TD></TR><TR><TD CLASS="l">4120</TD><TD>                                 itsSuperBlockStartsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4121</TD><TD>                itsSuperBlockStarts = tmp;</TD></TR><TR><TD CLASS="l">4122</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4123</TD><TD>            itsSuperBlockStarts[itsSuperBlockStartsTop++] = pc;</TD></TR><TR><TD CLASS="l">4124</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4125</TD><TD>    }</TD></TR><TR><TD CLASS="l">4126</TD><TD> </TD></TR><TR><TD CLASS="l">4127</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4128</TD><TD>     * Sort the list of recorded super block starts and remove duplicates.</TD></TR><TR><TD CLASS="l">4129</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="70">4130</A></TD><TD>     * Also adds exception handling blocks as block starts, since there is no</TD></TR><TR><TD CLASS="l">4131</TD><TD>     * explicit control flow to these. Used for stack map table generation.</TD></TR><TR><TD CLASS="l">4132</TD><TD>     */</TD></TR><TR><TD CLASS="l">4133</TD><TD>    private void finalizeSuperBlockStarts() {</TD></TR><TR CLASS="z"><TD CLASS="l">4134</TD><TD>        if (GenerateStackMap) {</TD></TR><TR CLASS="z"><TD CLASS="l">4135</TD><TD>            for (int i = 0; i &lt; itsExceptionTableTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4136</TD><TD>                ExceptionTableEntry ete = itsExceptionTable[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4137</TD><TD>                short handlerPC = (short) getLabelPC(ete.itsHandlerLabel);</TD></TR><TR CLASS="z"><TD CLASS="l">4138</TD><TD>                addSuperBlockStart(handlerPC);</TD></TR><TR><TD CLASS="l">4139</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4140</TD><TD>            Arrays.sort(itsSuperBlockStarts, 0, itsSuperBlockStartsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4141</TD><TD>            int prev = itsSuperBlockStarts[0];</TD></TR><TR CLASS="z"><TD CLASS="l">4142</TD><TD>            int copyTo = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">4143</TD><TD>            for (int i = 1; i &lt; itsSuperBlockStartsTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4144</TD><TD>                int curr = itsSuperBlockStarts[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4145</TD><TD>                if (prev != curr) {</TD></TR><TR CLASS="z"><TD CLASS="l">4146</TD><TD>                    if (copyTo != i) {</TD></TR><TR CLASS="z"><TD CLASS="l">4147</TD><TD>                        itsSuperBlockStarts[copyTo] = curr;</TD></TR><TR><TD CLASS="l">4148</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">4149</TD><TD>                    copyTo++;</TD></TR><TR CLASS="z"><TD CLASS="l">4150</TD><TD>                    prev = curr;</TD></TR><TR><TD CLASS="l">4151</TD><TD>                }</TD></TR><TR><TD CLASS="l">4152</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4153</TD><TD>            itsSuperBlockStartsTop = copyTo;</TD></TR><TR CLASS="z"><TD CLASS="l">4154</TD><TD>            if (itsSuperBlockStarts[copyTo - 1] == itsCodeBufferTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">4155</TD><TD>                itsSuperBlockStartsTop--;</TD></TR><TR><TD CLASS="l">4156</TD><TD>            }</TD></TR><TR><TD CLASS="l">4157</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4158</TD><TD>    }</TD></TR><TR><TD CLASS="l">4159</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4160</TD><TD>    private int[] itsSuperBlockStarts = null;</TD></TR><TR CLASS="c"><TD CLASS="l">4161</TD><TD>    private int itsSuperBlockStartsTop = 0;</TD></TR><TR><TD CLASS="l">4162</TD><TD>    private static final int SuperBlockStartsSize = 4;</TD></TR><TR><TD CLASS="l">4163</TD><TD> </TD></TR><TR><TD CLASS="l">4164</TD><TD>    // Used to find blocks of code with no dependencies (aka dead code).</TD></TR><TR><TD CLASS="l">4165</TD><TD>    // Necessary for generating type information for dead code, which is</TD></TR><TR><TD CLASS="l">4166</TD><TD>    // expected by the Sun verifier. It is only necessary to store a single</TD></TR><TR><TD CLASS="l">4167</TD><TD>    // jump source to determine if a block is reachable or not.</TD></TR><TR CLASS="c"><TD CLASS="l">4168</TD><TD>    private UintMap itsJumpFroms = null;</TD></TR><TR><TD CLASS="l">4169</TD><TD> </TD></TR><TR><TD CLASS="l">4170</TD><TD>    private static final int LineNumberTableSize = 16;</TD></TR><TR><TD CLASS="l">4171</TD><TD>    private static final int ExceptionTableSize = 4;</TD></TR><TR><TD CLASS="l">4172</TD><TD> </TD></TR><TR><TD CLASS="l">4173</TD><TD>    private static final int MajorVersion;</TD></TR><TR><TD CLASS="l">4174</TD><TD>    private static final int MinorVersion;</TD></TR><TR><TD CLASS="l">4175</TD><TD>    private static final boolean GenerateStackMap;</TD></TR><TR><TD CLASS="l">4176</TD><TD> </TD></TR><TR><TD CLASS="l">4177</TD><TD>    static {</TD></TR><TR><TD CLASS="l">4178</TD><TD>        // Figure out which classfile version should be generated. This assumes</TD></TR><TR><TD CLASS="l">4179</TD><TD>        // that the runtime used to compile the JavaScript files is the same as</TD></TR><TR><TD CLASS="l">4180</TD><TD>        // the one used to run them. This is important because there are cases</TD></TR><TR><TD CLASS="l">4181</TD><TD>        // when bytecode is generated at runtime, where it is not easy to pass</TD></TR><TR><TD CLASS="l">4182</TD><TD>        // along what version is necessary. Instead, we grab the version numbers</TD></TR><TR><TD CLASS="l">4183</TD><TD>        // from the bytecode of this class and use that.</TD></TR><TR><TD CLASS="l"><A NAME="79">4184</A></TD><TD>        //</TD></TR><TR><TD CLASS="l">4185</TD><TD>        // Based on the version numbers we scrape, we can also determine what</TD></TR><TR><TD CLASS="l">4186</TD><TD>        // bytecode features we need. For example, Java 6 bytecode (classfile</TD></TR><TR><TD CLASS="l">4187</TD><TD>        // version 50) should have stack maps generated.</TD></TR><TR CLASS="c"><TD CLASS="l">4188</TD><TD>        InputStream is = null;</TD></TR><TR CLASS="c"><TD CLASS="l">4189</TD><TD>        int major = 48, minor = 0;</TD></TR><TR><TD CLASS="l">4190</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">4191</TD><TD>            is = ClassFileWriter.class.getResourceAsStream(&#34;ClassFileWriter.class&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">4192</TD><TD>            if (is == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">4193</TD><TD>                is = ClassLoader.getSystemResourceAsStream(</TD></TR><TR><TD CLASS="l">4194</TD><TD>                    &#34;org/mozilla/classfile/ClassFileWriter.class&#34;);</TD></TR><TR><TD CLASS="l">4195</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4196</TD><TD>            byte[] header = new byte[8];</TD></TR><TR><TD CLASS="l">4197</TD><TD>            // read loop is required since JDK7 will only provide 2 bytes</TD></TR><TR><TD CLASS="l">4198</TD><TD>            // on the first read() - see bug #630111</TD></TR><TR CLASS="c"><TD CLASS="l">4199</TD><TD>            int read = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">4200</TD><TD>            while (read &lt; 8) {</TD></TR><TR CLASS="c"><TD CLASS="l">4201</TD><TD>                int c = is.read(header, read, 8 - read);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="71% line coverage (10 out of 14 instructions)">4202</TD><TD TITLE="71% line coverage (10 out of 14 instructions)">                if (c &lt; 0) throw new IOException();</TD></TR><TR CLASS="c"><TD CLASS="l">4203</TD><TD>                read += c;</TD></TR><TR CLASS="c"><TD CLASS="l">4204</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4205</TD><TD>            minor = (header[4] &lt;&lt; 8) | (header[5] &amp; 0xff);</TD></TR><TR CLASS="c"><TD CLASS="l">4206</TD><TD>            major = (header[6] &lt;&lt; 8) | (header[7] &amp; 0xff);</TD></TR><TR CLASS="z"><TD CLASS="l">4207</TD><TD>        } catch (Exception e) {</TD></TR><TR><TD CLASS="l">4208</TD><TD>            // Unable to get class file, use default bytecode version</TD></TR><TR><TD CLASS="l">4209</TD><TD>        } finally {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="66% line coverage (31 out of 47 instructions)">4210</TD><TD TITLE="66% line coverage (31 out of 47 instructions)">            MinorVersion = minor;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="66% line coverage (31 out of 47 instructions)">4211</TD><TD TITLE="66% line coverage (31 out of 47 instructions)">            MajorVersion = major;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="54% line coverage (35 out of 65 instructions)">4212</TD><TD TITLE="54% line coverage (35 out of 65 instructions)">            GenerateStackMap = major &gt;= 50;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="33% line coverage (3 out of 9 instructions)">4213</TD><TD TITLE="33% line coverage (3 out of 9 instructions)">            if (is != null) {</TD></TR><TR><TD CLASS="l">4214</TD><TD>                try {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="33% line coverage (3 out of 9 instructions)">4215</TD><TD TITLE="33% line coverage (3 out of 9 instructions)">                    is.close();</TD></TR><TR CLASS="z"><TD CLASS="l">4216</TD><TD>                } catch (IOException e) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="20% line coverage (3 out of 15 instructions)">4217</TD><TD TITLE="20% line coverage (3 out of 15 instructions)">                }</TD></TR><TR><TD CLASS="l">4218</TD><TD>            }</TD></TR><TR><TD CLASS="l">4219</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4220</TD><TD>    }</TD></TR><TR><TD CLASS="l">4221</TD><TD> </TD></TR><TR><TD CLASS="l">4222</TD><TD>    private final static int FileHeaderConstant = 0xCAFEBABE;</TD></TR><TR><TD CLASS="l">4223</TD><TD>    // Set DEBUG flags to true to get better checking and progress info.</TD></TR><TR><TD CLASS="l">4224</TD><TD>    private static final boolean DEBUGSTACK = false;</TD></TR><TR><TD CLASS="l">4225</TD><TD>    private static final boolean DEBUGLABELS = false;</TD></TR><TR><TD CLASS="l">4226</TD><TD>    private static final boolean DEBUGCODE = false;</TD></TR><TR><TD CLASS="l">4227</TD><TD> </TD></TR><TR><TD CLASS="l">4228</TD><TD>    private String generatedClassName;</TD></TR><TR><TD CLASS="l">4229</TD><TD> </TD></TR><TR><TD CLASS="l">4230</TD><TD>    private ExceptionTableEntry itsExceptionTable[];</TD></TR><TR><TD CLASS="l">4231</TD><TD>    private int itsExceptionTableTop;</TD></TR><TR><TD CLASS="l">4232</TD><TD> </TD></TR><TR><TD CLASS="l">4233</TD><TD>    private int itsLineNumberTable[];   // pack start_pc &amp; line_number together</TD></TR><TR><TD CLASS="l">4234</TD><TD>    private int itsLineNumberTableTop;</TD></TR><TR><TD CLASS="l">4235</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4236</TD><TD>    private byte[] itsCodeBuffer = new byte[256];</TD></TR><TR><TD CLASS="l">4237</TD><TD>    private int itsCodeBufferTop;</TD></TR><TR><TD CLASS="l">4238</TD><TD> </TD></TR><TR><TD CLASS="l">4239</TD><TD>    private ConstantPool itsConstantPool;</TD></TR><TR><TD CLASS="l">4240</TD><TD> </TD></TR><TR><TD CLASS="l">4241</TD><TD>    private ClassFileMethod itsCurrentMethod;</TD></TR><TR><TD CLASS="l">4242</TD><TD>    private short itsStackTop;</TD></TR><TR><TD CLASS="l">4243</TD><TD> </TD></TR><TR><TD CLASS="l">4244</TD><TD>    private short itsMaxStack;</TD></TR><TR><TD CLASS="l">4245</TD><TD>    private short itsMaxLocals;</TD></TR><TR><TD CLASS="l">4246</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4247</TD><TD>    private ObjArray itsMethods = new ObjArray();</TD></TR><TR CLASS="c"><TD CLASS="l">4248</TD><TD>    private ObjArray itsFields = new ObjArray();</TD></TR><TR CLASS="c"><TD CLASS="l">4249</TD><TD>    private ObjArray itsInterfaces = new ObjArray();</TD></TR><TR><TD CLASS="l">4250</TD><TD> </TD></TR><TR><TD CLASS="l">4251</TD><TD>    private short itsFlags;</TD></TR><TR><TD CLASS="l">4252</TD><TD>    private short itsThisClassIndex;</TD></TR><TR><TD CLASS="l">4253</TD><TD>    private short itsSuperClassIndex;</TD></TR><TR><TD CLASS="l">4254</TD><TD>    private short itsSourceFileNameIndex;</TD></TR><TR><TD CLASS="l">4255</TD><TD> </TD></TR><TR><TD CLASS="l">4256</TD><TD>    private static final int MIN_LABEL_TABLE_SIZE = 32;</TD></TR><TR><TD CLASS="l">4257</TD><TD>    private int[] itsLabelTable;</TD></TR><TR><TD CLASS="l">4258</TD><TD>    private int itsLabelTableTop;</TD></TR><TR><TD CLASS="l">4259</TD><TD> </TD></TR><TR><TD CLASS="l">4260</TD><TD>// itsFixupTable[i] = (label_index &lt;&lt; 32) | fixup_site</TD></TR><TR><TD CLASS="l">4261</TD><TD>    private static final int MIN_FIXUP_TABLE_SIZE = 40;</TD></TR><TR><TD CLASS="l">4262</TD><TD>    private long[] itsFixupTable;</TD></TR><TR><TD CLASS="l">4263</TD><TD>    private int itsFixupTableTop;</TD></TR><TR><TD CLASS="l">4264</TD><TD>    private ObjArray itsVarDescriptors;</TD></TR><TR><TD CLASS="l">4265</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4266</TD><TD>    private char[] tmpCharBuffer = new char[64];</TD></TR><TR><TD CLASS="l">4267</TD><TD>}</TD></TR><TR><TD CLASS="l">4268</TD><TD> </TD></TR><TR><TD CLASS="l">4269</TD><TD>final class ExceptionTableEntry</TD></TR><TR><TD CLASS="l"><A NAME="d8">4270</A></TD><TD>{</TD></TR><TR><TD CLASS="l">4271</TD><TD> </TD></TR><TR><TD CLASS="l">4272</TD><TD>    ExceptionTableEntry(int startLabel, int endLabel,</TD></TR><TR><TD CLASS="l">4273</TD><TD>                        int handlerLabel, short catchType)</TD></TR><TR CLASS="c"><TD CLASS="l">4274</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4275</TD><TD>        itsStartLabel = startLabel;</TD></TR><TR CLASS="c"><TD CLASS="l">4276</TD><TD>        itsEndLabel = endLabel;</TD></TR><TR CLASS="c"><TD CLASS="l">4277</TD><TD>        itsHandlerLabel = handlerLabel;</TD></TR><TR CLASS="c"><TD CLASS="l">4278</TD><TD>        itsCatchType = catchType;</TD></TR><TR CLASS="c"><TD CLASS="l">4279</TD><TD>    }</TD></TR><TR><TD CLASS="l">4280</TD><TD> </TD></TR><TR><TD CLASS="l">4281</TD><TD>    int itsStartLabel;</TD></TR><TR><TD CLASS="l">4282</TD><TD>    int itsEndLabel;</TD></TR><TR><TD CLASS="l">4283</TD><TD>    int itsHandlerLabel;</TD></TR><TR><TD CLASS="l">4284</TD><TD>    short itsCatchType;</TD></TR><TR><TD CLASS="l">4285</TD><TD>}</TD></TR><TR><TD CLASS="l">4286</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="4b">4287</A></TD><TD>final class ClassFileField</TD></TR><TR><TD CLASS="l">4288</TD><TD>{</TD></TR><TR><TD CLASS="l">4289</TD><TD> </TD></TR><TR><TD CLASS="l">4290</TD><TD>    ClassFileField(short nameIndex, short typeIndex, short flags)</TD></TR><TR CLASS="c"><TD CLASS="l">4291</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4292</TD><TD>        itsNameIndex = nameIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4293</TD><TD>        itsTypeIndex = typeIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4294</TD><TD>        itsFlags = flags;</TD></TR><TR CLASS="c"><TD CLASS="l">4295</TD><TD>        itsHasAttributes = false;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="4c">4296</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4297</TD><TD> </TD></TR><TR><TD CLASS="l">4298</TD><TD>    void setAttributes(short attr1, short attr2, short attr3, int index)</TD></TR><TR><TD CLASS="l">4299</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4300</TD><TD>        itsHasAttributes = true;</TD></TR><TR CLASS="z"><TD CLASS="l">4301</TD><TD>        itsAttr1 = attr1;</TD></TR><TR CLASS="z"><TD CLASS="l">4302</TD><TD>        itsAttr2 = attr2;</TD></TR><TR CLASS="z"><TD CLASS="l">4303</TD><TD>        itsAttr3 = attr3;</TD></TR><TR CLASS="z"><TD CLASS="l">4304</TD><TD>        itsIndex = index;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4d">4305</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4306</TD><TD> </TD></TR><TR><TD CLASS="l">4307</TD><TD>    int write(byte[] data, int offset)</TD></TR><TR><TD CLASS="l">4308</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4309</TD><TD>        offset = ClassFileWriter.putInt16(itsFlags, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4310</TD><TD>        offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4311</TD><TD>        offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4312</TD><TD>        if (!itsHasAttributes) {</TD></TR><TR><TD CLASS="l">4313</TD><TD>            // write 0 attributes</TD></TR><TR CLASS="c"><TD CLASS="l">4314</TD><TD>            offset = ClassFileWriter.putInt16(0, data, offset);</TD></TR><TR><TD CLASS="l">4315</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">4316</TD><TD>            offset = ClassFileWriter.putInt16(1, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">4317</TD><TD>            offset = ClassFileWriter.putInt16(itsAttr1, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">4318</TD><TD>            offset = ClassFileWriter.putInt16(itsAttr2, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">4319</TD><TD>            offset = ClassFileWriter.putInt16(itsAttr3, data, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">4320</TD><TD>            offset = ClassFileWriter.putInt16(itsIndex, data, offset);</TD></TR><TR><TD CLASS="l">4321</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4322</TD><TD>        return offset;</TD></TR><TR><TD CLASS="l"><A NAME="4e">4323</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4324</TD><TD> </TD></TR><TR><TD CLASS="l">4325</TD><TD>    int getWriteSize()</TD></TR><TR><TD CLASS="l">4326</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4327</TD><TD>        int size = 2 * 3;</TD></TR><TR CLASS="c"><TD CLASS="l">4328</TD><TD>        if (!itsHasAttributes) {</TD></TR><TR CLASS="c"><TD CLASS="l">4329</TD><TD>            size += 2;</TD></TR><TR><TD CLASS="l">4330</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">4331</TD><TD>            size += 2 + 2 * 4;</TD></TR><TR><TD CLASS="l">4332</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4333</TD><TD>        return size;</TD></TR><TR><TD CLASS="l">4334</TD><TD>    }</TD></TR><TR><TD CLASS="l">4335</TD><TD> </TD></TR><TR><TD CLASS="l">4336</TD><TD>    private short itsNameIndex;</TD></TR><TR><TD CLASS="l">4337</TD><TD>    private short itsTypeIndex;</TD></TR><TR><TD CLASS="l">4338</TD><TD>    private short itsFlags;</TD></TR><TR><TD CLASS="l">4339</TD><TD>    private boolean itsHasAttributes;</TD></TR><TR><TD CLASS="l">4340</TD><TD>    private short itsAttr1, itsAttr2, itsAttr3;</TD></TR><TR><TD CLASS="l">4341</TD><TD>    private int itsIndex;</TD></TR><TR><TD CLASS="l">4342</TD><TD>}</TD></TR><TR><TD CLASS="l">4343</TD><TD> </TD></TR><TR><TD CLASS="l">4344</TD><TD>final class ClassFileMethod</TD></TR><TR><TD CLASS="l"><A NAME="d0">4345</A></TD><TD>{</TD></TR><TR><TD CLASS="l">4346</TD><TD> </TD></TR><TR><TD CLASS="l">4347</TD><TD>    ClassFileMethod(String name, short nameIndex, String type, short typeIndex,</TD></TR><TR><TD CLASS="l">4348</TD><TD>                    short flags)</TD></TR><TR CLASS="c"><TD CLASS="l">4349</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4350</TD><TD>        itsName = name;</TD></TR><TR CLASS="c"><TD CLASS="l">4351</TD><TD>        itsNameIndex = nameIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4352</TD><TD>        itsType = type;</TD></TR><TR CLASS="c"><TD CLASS="l">4353</TD><TD>        itsTypeIndex = typeIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4354</TD><TD>        itsFlags = flags;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="d6">4355</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4356</TD><TD> </TD></TR><TR><TD CLASS="l">4357</TD><TD>    void setCodeAttribute(byte codeAttribute[])</TD></TR><TR><TD CLASS="l">4358</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4359</TD><TD>        itsCodeAttribute = codeAttribute;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="d7">4360</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4361</TD><TD> </TD></TR><TR><TD CLASS="l">4362</TD><TD>    int write(byte[] data, int offset)</TD></TR><TR><TD CLASS="l">4363</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4364</TD><TD>        offset = ClassFileWriter.putInt16(itsFlags, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4365</TD><TD>        offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4366</TD><TD>        offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);</TD></TR><TR><TD CLASS="l">4367</TD><TD>        // Code attribute only</TD></TR><TR CLASS="c"><TD CLASS="l">4368</TD><TD>        offset = ClassFileWriter.putInt16(1, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4369</TD><TD>        System.arraycopy(itsCodeAttribute, 0, data, offset,</TD></TR><TR><TD CLASS="l">4370</TD><TD>                         itsCodeAttribute.length);</TD></TR><TR CLASS="c"><TD CLASS="l">4371</TD><TD>        offset += itsCodeAttribute.length;</TD></TR><TR CLASS="c"><TD CLASS="l">4372</TD><TD>        return offset;</TD></TR><TR><TD CLASS="l"><A NAME="d5">4373</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4374</TD><TD> </TD></TR><TR><TD CLASS="l">4375</TD><TD>    int getWriteSize()</TD></TR><TR><TD CLASS="l">4376</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4377</TD><TD>        return 2 * 4 + itsCodeAttribute.length;</TD></TR><TR><TD CLASS="l"><A NAME="d2">4378</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4379</TD><TD> </TD></TR><TR><TD CLASS="l">4380</TD><TD>    String getName()</TD></TR><TR><TD CLASS="l">4381</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4382</TD><TD>        return itsName;</TD></TR><TR><TD CLASS="l"><A NAME="d3">4383</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4384</TD><TD> </TD></TR><TR><TD CLASS="l">4385</TD><TD>    String getType()</TD></TR><TR><TD CLASS="l">4386</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4387</TD><TD>        return itsType;</TD></TR><TR><TD CLASS="l"><A NAME="d1">4388</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4389</TD><TD> </TD></TR><TR><TD CLASS="l">4390</TD><TD>    short getFlags()</TD></TR><TR><TD CLASS="l">4391</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4392</TD><TD>        return itsFlags;</TD></TR><TR><TD CLASS="l">4393</TD><TD>    }</TD></TR><TR><TD CLASS="l">4394</TD><TD> </TD></TR><TR><TD CLASS="l">4395</TD><TD>    private String itsName;</TD></TR><TR><TD CLASS="l">4396</TD><TD>    private String itsType;</TD></TR><TR><TD CLASS="l">4397</TD><TD>    private short itsNameIndex;</TD></TR><TR><TD CLASS="l">4398</TD><TD>    private short itsTypeIndex;</TD></TR><TR><TD CLASS="l">4399</TD><TD>    private short itsFlags;</TD></TR><TR><TD CLASS="l">4400</TD><TD>    private byte[] itsCodeAttribute;</TD></TR><TR><TD CLASS="l">4401</TD><TD> </TD></TR><TR><TD CLASS="l">4402</TD><TD>}</TD></TR><TR><TD CLASS="l">4403</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="bb">4404</A></TD><TD>final class ConstantPool</TD></TR><TR><TD CLASS="l">4405</TD><TD>{</TD></TR><TR><TD CLASS="l">4406</TD><TD> </TD></TR><TR><TD CLASS="l">4407</TD><TD>    ConstantPool(ClassFileWriter cfw)</TD></TR><TR CLASS="c"><TD CLASS="l">4408</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4409</TD><TD>        this.cfw = cfw;</TD></TR><TR CLASS="c"><TD CLASS="l">4410</TD><TD>        itsTopIndex = 1;       // the zero'th entry is reserved</TD></TR><TR CLASS="c"><TD CLASS="l">4411</TD><TD>        itsPool = new byte[ConstantPoolSize];</TD></TR><TR CLASS="c"><TD CLASS="l">4412</TD><TD>        itsTop = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">4413</TD><TD>    }</TD></TR><TR><TD CLASS="l">4414</TD><TD> </TD></TR><TR><TD CLASS="l">4415</TD><TD>    private static final int ConstantPoolSize = 256;</TD></TR><TR><TD CLASS="l">4416</TD><TD>    static final byte</TD></TR><TR><TD CLASS="l">4417</TD><TD>        CONSTANT_Class = 7,</TD></TR><TR><TD CLASS="l">4418</TD><TD>        CONSTANT_Fieldref = 9,</TD></TR><TR><TD CLASS="l">4419</TD><TD>        CONSTANT_Methodref = 10,</TD></TR><TR><TD CLASS="l">4420</TD><TD>        CONSTANT_InterfaceMethodref = 11,</TD></TR><TR><TD CLASS="l">4421</TD><TD>        CONSTANT_String = 8,</TD></TR><TR><TD CLASS="l">4422</TD><TD>        CONSTANT_Integer = 3,</TD></TR><TR><TD CLASS="l">4423</TD><TD>        CONSTANT_Float = 4,</TD></TR><TR><TD CLASS="l">4424</TD><TD>        CONSTANT_Long = 5,</TD></TR><TR><TD CLASS="l">4425</TD><TD>        CONSTANT_Double = 6,</TD></TR><TR><TD CLASS="l">4426</TD><TD>        CONSTANT_NameAndType = 12,</TD></TR><TR><TD CLASS="l"><A NAME="cf">4427</A></TD><TD>        CONSTANT_Utf8 = 1;</TD></TR><TR><TD CLASS="l">4428</TD><TD> </TD></TR><TR><TD CLASS="l">4429</TD><TD>    int write(byte[] data, int offset)</TD></TR><TR><TD CLASS="l">4430</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4431</TD><TD>        offset = ClassFileWriter.putInt16((short)itsTopIndex, data, offset);</TD></TR><TR CLASS="c"><TD CLASS="l">4432</TD><TD>        System.arraycopy(itsPool, 0, data, offset, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4433</TD><TD>        offset += itsTop;</TD></TR><TR CLASS="c"><TD CLASS="l">4434</TD><TD>        return offset;</TD></TR><TR><TD CLASS="l"><A NAME="cd">4435</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4436</TD><TD> </TD></TR><TR><TD CLASS="l">4437</TD><TD>    int getWriteSize()</TD></TR><TR><TD CLASS="l">4438</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4439</TD><TD>        return 2 + itsTop;</TD></TR><TR><TD CLASS="l"><A NAME="c6">4440</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4441</TD><TD> </TD></TR><TR><TD CLASS="l">4442</TD><TD>    int addConstant(int k)</TD></TR><TR><TD CLASS="l">4443</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4444</TD><TD>        ensure(5);</TD></TR><TR CLASS="c"><TD CLASS="l">4445</TD><TD>        itsPool[itsTop++] = CONSTANT_Integer;</TD></TR><TR CLASS="c"><TD CLASS="l">4446</TD><TD>        itsTop = ClassFileWriter.putInt32(k, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4447</TD><TD>        itsPoolTypes.put(itsTopIndex, CONSTANT_Integer);</TD></TR><TR CLASS="c"><TD CLASS="l">4448</TD><TD>        return (short)(itsTopIndex++);</TD></TR><TR><TD CLASS="l"><A NAME="bd">4449</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4450</TD><TD> </TD></TR><TR><TD CLASS="l">4451</TD><TD>    int addConstant(long k)</TD></TR><TR><TD CLASS="l">4452</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4453</TD><TD>        ensure(9);</TD></TR><TR CLASS="z"><TD CLASS="l">4454</TD><TD>        itsPool[itsTop++] = CONSTANT_Long;</TD></TR><TR CLASS="z"><TD CLASS="l">4455</TD><TD>        itsTop = ClassFileWriter.putInt64(k, itsPool, itsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4456</TD><TD>        int index = itsTopIndex;</TD></TR><TR CLASS="z"><TD CLASS="l">4457</TD><TD>        itsTopIndex += 2;</TD></TR><TR CLASS="z"><TD CLASS="l">4458</TD><TD>        itsPoolTypes.put(index, CONSTANT_Long);</TD></TR><TR CLASS="z"><TD CLASS="l">4459</TD><TD>        return index;</TD></TR><TR><TD CLASS="l"><A NAME="bc">4460</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4461</TD><TD> </TD></TR><TR><TD CLASS="l">4462</TD><TD>    int addConstant(float k)</TD></TR><TR><TD CLASS="l">4463</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4464</TD><TD>        ensure(5);</TD></TR><TR CLASS="z"><TD CLASS="l">4465</TD><TD>        itsPool[itsTop++] = CONSTANT_Float;</TD></TR><TR CLASS="z"><TD CLASS="l">4466</TD><TD>        int bits = Float.floatToIntBits(k);</TD></TR><TR CLASS="z"><TD CLASS="l">4467</TD><TD>        itsTop = ClassFileWriter.putInt32(bits, itsPool, itsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4468</TD><TD>        itsPoolTypes.put(itsTopIndex, CONSTANT_Float);</TD></TR><TR CLASS="z"><TD CLASS="l">4469</TD><TD>        return itsTopIndex++;</TD></TR><TR><TD CLASS="l"><A NAME="c5">4470</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4471</TD><TD> </TD></TR><TR><TD CLASS="l">4472</TD><TD>    int addConstant(double k)</TD></TR><TR><TD CLASS="l">4473</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4474</TD><TD>        ensure(9);</TD></TR><TR CLASS="c"><TD CLASS="l">4475</TD><TD>        itsPool[itsTop++] = CONSTANT_Double;</TD></TR><TR CLASS="c"><TD CLASS="l">4476</TD><TD>        long bits = Double.doubleToLongBits(k);</TD></TR><TR CLASS="c"><TD CLASS="l">4477</TD><TD>        itsTop = ClassFileWriter.putInt64(bits, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4478</TD><TD>        int index = itsTopIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4479</TD><TD>        itsTopIndex += 2;</TD></TR><TR CLASS="c"><TD CLASS="l">4480</TD><TD>        itsPoolTypes.put(index, CONSTANT_Double);</TD></TR><TR CLASS="c"><TD CLASS="l">4481</TD><TD>        return index;</TD></TR><TR><TD CLASS="l"><A NAME="c4">4482</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4483</TD><TD> </TD></TR><TR><TD CLASS="l">4484</TD><TD>    int addConstant(String k)</TD></TR><TR><TD CLASS="l">4485</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4486</TD><TD>        int utf8Index = 0xFFFF &amp; addUtf8(k);</TD></TR><TR CLASS="c"><TD CLASS="l">4487</TD><TD>        int theIndex = itsStringConstHash.getInt(utf8Index, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4488</TD><TD>        if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4489</TD><TD>            theIndex = itsTopIndex++;</TD></TR><TR CLASS="c"><TD CLASS="l">4490</TD><TD>            ensure(3);</TD></TR><TR CLASS="c"><TD CLASS="l">4491</TD><TD>            itsPool[itsTop++] = CONSTANT_String;</TD></TR><TR CLASS="c"><TD CLASS="l">4492</TD><TD>            itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4493</TD><TD>            itsStringConstHash.put(utf8Index, theIndex);</TD></TR><TR><TD CLASS="l">4494</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4495</TD><TD>        itsPoolTypes.put(theIndex, CONSTANT_String);</TD></TR><TR CLASS="c"><TD CLASS="l">4496</TD><TD>        return theIndex;</TD></TR><TR><TD CLASS="l"><A NAME="c0">4497</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4498</TD><TD> </TD></TR><TR><TD CLASS="l">4499</TD><TD>    boolean isUnderUtfEncodingLimit(String s)</TD></TR><TR><TD CLASS="l">4500</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4501</TD><TD>        int strLen = s.length();</TD></TR><TR CLASS="z"><TD CLASS="l">4502</TD><TD>        if (strLen * 3 &lt;= MAX_UTF_ENCODING_SIZE) {</TD></TR><TR CLASS="z"><TD CLASS="l">4503</TD><TD>            return true;</TD></TR><TR CLASS="z"><TD CLASS="l">4504</TD><TD>        } else if (strLen &gt; MAX_UTF_ENCODING_SIZE) {</TD></TR><TR CLASS="z"><TD CLASS="l">4505</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">4506</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4507</TD><TD>        return strLen == getUtfEncodingLimit(s, 0, strLen);</TD></TR><TR><TD CLASS="l">4508</TD><TD>    }</TD></TR><TR><TD CLASS="l">4509</TD><TD> </TD></TR><TR><TD CLASS="l">4510</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4511</TD><TD>     * Get maximum i such that &lt;tt&gt;start &lt;= i &lt;= end&lt;/tt&gt; and</TD></TR><TR><TD CLASS="l"><A NAME="cc">4512</A></TD><TD>     * &lt;tt&gt;s.substring(start, i)&lt;/tt&gt; fits JVM UTF string encoding limit.</TD></TR><TR><TD CLASS="l">4513</TD><TD>     */</TD></TR><TR><TD CLASS="l">4514</TD><TD>    int getUtfEncodingLimit(String s, int start, int end)</TD></TR><TR><TD CLASS="l">4515</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4516</TD><TD>        if ((end - start) * 3 &lt;= MAX_UTF_ENCODING_SIZE) {</TD></TR><TR CLASS="c"><TD CLASS="l">4517</TD><TD>            return end;</TD></TR><TR><TD CLASS="l">4518</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4519</TD><TD>        int limit = MAX_UTF_ENCODING_SIZE;</TD></TR><TR CLASS="c"><TD CLASS="l">4520</TD><TD>        for (int i = start; i != end; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">4521</TD><TD>            int c = s.charAt(i);</TD></TR><TR CLASS="c"><TD CLASS="l">4522</TD><TD>            if (0 != c &amp;&amp; c &lt;= 0x7F) {</TD></TR><TR CLASS="c"><TD CLASS="l">4523</TD><TD>                --limit;</TD></TR><TR CLASS="c"><TD CLASS="l">4524</TD><TD>            } else if (c &lt; 0x7FF) {</TD></TR><TR CLASS="c"><TD CLASS="l">4525</TD><TD>                limit -= 2;</TD></TR><TR><TD CLASS="l">4526</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">4527</TD><TD>                limit -= 3;</TD></TR><TR><TD CLASS="l">4528</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4529</TD><TD>            if (limit &lt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">4530</TD><TD>                return i;</TD></TR><TR><TD CLASS="l">4531</TD><TD>            }</TD></TR><TR><TD CLASS="l">4532</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4533</TD><TD>        return end;</TD></TR><TR><TD CLASS="l"><A NAME="c1">4534</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4535</TD><TD> </TD></TR><TR><TD CLASS="l">4536</TD><TD>    short addUtf8(String k)</TD></TR><TR><TD CLASS="l">4537</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4538</TD><TD>        int theIndex = itsUtf8Hash.get(k, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4539</TD><TD>        if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4540</TD><TD>            int strLen = k.length();</TD></TR><TR><TD CLASS="l">4541</TD><TD>            boolean tooBigString;</TD></TR><TR CLASS="c"><TD CLASS="l">4542</TD><TD>            if (strLen &gt; MAX_UTF_ENCODING_SIZE) {</TD></TR><TR CLASS="z"><TD CLASS="l">4543</TD><TD>                tooBigString = true;</TD></TR><TR><TD CLASS="l">4544</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">4545</TD><TD>                tooBigString = false;</TD></TR><TR><TD CLASS="l">4546</TD><TD>                // Ask for worst case scenario buffer when each char takes 3</TD></TR><TR><TD CLASS="l">4547</TD><TD>                // bytes</TD></TR><TR CLASS="c"><TD CLASS="l">4548</TD><TD>                ensure(1 + 2 + strLen * 3);</TD></TR><TR CLASS="c"><TD CLASS="l">4549</TD><TD>                int top = itsTop;</TD></TR><TR><TD CLASS="l">4550</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4551</TD><TD>                itsPool[top++] = CONSTANT_Utf8;</TD></TR><TR CLASS="c"><TD CLASS="l">4552</TD><TD>                top += 2; // skip length</TD></TR><TR><TD CLASS="l">4553</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4554</TD><TD>                char[] chars = cfw.getCharBuffer(strLen);</TD></TR><TR CLASS="c"><TD CLASS="l">4555</TD><TD>                k.getChars(0, strLen, chars, 0);</TD></TR><TR><TD CLASS="l">4556</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4557</TD><TD>                for (int i = 0; i != strLen; i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">4558</TD><TD>                    int c = chars[i];</TD></TR><TR CLASS="c"><TD CLASS="l">4559</TD><TD>                    if (c != 0 &amp;&amp; c &lt;= 0x7F) {</TD></TR><TR CLASS="c"><TD CLASS="l">4560</TD><TD>                        itsPool[top++] = (byte)c;</TD></TR><TR CLASS="c"><TD CLASS="l">4561</TD><TD>                    } else if (c &gt; 0x7FF) {</TD></TR><TR CLASS="c"><TD CLASS="l">4562</TD><TD>                        itsPool[top++] = (byte)(0xE0 | (c &gt;&gt; 12));</TD></TR><TR CLASS="c"><TD CLASS="l">4563</TD><TD>                        itsPool[top++] = (byte)(0x80 | ((c &gt;&gt; 6) &amp; 0x3F));</TD></TR><TR CLASS="c"><TD CLASS="l">4564</TD><TD>                        itsPool[top++] = (byte)(0x80 | (c &amp; 0x3F));</TD></TR><TR><TD CLASS="l">4565</TD><TD>                    } else {</TD></TR><TR CLASS="c"><TD CLASS="l">4566</TD><TD>                        itsPool[top++] = (byte)(0xC0 | (c &gt;&gt; 6));</TD></TR><TR CLASS="c"><TD CLASS="l">4567</TD><TD>                        itsPool[top++] = (byte)(0x80 | (c &amp; 0x3F));</TD></TR><TR><TD CLASS="l">4568</TD><TD>                    }</TD></TR><TR><TD CLASS="l">4569</TD><TD>                }</TD></TR><TR><TD CLASS="l">4570</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4571</TD><TD>                int utfLen = top - (itsTop + 1 + 2);</TD></TR><TR CLASS="c"><TD CLASS="l">4572</TD><TD>                if (utfLen &gt; MAX_UTF_ENCODING_SIZE) {</TD></TR><TR CLASS="z"><TD CLASS="l">4573</TD><TD>                    tooBigString = true;</TD></TR><TR><TD CLASS="l">4574</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">4575</TD><TD>                    // Write back length</TD></TR><TR CLASS="c"><TD CLASS="l">4576</TD><TD>                    itsPool[itsTop + 1] = (byte)(utfLen &gt;&gt;&gt; 8);</TD></TR><TR CLASS="c"><TD CLASS="l">4577</TD><TD>                    itsPool[itsTop + 2] = (byte)utfLen;</TD></TR><TR><TD CLASS="l">4578</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4579</TD><TD>                    itsTop = top;</TD></TR><TR CLASS="c"><TD CLASS="l">4580</TD><TD>                    theIndex = itsTopIndex++;</TD></TR><TR CLASS="c"><TD CLASS="l">4581</TD><TD>                    itsUtf8Hash.put(k, theIndex);</TD></TR><TR><TD CLASS="l">4582</TD><TD>                }</TD></TR><TR><TD CLASS="l">4583</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4584</TD><TD>            if (tooBigString) {</TD></TR><TR CLASS="z"><TD CLASS="l">4585</TD><TD>                throw new IllegalArgumentException(&#34;Too big string&#34;);</TD></TR><TR><TD CLASS="l">4586</TD><TD>            }</TD></TR><TR><TD CLASS="l">4587</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4588</TD><TD>        setConstantData(theIndex, k);</TD></TR><TR CLASS="c"><TD CLASS="l">4589</TD><TD>        itsPoolTypes.put(theIndex, CONSTANT_Utf8);</TD></TR><TR CLASS="c"><TD CLASS="l">4590</TD><TD>        return (short)theIndex;</TD></TR><TR><TD CLASS="l"><A NAME="ca">4591</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4592</TD><TD> </TD></TR><TR><TD CLASS="l">4593</TD><TD>    private short addNameAndType(String name, String type)</TD></TR><TR><TD CLASS="l">4594</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4595</TD><TD>        short nameIndex = addUtf8(name);</TD></TR><TR CLASS="c"><TD CLASS="l">4596</TD><TD>        short typeIndex = addUtf8(type);</TD></TR><TR CLASS="c"><TD CLASS="l">4597</TD><TD>        ensure(5);</TD></TR><TR CLASS="c"><TD CLASS="l">4598</TD><TD>        itsPool[itsTop++] = CONSTANT_NameAndType;</TD></TR><TR CLASS="c"><TD CLASS="l">4599</TD><TD>        itsTop = ClassFileWriter.putInt16(nameIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4600</TD><TD>        itsTop = ClassFileWriter.putInt16(typeIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4601</TD><TD>        itsPoolTypes.put(itsTopIndex, CONSTANT_NameAndType);</TD></TR><TR CLASS="c"><TD CLASS="l">4602</TD><TD>        return (short)(itsTopIndex++);</TD></TR><TR><TD CLASS="l"><A NAME="c3">4603</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4604</TD><TD> </TD></TR><TR><TD CLASS="l">4605</TD><TD>    short addClass(String className)</TD></TR><TR><TD CLASS="l">4606</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4607</TD><TD>        int theIndex = itsClassHash.get(className, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4608</TD><TD>        if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4609</TD><TD>            String slashed = className;</TD></TR><TR CLASS="c"><TD CLASS="l">4610</TD><TD>            if (className.indexOf('.') &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">4611</TD><TD>                slashed = ClassFileWriter.getSlashedForm(className);</TD></TR><TR CLASS="c"><TD CLASS="l">4612</TD><TD>                theIndex = itsClassHash.get(slashed, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4613</TD><TD>                if (theIndex != -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4614</TD><TD>                    itsClassHash.put(className, theIndex);</TD></TR><TR><TD CLASS="l">4615</TD><TD>                }</TD></TR><TR><TD CLASS="l">4616</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4617</TD><TD>            if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4618</TD><TD>                int utf8Index = addUtf8(slashed);</TD></TR><TR CLASS="c"><TD CLASS="l">4619</TD><TD>                ensure(3);</TD></TR><TR CLASS="c"><TD CLASS="l">4620</TD><TD>                itsPool[itsTop++] = CONSTANT_Class;</TD></TR><TR CLASS="c"><TD CLASS="l">4621</TD><TD>                itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4622</TD><TD>                theIndex = itsTopIndex++;</TD></TR><TR CLASS="c"><TD CLASS="l">4623</TD><TD>                itsClassHash.put(slashed, theIndex);</TD></TR><TR CLASS="c"><TD CLASS="l">4624</TD><TD>                if (className != slashed) {</TD></TR><TR CLASS="c"><TD CLASS="l">4625</TD><TD>                    itsClassHash.put(className, theIndex);</TD></TR><TR><TD CLASS="l">4626</TD><TD>                }</TD></TR><TR><TD CLASS="l">4627</TD><TD>            }</TD></TR><TR><TD CLASS="l">4628</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4629</TD><TD>        setConstantData(theIndex, className);</TD></TR><TR CLASS="c"><TD CLASS="l">4630</TD><TD>        itsPoolTypes.put(theIndex, CONSTANT_Class);</TD></TR><TR CLASS="c"><TD CLASS="l">4631</TD><TD>        return (short)theIndex;</TD></TR><TR><TD CLASS="l"><A NAME="c7">4632</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4633</TD><TD> </TD></TR><TR><TD CLASS="l">4634</TD><TD>    short addFieldRef(String className, String fieldName, String fieldType)</TD></TR><TR><TD CLASS="l">4635</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4636</TD><TD>        FieldOrMethodRef ref = new FieldOrMethodRef(className, fieldName,</TD></TR><TR><TD CLASS="l">4637</TD><TD>                                                    fieldType);</TD></TR><TR><TD CLASS="l">4638</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4639</TD><TD>        int theIndex = itsFieldRefHash.get(ref, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4640</TD><TD>        if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4641</TD><TD>            short ntIndex = addNameAndType(fieldName, fieldType);</TD></TR><TR CLASS="c"><TD CLASS="l">4642</TD><TD>            short classIndex = addClass(className);</TD></TR><TR CLASS="c"><TD CLASS="l">4643</TD><TD>            ensure(5);</TD></TR><TR CLASS="c"><TD CLASS="l">4644</TD><TD>            itsPool[itsTop++] = CONSTANT_Fieldref;</TD></TR><TR CLASS="c"><TD CLASS="l">4645</TD><TD>            itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4646</TD><TD>            itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4647</TD><TD>            theIndex = itsTopIndex++;</TD></TR><TR CLASS="c"><TD CLASS="l">4648</TD><TD>            itsFieldRefHash.put(ref, theIndex);</TD></TR><TR><TD CLASS="l">4649</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4650</TD><TD>        setConstantData(theIndex, ref);</TD></TR><TR CLASS="c"><TD CLASS="l">4651</TD><TD>        itsPoolTypes.put(theIndex, CONSTANT_Fieldref);</TD></TR><TR CLASS="c"><TD CLASS="l">4652</TD><TD>        return (short)theIndex;</TD></TR><TR><TD CLASS="l">4653</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="c9">4654</A></TD><TD> </TD></TR><TR><TD CLASS="l">4655</TD><TD>    short addMethodRef(String className, String methodName,</TD></TR><TR><TD CLASS="l">4656</TD><TD>                       String methodType)</TD></TR><TR><TD CLASS="l">4657</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4658</TD><TD>        FieldOrMethodRef ref = new FieldOrMethodRef(className, methodName,</TD></TR><TR><TD CLASS="l">4659</TD><TD>                                                    methodType);</TD></TR><TR><TD CLASS="l">4660</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4661</TD><TD>        int theIndex = itsMethodRefHash.get(ref, -1);</TD></TR><TR CLASS="c"><TD CLASS="l">4662</TD><TD>        if (theIndex == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4663</TD><TD>            short ntIndex = addNameAndType(methodName, methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">4664</TD><TD>            short classIndex = addClass(className);</TD></TR><TR CLASS="c"><TD CLASS="l">4665</TD><TD>            ensure(5);</TD></TR><TR CLASS="c"><TD CLASS="l">4666</TD><TD>            itsPool[itsTop++] = CONSTANT_Methodref;</TD></TR><TR CLASS="c"><TD CLASS="l">4667</TD><TD>            itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4668</TD><TD>            itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4669</TD><TD>            theIndex = itsTopIndex++;</TD></TR><TR CLASS="c"><TD CLASS="l">4670</TD><TD>            itsMethodRefHash.put(ref, theIndex);</TD></TR><TR><TD CLASS="l">4671</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4672</TD><TD>        setConstantData(theIndex, ref);</TD></TR><TR CLASS="c"><TD CLASS="l">4673</TD><TD>        itsPoolTypes.put(theIndex, CONSTANT_Methodref);</TD></TR><TR CLASS="c"><TD CLASS="l">4674</TD><TD>        return (short)theIndex;</TD></TR><TR><TD CLASS="l">4675</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="c8">4676</A></TD><TD> </TD></TR><TR><TD CLASS="l">4677</TD><TD>    short addInterfaceMethodRef(String className,</TD></TR><TR><TD CLASS="l">4678</TD><TD>                                String methodName, String methodType)</TD></TR><TR><TD CLASS="l">4679</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4680</TD><TD>        short ntIndex = addNameAndType(methodName, methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">4681</TD><TD>        short classIndex = addClass(className);</TD></TR><TR CLASS="c"><TD CLASS="l">4682</TD><TD>        ensure(5);</TD></TR><TR CLASS="c"><TD CLASS="l">4683</TD><TD>        itsPool[itsTop++] = CONSTANT_InterfaceMethodref;</TD></TR><TR CLASS="c"><TD CLASS="l">4684</TD><TD>        itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4685</TD><TD>        itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4686</TD><TD>        FieldOrMethodRef r = new FieldOrMethodRef(className, methodName,</TD></TR><TR><TD CLASS="l">4687</TD><TD>                                                  methodType);</TD></TR><TR CLASS="c"><TD CLASS="l">4688</TD><TD>        setConstantData(itsTopIndex, r);</TD></TR><TR CLASS="c"><TD CLASS="l">4689</TD><TD>        itsPoolTypes.put(itsTopIndex, CONSTANT_InterfaceMethodref);</TD></TR><TR CLASS="c"><TD CLASS="l">4690</TD><TD>        return (short)(itsTopIndex++);</TD></TR><TR><TD CLASS="l"><A NAME="be">4691</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4692</TD><TD> </TD></TR><TR><TD CLASS="l">4693</TD><TD>    Object getConstantData(int index)</TD></TR><TR><TD CLASS="l">4694</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4695</TD><TD>        return itsConstantData.getObject(index);</TD></TR><TR><TD CLASS="l"><A NAME="ce">4696</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4697</TD><TD> </TD></TR><TR><TD CLASS="l">4698</TD><TD>    void setConstantData(int index, Object data)</TD></TR><TR><TD CLASS="l">4699</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4700</TD><TD>        itsConstantData.put(index, data);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="bf">4701</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4702</TD><TD> </TD></TR><TR><TD CLASS="l">4703</TD><TD>    byte getConstantType(int index)</TD></TR><TR><TD CLASS="l">4704</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4705</TD><TD>        return (byte) itsPoolTypes.getInt(index, 0);</TD></TR><TR><TD CLASS="l"><A NAME="cb">4706</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4707</TD><TD> </TD></TR><TR><TD CLASS="l">4708</TD><TD>    void ensure(int howMuch)</TD></TR><TR><TD CLASS="l">4709</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4710</TD><TD>        if (itsTop + howMuch &gt; itsPool.length) {</TD></TR><TR CLASS="c"><TD CLASS="l">4711</TD><TD>            int newCapacity = itsPool.length * 2;</TD></TR><TR CLASS="c"><TD CLASS="l">4712</TD><TD>            if (itsTop + howMuch &gt; newCapacity) {</TD></TR><TR CLASS="c"><TD CLASS="l">4713</TD><TD>                newCapacity = itsTop + howMuch;</TD></TR><TR><TD CLASS="l">4714</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">4715</TD><TD>            byte[] tmp = new byte[newCapacity];</TD></TR><TR CLASS="c"><TD CLASS="l">4716</TD><TD>            System.arraycopy(itsPool, 0, tmp, 0, itsTop);</TD></TR><TR CLASS="c"><TD CLASS="l">4717</TD><TD>            itsPool = tmp;</TD></TR><TR><TD CLASS="l">4718</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4719</TD><TD>    }</TD></TR><TR><TD CLASS="l">4720</TD><TD> </TD></TR><TR><TD CLASS="l">4721</TD><TD>    private ClassFileWriter cfw;</TD></TR><TR><TD CLASS="l">4722</TD><TD> </TD></TR><TR><TD CLASS="l">4723</TD><TD>    private static final int MAX_UTF_ENCODING_SIZE = 65535;</TD></TR><TR><TD CLASS="l">4724</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">4725</TD><TD>    private UintMap itsStringConstHash = new UintMap();</TD></TR><TR CLASS="c"><TD CLASS="l">4726</TD><TD>    private ObjToIntMap itsUtf8Hash = new ObjToIntMap();</TD></TR><TR CLASS="c"><TD CLASS="l">4727</TD><TD>    private ObjToIntMap itsFieldRefHash = new ObjToIntMap();</TD></TR><TR CLASS="c"><TD CLASS="l">4728</TD><TD>    private ObjToIntMap itsMethodRefHash = new ObjToIntMap();</TD></TR><TR CLASS="c"><TD CLASS="l">4729</TD><TD>    private ObjToIntMap itsClassHash = new ObjToIntMap();</TD></TR><TR><TD CLASS="l">4730</TD><TD> </TD></TR><TR><TD CLASS="l">4731</TD><TD>    private int itsTop;</TD></TR><TR><TD CLASS="l">4732</TD><TD>    private int itsTopIndex;</TD></TR><TR CLASS="c"><TD CLASS="l">4733</TD><TD>    private UintMap itsConstantData = new UintMap();</TD></TR><TR CLASS="c"><TD CLASS="l">4734</TD><TD>    private UintMap itsPoolTypes = new UintMap();</TD></TR><TR><TD CLASS="l">4735</TD><TD>    private byte itsPool[];</TD></TR><TR><TD CLASS="l">4736</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="b4">4737</A></TD><TD> </TD></TR><TR><TD CLASS="l">4738</TD><TD>final class FieldOrMethodRef</TD></TR><TR><TD CLASS="l">4739</TD><TD>{</TD></TR><TR><TD CLASS="l">4740</TD><TD>    FieldOrMethodRef(String className, String name, String type)</TD></TR><TR CLASS="c"><TD CLASS="l">4741</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4742</TD><TD>        this.className = className;</TD></TR><TR CLASS="c"><TD CLASS="l">4743</TD><TD>        this.name = name;</TD></TR><TR CLASS="c"><TD CLASS="l">4744</TD><TD>        this.type = type;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="b5">4745</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4746</TD><TD> </TD></TR><TR><TD CLASS="l">4747</TD><TD>    public String getClassName()</TD></TR><TR><TD CLASS="l">4748</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4749</TD><TD>        return className;</TD></TR><TR><TD CLASS="l"><A NAME="b6">4750</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4751</TD><TD> </TD></TR><TR><TD CLASS="l">4752</TD><TD>    public String getName()</TD></TR><TR><TD CLASS="l">4753</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4754</TD><TD>        return name;</TD></TR><TR><TD CLASS="l"><A NAME="b7">4755</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4756</TD><TD> </TD></TR><TR><TD CLASS="l">4757</TD><TD>    public String getType()</TD></TR><TR><TD CLASS="l">4758</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">4759</TD><TD>        return type;</TD></TR><TR><TD CLASS="l">4760</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="b8">4761</A></TD><TD> </TD></TR><TR><TD CLASS="l">4762</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">4763</TD><TD>    public boolean equals(Object obj)</TD></TR><TR><TD CLASS="l">4764</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="60% line coverage (3 out of 5 instructions)">4765</TD><TD TITLE="60% line coverage (3 out of 5 instructions)">        if (!(obj instanceof FieldOrMethodRef)) { return false; }</TD></TR><TR CLASS="c"><TD CLASS="l">4766</TD><TD>        FieldOrMethodRef x = (FieldOrMethodRef)obj;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="96% line coverage (24 out of 25 instructions)">4767</TD><TD TITLE="96% line coverage (24 out of 25 instructions)">        return className.equals(x.className)</TD></TR><TR><TD CLASS="l">4768</TD><TD>            &amp;&amp; name.equals(x.name)</TD></TR><TR><TD CLASS="l">4769</TD><TD>            &amp;&amp; type.equals(x.type);</TD></TR><TR><TD CLASS="l">4770</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="ba">4771</A></TD><TD> </TD></TR><TR><TD CLASS="l">4772</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">4773</TD><TD>    public int hashCode()</TD></TR><TR><TD CLASS="l">4774</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">4775</TD><TD>        if (hashCode == -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">4776</TD><TD>            int h1 = className.hashCode();</TD></TR><TR CLASS="c"><TD CLASS="l">4777</TD><TD>            int h2 = name.hashCode();</TD></TR><TR CLASS="c"><TD CLASS="l">4778</TD><TD>            int h3 = type.hashCode();</TD></TR><TR CLASS="c"><TD CLASS="l">4779</TD><TD>            hashCode = h1 ^ h2 ^ h3;</TD></TR><TR><TD CLASS="l">4780</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">4781</TD><TD>        return hashCode;</TD></TR><TR><TD CLASS="l">4782</TD><TD>    }</TD></TR><TR><TD CLASS="l">4783</TD><TD> </TD></TR><TR><TD CLASS="l">4784</TD><TD>    private String className;</TD></TR><TR><TD CLASS="l">4785</TD><TD>    private String name;</TD></TR><TR><TD CLASS="l">4786</TD><TD>    private String type;</TD></TR><TR CLASS="c"><TD CLASS="l">4787</TD><TD>    private int hashCode = -1;</TD></TR><TR><TD CLASS="l">4788</TD><TD>}</TD></TR><TR><TD CLASS="l">4789</TD><TD> </TD></TR><TR><TD CLASS="l">4790</TD><TD>/**</TD></TR><TR><TD CLASS="l">4791</TD><TD> * A super block is defined as a contiguous chunk of code with a single entry</TD></TR><TR><TD CLASS="l">4792</TD><TD> * point and multiple exit points (therefore ending in an unconditional jump</TD></TR><TR><TD CLASS="l">4793</TD><TD> * or the end of the method). This is used to emulate OpenJDK's compiler, which</TD></TR><TR><TD CLASS="l"><A NAME="2b">4794</A></TD><TD> * outputs stack map frames at the start of every super block except the method</TD></TR><TR><TD CLASS="l">4795</TD><TD> * start.</TD></TR><TR><TD CLASS="l">4796</TD><TD> */</TD></TR><TR><TD CLASS="l">4797</TD><TD>final class SuperBlock {</TD></TR><TR CLASS="z"><TD CLASS="l">4798</TD><TD>    SuperBlock(int index, int start, int end, int[] initialLocals) {</TD></TR><TR CLASS="z"><TD CLASS="l">4799</TD><TD>        this.index = index;</TD></TR><TR CLASS="z"><TD CLASS="l">4800</TD><TD>        this.start = start;</TD></TR><TR CLASS="z"><TD CLASS="l">4801</TD><TD>        this.end = end;</TD></TR><TR CLASS="z"><TD CLASS="l">4802</TD><TD>        locals = new int[initialLocals.length];</TD></TR><TR CLASS="z"><TD CLASS="l">4803</TD><TD>        System.arraycopy(initialLocals, 0, locals, 0, initialLocals.length);</TD></TR><TR CLASS="z"><TD CLASS="l">4804</TD><TD>        stack = new int[0];</TD></TR><TR CLASS="z"><TD CLASS="l">4805</TD><TD>        isInitialized = false;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2e">4806</A></TD><TD>        isInQueue = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4807</TD><TD>    }</TD></TR><TR><TD CLASS="l">4808</TD><TD> </TD></TR><TR><TD CLASS="l">4809</TD><TD>    int getIndex() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2f">4810</A></TD><TD>        return index;</TD></TR><TR><TD CLASS="l">4811</TD><TD>    }</TD></TR><TR><TD CLASS="l">4812</TD><TD> </TD></TR><TR><TD CLASS="l">4813</TD><TD>    int[] getLocals() {</TD></TR><TR CLASS="z"><TD CLASS="l">4814</TD><TD>        int[] copy = new int[locals.length];</TD></TR><TR CLASS="z"><TD CLASS="l">4815</TD><TD>        System.arraycopy(locals, 0, copy, 0, locals.length);</TD></TR><TR CLASS="z"><TD CLASS="l">4816</TD><TD>        return copy;</TD></TR><TR><TD CLASS="l">4817</TD><TD>    }</TD></TR><TR><TD CLASS="l">4818</TD><TD> </TD></TR><TR><TD CLASS="l">4819</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4820</TD><TD>     * Get a copy of the super block's locals without any trailing TOP types.</TD></TR><TR><TD CLASS="l">4821</TD><TD>     *</TD></TR><TR><TD CLASS="l">4822</TD><TD>     * This is useful for actual writing stack maps; during the computation of</TD></TR><TR><TD CLASS="l">4823</TD><TD>     * stack map types, all local arrays have the same size; the max locals for</TD></TR><TR><TD CLASS="l">4824</TD><TD>     * the method. In addition, DOUBLE and LONG types have trailing TOP types</TD></TR><TR><TD CLASS="l"><A NAME="32">4825</A></TD><TD>     * because they occupy two words. For writing purposes, these are not</TD></TR><TR><TD CLASS="l">4826</TD><TD>     * useful.</TD></TR><TR><TD CLASS="l">4827</TD><TD>     */</TD></TR><TR><TD CLASS="l">4828</TD><TD>    int[] getTrimmedLocals() {</TD></TR><TR CLASS="z"><TD CLASS="l">4829</TD><TD>        int last = locals.length - 1;</TD></TR><TR><TD CLASS="l">4830</TD><TD>        // Exclude all of the trailing TOPs not bound to a DOUBLE/LONG</TD></TR><TR CLASS="z"><TD CLASS="l">4831</TD><TD>        while (last &gt;= 0 &amp;&amp; locals[last] == TypeInfo.TOP &amp;&amp;</TD></TR><TR><TD CLASS="l">4832</TD><TD>               !TypeInfo.isTwoWords(locals[last - 1])) {</TD></TR><TR CLASS="z"><TD CLASS="l">4833</TD><TD>            last--;</TD></TR><TR><TD CLASS="l">4834</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4835</TD><TD>        last++;</TD></TR><TR><TD CLASS="l">4836</TD><TD>        // Exclude trailing TOPs following a DOUBLE/LONG</TD></TR><TR CLASS="z"><TD CLASS="l">4837</TD><TD>        int size = last;</TD></TR><TR CLASS="z"><TD CLASS="l">4838</TD><TD>        for (int i = 0; i &lt; last; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4839</TD><TD>            if (TypeInfo.isTwoWords(locals[i])) {</TD></TR><TR CLASS="z"><TD CLASS="l">4840</TD><TD>                size--;</TD></TR><TR><TD CLASS="l">4841</TD><TD>            }</TD></TR><TR><TD CLASS="l">4842</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4843</TD><TD>        int[] copy = new int[size];</TD></TR><TR CLASS="z"><TD CLASS="l">4844</TD><TD>        for (int i = 0, j = 0; i &lt; size; i++, j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4845</TD><TD>            copy[i] = locals[j];</TD></TR><TR CLASS="z"><TD CLASS="l">4846</TD><TD>            if (TypeInfo.isTwoWords(locals[j])) {</TD></TR><TR CLASS="z"><TD CLASS="l">4847</TD><TD>                j++;</TD></TR><TR><TD CLASS="l">4848</TD><TD>            }</TD></TR><TR><TD CLASS="l">4849</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="30">4850</A></TD><TD>        return copy;</TD></TR><TR><TD CLASS="l">4851</TD><TD>    }</TD></TR><TR><TD CLASS="l">4852</TD><TD> </TD></TR><TR><TD CLASS="l">4853</TD><TD>    int[] getStack() {</TD></TR><TR CLASS="z"><TD CLASS="l">4854</TD><TD>        int[] copy = new int[stack.length];</TD></TR><TR CLASS="z"><TD CLASS="l">4855</TD><TD>        System.arraycopy(stack, 0, copy, 0, stack.length);</TD></TR><TR CLASS="z"><TD CLASS="l">4856</TD><TD>        return copy;</TD></TR><TR><TD CLASS="l"><A NAME="35">4857</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4858</TD><TD> </TD></TR><TR><TD CLASS="l">4859</TD><TD>    boolean merge(int[] locals, int localsTop, int[] stack, int stackTop,</TD></TR><TR><TD CLASS="l">4860</TD><TD>                  ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">4861</TD><TD>        if (!isInitialized) {</TD></TR><TR CLASS="z"><TD CLASS="l">4862</TD><TD>            System.arraycopy(locals, 0, this.locals, 0, localsTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4863</TD><TD>            this.stack = new int[stackTop];</TD></TR><TR CLASS="z"><TD CLASS="l">4864</TD><TD>            System.arraycopy(stack, 0, this.stack, 0, stackTop);</TD></TR><TR CLASS="z"><TD CLASS="l">4865</TD><TD>            isInitialized = true;</TD></TR><TR CLASS="z"><TD CLASS="l">4866</TD><TD>            return true;</TD></TR><TR CLASS="z"><TD CLASS="l">4867</TD><TD>        } else if (this.locals.length == localsTop &amp;&amp;</TD></TR><TR><TD CLASS="l">4868</TD><TD>                   this.stack.length == stackTop) {</TD></TR><TR CLASS="z"><TD CLASS="l">4869</TD><TD>            boolean localsChanged = mergeState(this.locals, locals, localsTop,</TD></TR><TR><TD CLASS="l">4870</TD><TD>                                               pool);</TD></TR><TR CLASS="z"><TD CLASS="l">4871</TD><TD>            boolean stackChanged = mergeState(this.stack, stack, stackTop,</TD></TR><TR><TD CLASS="l">4872</TD><TD>                                              pool);</TD></TR><TR CLASS="z"><TD CLASS="l">4873</TD><TD>            return localsChanged || stackChanged;</TD></TR><TR><TD CLASS="l">4874</TD><TD>        } else {</TD></TR><TR><TD CLASS="l">4875</TD><TD>            if (ClassFileWriter.StackMapTable.DEBUGSTACKMAP) {</TD></TR><TR><TD CLASS="l">4876</TD><TD>                System.out.println(&#34;bad merge&#34;);</TD></TR><TR><TD CLASS="l">4877</TD><TD>                System.out.println(&#34;current type state:&#34;);</TD></TR><TR><TD CLASS="l">4878</TD><TD>                TypeInfo.print(this.locals, this.stack, pool);</TD></TR><TR><TD CLASS="l">4879</TD><TD>                System.out.println(&#34;incoming type state:&#34;);</TD></TR><TR><TD CLASS="l">4880</TD><TD>                TypeInfo.print(locals, localsTop, stack, stackTop, pool);</TD></TR><TR><TD CLASS="l">4881</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">4882</TD><TD>            throw new IllegalArgumentException(&#34;bad merge attempt&#34;);</TD></TR><TR><TD CLASS="l">4883</TD><TD>        }</TD></TR><TR><TD CLASS="l">4884</TD><TD>    }</TD></TR><TR><TD CLASS="l">4885</TD><TD> </TD></TR><TR><TD CLASS="l">4886</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4887</TD><TD>     * Merge an operand stack or local variable array with incoming state.</TD></TR><TR><TD CLASS="l">4888</TD><TD>     *</TD></TR><TR><TD CLASS="l">4889</TD><TD>     * They are treated the same way; by this point, it should already be</TD></TR><TR><TD CLASS="l">4890</TD><TD>     * ensured that the array sizes are the same, which is the only additional</TD></TR><TR><TD CLASS="l">4891</TD><TD>     * constraint that is imposed on merging operand stacks (the local variable</TD></TR><TR><TD CLASS="l"><A NAME="36">4892</A></TD><TD>     * array is always the same size).</TD></TR><TR><TD CLASS="l">4893</TD><TD>     */</TD></TR><TR><TD CLASS="l">4894</TD><TD>    private boolean mergeState(int[] current, int[] incoming, int size,</TD></TR><TR><TD CLASS="l">4895</TD><TD>                               ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">4896</TD><TD>        boolean changed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">4897</TD><TD>        for (int i = 0; i &lt; size; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4898</TD><TD>            int currentType = current[i];</TD></TR><TR><TD CLASS="l">4899</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">4900</TD><TD>            current[i] = TypeInfo.merge(current[i], incoming[i], pool);</TD></TR><TR CLASS="z"><TD CLASS="l">4901</TD><TD>            if (currentType != current[i]) {</TD></TR><TR CLASS="z"><TD CLASS="l">4902</TD><TD>                changed = true;</TD></TR><TR><TD CLASS="l">4903</TD><TD>            }</TD></TR><TR><TD CLASS="l">4904</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="31">4905</A></TD><TD>        return changed;</TD></TR><TR><TD CLASS="l">4906</TD><TD>    }</TD></TR><TR><TD CLASS="l">4907</TD><TD> </TD></TR><TR><TD CLASS="l">4908</TD><TD>    int getStart() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2d">4909</A></TD><TD>        return start;</TD></TR><TR><TD CLASS="l">4910</TD><TD>    }</TD></TR><TR><TD CLASS="l">4911</TD><TD> </TD></TR><TR><TD CLASS="l">4912</TD><TD>    int getEnd() {</TD></TR><TR CLASS="z"><TD CLASS="l">4913</TD><TD>        return end;</TD></TR><TR><TD CLASS="l"><A NAME="39">4914</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">4915</TD><TD> </TD></TR><TR><TD CLASS="l">4916</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">4917</TD><TD>    public String toString() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="34">4918</A></TD><TD>        return &#34;sb &#34; + index;</TD></TR><TR><TD CLASS="l">4919</TD><TD>    }</TD></TR><TR><TD CLASS="l">4920</TD><TD> </TD></TR><TR><TD CLASS="l">4921</TD><TD>    boolean isInitialized() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="38">4922</A></TD><TD>        return isInitialized;</TD></TR><TR><TD CLASS="l">4923</TD><TD>    }</TD></TR><TR><TD CLASS="l">4924</TD><TD> </TD></TR><TR><TD CLASS="l">4925</TD><TD>    void setInitialized(boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="33">4926</A></TD><TD>        isInitialized = b;</TD></TR><TR CLASS="z"><TD CLASS="l">4927</TD><TD>    }</TD></TR><TR><TD CLASS="l">4928</TD><TD> </TD></TR><TR><TD CLASS="l">4929</TD><TD>    boolean isInQueue() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="37">4930</A></TD><TD>        return isInQueue;</TD></TR><TR><TD CLASS="l">4931</TD><TD>    }</TD></TR><TR><TD CLASS="l">4932</TD><TD> </TD></TR><TR><TD CLASS="l">4933</TD><TD>    void setInQueue(boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l">4934</TD><TD>        isInQueue = b;</TD></TR><TR CLASS="z"><TD CLASS="l">4935</TD><TD>    }</TD></TR><TR><TD CLASS="l">4936</TD><TD> </TD></TR><TR><TD CLASS="l">4937</TD><TD>    private int index;</TD></TR><TR><TD CLASS="l">4938</TD><TD>    private int start;</TD></TR><TR><TD CLASS="l">4939</TD><TD>    private int end;</TD></TR><TR><TD CLASS="l">4940</TD><TD>    private int[] locals;</TD></TR><TR><TD CLASS="l">4941</TD><TD>    private int[] stack;</TD></TR><TR><TD CLASS="l">4942</TD><TD>    private boolean isInitialized;</TD></TR><TR><TD CLASS="l">4943</TD><TD>    private boolean isInQueue;</TD></TR><TR><TD CLASS="l">4944</TD><TD>}</TD></TR><TR><TD CLASS="l">4945</TD><TD> </TD></TR><TR><TD CLASS="l">4946</TD><TD>/**</TD></TR><TR><TD CLASS="l">4947</TD><TD> * Helper class for internal representations of type information. In most</TD></TR><TR><TD CLASS="l">4948</TD><TD> * cases, type information can be represented by a constant, but in some</TD></TR><TR><TD CLASS="l">4949</TD><TD> * cases, a payload is included. Despite the payload coming after the type</TD></TR><TR><TD CLASS="l"><A NAME="3a">4950</A></TD><TD> * tag in the output, we store it in bits 8-23 for uniformity; the tag is</TD></TR><TR><TD CLASS="l">4951</TD><TD> * always in bits 0-7.</TD></TR><TR><TD CLASS="l">4952</TD><TD> */</TD></TR><TR><TD CLASS="l">4953</TD><TD>final class TypeInfo {</TD></TR><TR CLASS="z"><TD CLASS="l">4954</TD><TD>    private TypeInfo() { }</TD></TR><TR><TD CLASS="l">4955</TD><TD> </TD></TR><TR><TD CLASS="l">4956</TD><TD>    static final int TOP = 0;</TD></TR><TR><TD CLASS="l">4957</TD><TD>    static final int INTEGER = 1;</TD></TR><TR><TD CLASS="l">4958</TD><TD>    static final int FLOAT = 2;</TD></TR><TR><TD CLASS="l">4959</TD><TD>    static final int DOUBLE = 3;</TD></TR><TR><TD CLASS="l">4960</TD><TD>    static final int LONG = 4;</TD></TR><TR><TD CLASS="l">4961</TD><TD>    static final int NULL = 5;</TD></TR><TR><TD CLASS="l">4962</TD><TD>    static final int UNINITIALIZED_THIS = 6;</TD></TR><TR><TD CLASS="l"><A NAME="3c">4963</A></TD><TD>    static final int OBJECT_TAG = 7;</TD></TR><TR><TD CLASS="l">4964</TD><TD>    static final int UNINITIALIZED_VAR_TAG = 8;</TD></TR><TR><TD CLASS="l">4965</TD><TD> </TD></TR><TR><TD CLASS="l">4966</TD><TD>    static final int OBJECT(int constantPoolIndex) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3b">4967</A></TD><TD>        return ((constantPoolIndex &amp; 0xFFFF) &lt;&lt; 8) | OBJECT_TAG;</TD></TR><TR><TD CLASS="l">4968</TD><TD>    }</TD></TR><TR><TD CLASS="l">4969</TD><TD> </TD></TR><TR><TD CLASS="l">4970</TD><TD>    static final int OBJECT(String type, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3e">4971</A></TD><TD>        return OBJECT(pool.addClass(type));</TD></TR><TR><TD CLASS="l">4972</TD><TD>    }</TD></TR><TR><TD CLASS="l">4973</TD><TD> </TD></TR><TR><TD CLASS="l">4974</TD><TD>    static final int UNINITIALIZED_VARIABLE(int bytecodeOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="43">4975</A></TD><TD>        return ((bytecodeOffset &amp; 0xFFFF) &lt;&lt; 8) | UNINITIALIZED_VAR_TAG;</TD></TR><TR><TD CLASS="l">4976</TD><TD>    }</TD></TR><TR><TD CLASS="l">4977</TD><TD> </TD></TR><TR><TD CLASS="l">4978</TD><TD>    static final int getTag(int typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="41">4979</A></TD><TD>        return typeInfo &amp; 0xFF;</TD></TR><TR><TD CLASS="l">4980</TD><TD>    }</TD></TR><TR><TD CLASS="l">4981</TD><TD> </TD></TR><TR><TD CLASS="l">4982</TD><TD>    static final int getPayload(int typeInfo) {</TD></TR><TR CLASS="z"><TD CLASS="l">4983</TD><TD>        return typeInfo &gt;&gt;&gt; 8;</TD></TR><TR><TD CLASS="l">4984</TD><TD>    }</TD></TR><TR><TD CLASS="l">4985</TD><TD> </TD></TR><TR><TD CLASS="l">4986</TD><TD>    /**</TD></TR><TR><TD CLASS="l">4987</TD><TD>     * Treat the result of getPayload as a constant pool index and fetch the</TD></TR><TR><TD CLASS="l">4988</TD><TD>     * corresponding String mapped to it.</TD></TR><TR><TD CLASS="l"><A NAME="42">4989</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">4990</TD><TD>     * Only works on OBJECT types.</TD></TR><TR><TD CLASS="l">4991</TD><TD>     */</TD></TR><TR><TD CLASS="l">4992</TD><TD>    static final String getPayloadAsType(int typeInfo, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">4993</TD><TD>        if (getTag(typeInfo) == OBJECT_TAG) {</TD></TR><TR CLASS="z"><TD CLASS="l">4994</TD><TD>            return (String) pool.getConstantData(getPayload(typeInfo));</TD></TR><TR><TD CLASS="l">4995</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">4996</TD><TD>        throw new IllegalArgumentException(&#34;expecting object type&#34;);</TD></TR><TR><TD CLASS="l">4997</TD><TD>    }</TD></TR><TR><TD CLASS="l">4998</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3f">4999</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">5000</TD><TD>     * Create type information from an internal type.</TD></TR><TR><TD CLASS="l">5001</TD><TD>     */</TD></TR><TR><TD CLASS="l">5002</TD><TD>    static final int fromType(String type, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5003</TD><TD>        if (type.length() == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">5004</TD><TD>            switch (type.charAt(0)) {</TD></TR><TR><TD CLASS="l">5005</TD><TD>                case 'B': // sbyte</TD></TR><TR><TD CLASS="l">5006</TD><TD>                case 'C': // unicode char</TD></TR><TR><TD CLASS="l">5007</TD><TD>                case 'S': // short</TD></TR><TR><TD CLASS="l">5008</TD><TD>                case 'Z': // boolean</TD></TR><TR><TD CLASS="l">5009</TD><TD>                case 'I': // all of the above are verified as integers</TD></TR><TR CLASS="z"><TD CLASS="l">5010</TD><TD>                    return INTEGER;</TD></TR><TR><TD CLASS="l">5011</TD><TD>                case 'D':</TD></TR><TR CLASS="z"><TD CLASS="l">5012</TD><TD>                    return DOUBLE;</TD></TR><TR><TD CLASS="l">5013</TD><TD>                case 'F':</TD></TR><TR CLASS="z"><TD CLASS="l">5014</TD><TD>                    return FLOAT;</TD></TR><TR><TD CLASS="l">5015</TD><TD>                case 'J':</TD></TR><TR CLASS="z"><TD CLASS="l">5016</TD><TD>                    return LONG;</TD></TR><TR><TD CLASS="l">5017</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">5018</TD><TD>                    throw new IllegalArgumentException(&#34;bad type&#34;);</TD></TR><TR><TD CLASS="l">5019</TD><TD>            }</TD></TR><TR><TD CLASS="l">5020</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="44">5021</A></TD><TD>        return TypeInfo.OBJECT(type, pool);</TD></TR><TR><TD CLASS="l">5022</TD><TD>    }</TD></TR><TR><TD CLASS="l">5023</TD><TD> </TD></TR><TR><TD CLASS="l">5024</TD><TD>    static boolean isTwoWords(int type) {</TD></TR><TR CLASS="z"><TD CLASS="l">5025</TD><TD>        return type == DOUBLE || type == LONG;</TD></TR><TR><TD CLASS="l">5026</TD><TD>    }</TD></TR><TR><TD CLASS="l">5027</TD><TD> </TD></TR><TR><TD CLASS="l">5028</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5029</TD><TD>     * Merge two verification types.</TD></TR><TR><TD CLASS="l">5030</TD><TD>     *</TD></TR><TR><TD CLASS="l">5031</TD><TD>     * In most cases, the verification types must be the same. For example,</TD></TR><TR><TD CLASS="l">5032</TD><TD>     * INTEGER and DOUBLE cannot be merged and an exception will be thrown.</TD></TR><TR><TD CLASS="l">5033</TD><TD>     * The basic rules are:</TD></TR><TR><TD CLASS="l">5034</TD><TD>     *</TD></TR><TR><TD CLASS="l">5035</TD><TD>     * - If the types are equal, simply return one.</TD></TR><TR><TD CLASS="l">5036</TD><TD>     * - If either type is TOP, return TOP.</TD></TR><TR><TD CLASS="l">5037</TD><TD>     * - If either type is NULL, return the other type.</TD></TR><TR><TD CLASS="l">5038</TD><TD>     * - If both types are objects, find the lowest common ancestor in the</TD></TR><TR><TD CLASS="l">5039</TD><TD>     *   class hierarchy.</TD></TR><TR><TD CLASS="l">5040</TD><TD>     *</TD></TR><TR><TD CLASS="l">5041</TD><TD>     * This method uses reflection to traverse the class hierarchy. Therefore,</TD></TR><TR><TD CLASS="l">5042</TD><TD>     * it is assumed that the current class being generated is never the target</TD></TR><TR><TD CLASS="l"><A NAME="45">5043</A></TD><TD>     * of a full object-object merge, which would need to load the current</TD></TR><TR><TD CLASS="l">5044</TD><TD>     * class reflectively.</TD></TR><TR><TD CLASS="l">5045</TD><TD>     */</TD></TR><TR><TD CLASS="l">5046</TD><TD>    static int merge(int current, int incoming, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5047</TD><TD>        int currentTag = getTag(current);</TD></TR><TR CLASS="z"><TD CLASS="l">5048</TD><TD>        int incomingTag = getTag(incoming);</TD></TR><TR CLASS="z"><TD CLASS="l">5049</TD><TD>        boolean currentIsObject = currentTag == TypeInfo.OBJECT_TAG;</TD></TR><TR CLASS="z"><TD CLASS="l">5050</TD><TD>        boolean incomingIsObject = incomingTag == TypeInfo.OBJECT_TAG;</TD></TR><TR><TD CLASS="l">5051</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5052</TD><TD>        if (current == incoming || (currentIsObject &amp;&amp; incoming == NULL)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5053</TD><TD>            return current;</TD></TR><TR CLASS="z"><TD CLASS="l">5054</TD><TD>        } else if (currentTag == TypeInfo.TOP ||</TD></TR><TR><TD CLASS="l">5055</TD><TD>            incomingTag == TypeInfo.TOP) {</TD></TR><TR CLASS="z"><TD CLASS="l">5056</TD><TD>            return TypeInfo.TOP;</TD></TR><TR CLASS="z"><TD CLASS="l">5057</TD><TD>        } else if (current == NULL &amp;&amp; incomingIsObject) {</TD></TR><TR CLASS="z"><TD CLASS="l">5058</TD><TD>            return incoming;</TD></TR><TR CLASS="z"><TD CLASS="l">5059</TD><TD>        } else if (currentIsObject &amp;&amp; incomingIsObject) {</TD></TR><TR CLASS="z"><TD CLASS="l">5060</TD><TD>            String currentName = getPayloadAsType(current, pool);</TD></TR><TR CLASS="z"><TD CLASS="l">5061</TD><TD>            String incomingName = getPayloadAsType(incoming, pool);</TD></TR><TR><TD CLASS="l">5062</TD><TD>            // The class file always has the class and super names in the same</TD></TR><TR><TD CLASS="l">5063</TD><TD>            // spot. The constant order is: class_data, class_name, super_data,</TD></TR><TR><TD CLASS="l">5064</TD><TD>            // super_name.</TD></TR><TR CLASS="z"><TD CLASS="l">5065</TD><TD>            String currentlyGeneratedName = (String) pool.getConstantData(2);</TD></TR><TR CLASS="z"><TD CLASS="l">5066</TD><TD>            String currentlyGeneratedSuperName =</TD></TR><TR><TD CLASS="l">5067</TD><TD>                    (String) pool.getConstantData(4);</TD></TR><TR><TD CLASS="l">5068</TD><TD> </TD></TR><TR><TD CLASS="l">5069</TD><TD>            // If any of the merged types are the class that's currently being</TD></TR><TR><TD CLASS="l">5070</TD><TD>            // generated, automatically start at the super class instead. At</TD></TR><TR><TD CLASS="l">5071</TD><TD>            // this point, we already know the classes are different, so we</TD></TR><TR><TD CLASS="l">5072</TD><TD>            // don't need to handle that case.</TD></TR><TR CLASS="z"><TD CLASS="l">5073</TD><TD>            if (currentName.equals(currentlyGeneratedName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5074</TD><TD>                currentName = currentlyGeneratedSuperName;</TD></TR><TR><TD CLASS="l">5075</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">5076</TD><TD>            if (incomingName.equals(currentlyGeneratedName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5077</TD><TD>                incomingName = currentlyGeneratedSuperName;</TD></TR><TR><TD CLASS="l">5078</TD><TD>            }</TD></TR><TR><TD CLASS="l">5079</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5080</TD><TD>            Class&lt;?&gt; currentClass = getClassFromInternalName(currentName);</TD></TR><TR CLASS="z"><TD CLASS="l">5081</TD><TD>            Class&lt;?&gt; incomingClass = getClassFromInternalName(incomingName);</TD></TR><TR><TD CLASS="l">5082</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">5083</TD><TD>            if (currentClass.isAssignableFrom(incomingClass)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5084</TD><TD>                return current;</TD></TR><TR CLASS="z"><TD CLASS="l">5085</TD><TD>            } else if (incomingClass.isAssignableFrom(currentClass)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5086</TD><TD>                return incoming;</TD></TR><TR CLASS="z"><TD CLASS="l">5087</TD><TD>            } else if (incomingClass.isInterface() ||</TD></TR><TR><TD CLASS="l">5088</TD><TD>                       currentClass.isInterface()) {</TD></TR><TR><TD CLASS="l">5089</TD><TD>                // For verification purposes, Sun specifies that interfaces are</TD></TR><TR><TD CLASS="l">5090</TD><TD>                // subtypes of Object. Therefore, we know that the merge result</TD></TR><TR><TD CLASS="l">5091</TD><TD>                // involving interfaces where one is not assignable to the</TD></TR><TR><TD CLASS="l">5092</TD><TD>                // other results in Object.</TD></TR><TR CLASS="z"><TD CLASS="l">5093</TD><TD>                return OBJECT(&#34;java/lang/Object&#34;, pool);</TD></TR><TR><TD CLASS="l">5094</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">5095</TD><TD>                Class&lt;?&gt; commonClass = incomingClass.getSuperclass();</TD></TR><TR CLASS="z"><TD CLASS="l">5096</TD><TD>                while (commonClass != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">5097</TD><TD>                    if (commonClass.isAssignableFrom(currentClass)) {</TD></TR><TR CLASS="z"><TD CLASS="l">5098</TD><TD>                        String name = commonClass.getName();</TD></TR><TR CLASS="z"><TD CLASS="l">5099</TD><TD>                        name = ClassFileWriter.getSlashedForm(name);</TD></TR><TR CLASS="z"><TD CLASS="l">5100</TD><TD>                        return OBJECT(name, pool);</TD></TR><TR><TD CLASS="l">5101</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">5102</TD><TD>                    commonClass = commonClass.getSuperclass();</TD></TR><TR><TD CLASS="l">5103</TD><TD>                }</TD></TR><TR><TD CLASS="l">5104</TD><TD>            }</TD></TR><TR><TD CLASS="l">5105</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5106</TD><TD>        throw new IllegalArgumentException(&#34;bad merge attempt between &#34; +</TD></TR><TR><TD CLASS="l">5107</TD><TD>                                           toString(current, pool) + &#34; and &#34; +</TD></TR><TR><TD CLASS="l"><A NAME="4a">5108</A></TD><TD>                                           toString(incoming, pool));</TD></TR><TR><TD CLASS="l">5109</TD><TD>    }</TD></TR><TR><TD CLASS="l">5110</TD><TD> </TD></TR><TR><TD CLASS="l">5111</TD><TD>    static String toString(int type, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5112</TD><TD>        int tag = getTag(type);</TD></TR><TR CLASS="z"><TD CLASS="l">5113</TD><TD>        switch (tag) {</TD></TR><TR><TD CLASS="l">5114</TD><TD>            case TypeInfo.TOP:</TD></TR><TR CLASS="z"><TD CLASS="l">5115</TD><TD>                return &#34;top&#34;;</TD></TR><TR><TD CLASS="l">5116</TD><TD>            case TypeInfo.INTEGER:</TD></TR><TR CLASS="z"><TD CLASS="l">5117</TD><TD>                return &#34;int&#34;;</TD></TR><TR><TD CLASS="l">5118</TD><TD>            case TypeInfo.FLOAT:</TD></TR><TR CLASS="z"><TD CLASS="l">5119</TD><TD>                return &#34;float&#34;;</TD></TR><TR><TD CLASS="l">5120</TD><TD>            case TypeInfo.DOUBLE:</TD></TR><TR CLASS="z"><TD CLASS="l">5121</TD><TD>                return &#34;double&#34;;</TD></TR><TR><TD CLASS="l">5122</TD><TD>            case TypeInfo.LONG:</TD></TR><TR CLASS="z"><TD CLASS="l">5123</TD><TD>                return &#34;long&#34;;</TD></TR><TR><TD CLASS="l">5124</TD><TD>            case TypeInfo.NULL:</TD></TR><TR CLASS="z"><TD CLASS="l">5125</TD><TD>                return &#34;null&#34;;</TD></TR><TR><TD CLASS="l">5126</TD><TD>            case TypeInfo.UNINITIALIZED_THIS:</TD></TR><TR CLASS="z"><TD CLASS="l">5127</TD><TD>                return &#34;uninitialized_this&#34;;</TD></TR><TR><TD CLASS="l">5128</TD><TD>            default:</TD></TR><TR CLASS="z"><TD CLASS="l">5129</TD><TD>                if (tag == TypeInfo.OBJECT_TAG) {</TD></TR><TR CLASS="z"><TD CLASS="l">5130</TD><TD>                    return getPayloadAsType(type, pool);</TD></TR><TR CLASS="z"><TD CLASS="l">5131</TD><TD>                } else if (tag == TypeInfo.UNINITIALIZED_VAR_TAG) {</TD></TR><TR CLASS="z"><TD CLASS="l">5132</TD><TD>                    return &#34;uninitialized&#34;;</TD></TR><TR><TD CLASS="l">5133</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">5134</TD><TD>                    throw new IllegalArgumentException(&#34;bad type&#34;);</TD></TR><TR><TD CLASS="l">5135</TD><TD>                }</TD></TR><TR><TD CLASS="l">5136</TD><TD>        }</TD></TR><TR><TD CLASS="l">5137</TD><TD>    }</TD></TR><TR><TD CLASS="l">5138</TD><TD> </TD></TR><TR><TD CLASS="l">5139</TD><TD>    /**</TD></TR><TR><TD CLASS="l">5140</TD><TD>     * Take an internal name and return a java.lang.Class instance that</TD></TR><TR><TD CLASS="l">5141</TD><TD>     * represents it.</TD></TR><TR><TD CLASS="l">5142</TD><TD>     *</TD></TR><TR><TD CLASS="l">5143</TD><TD>     * For example, given &#34;java/lang/Object&#34;, returns the equivalent of</TD></TR><TR><TD CLASS="l"><A NAME="40">5144</A></TD><TD>     * Class.forName(&#34;java.lang.Object&#34;), but also handles exceptions.</TD></TR><TR><TD CLASS="l">5145</TD><TD>     */</TD></TR><TR><TD CLASS="l">5146</TD><TD>    static Class getClassFromInternalName(String internalName) {</TD></TR><TR><TD CLASS="l">5147</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">5148</TD><TD>            return Class.forName(internalName.replace('/', '.'));</TD></TR><TR CLASS="z"><TD CLASS="l">5149</TD><TD>        } catch (ClassNotFoundException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">5150</TD><TD>            throw new RuntimeException(e);</TD></TR><TR><TD CLASS="l"><A NAME="48">5151</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">5152</TD><TD>    }</TD></TR><TR><TD CLASS="l">5153</TD><TD> </TD></TR><TR><TD CLASS="l">5154</TD><TD>    static String toString(int[] types, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="49">5155</A></TD><TD>        return toString(types, types.length, pool);</TD></TR><TR><TD CLASS="l">5156</TD><TD>    }</TD></TR><TR><TD CLASS="l">5157</TD><TD> </TD></TR><TR><TD CLASS="l">5158</TD><TD>    static String toString(int[] types, int typesTop, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5159</TD><TD>        StringBuilder sb = new StringBuilder();</TD></TR><TR CLASS="z"><TD CLASS="l">5160</TD><TD>        sb.append(&#34;[&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5161</TD><TD>        for (int i = 0; i &lt; typesTop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">5162</TD><TD>            if (i &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">5163</TD><TD>                sb.append(&#34;, &#34;);</TD></TR><TR><TD CLASS="l">5164</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">5165</TD><TD>            sb.append(toString(types[i], pool));</TD></TR><TR><TD CLASS="l">5166</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">5167</TD><TD>        sb.append(&#34;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="46">5168</A></TD><TD>        return sb.toString();</TD></TR><TR><TD CLASS="l">5169</TD><TD>    }</TD></TR><TR><TD CLASS="l">5170</TD><TD> </TD></TR><TR><TD CLASS="l">5171</TD><TD>    static void print(int[] locals, int[] stack, ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5172</TD><TD>        print(locals, locals.length, stack, stack.length, pool);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="47">5173</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">5174</TD><TD> </TD></TR><TR><TD CLASS="l">5175</TD><TD>    static void print(int[] locals, int localsTop, int[] stack, int stackTop,</TD></TR><TR><TD CLASS="l">5176</TD><TD>                       ConstantPool pool) {</TD></TR><TR CLASS="z"><TD CLASS="l">5177</TD><TD>        System.out.print(&#34;locals: &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5178</TD><TD>        System.out.println(toString(locals, localsTop, pool));</TD></TR><TR CLASS="z"><TD CLASS="l">5179</TD><TD>        System.out.print(&#34;stack: &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">5180</TD><TD>        System.out.println(toString(stack, stackTop, pool));</TD></TR><TR CLASS="z"><TD CLASS="l">5181</TD><TD>        System.out.println();</TD></TR><TR CLASS="z"><TD CLASS="l">5182</TD><TD>    }</TD></TR><TR><TD CLASS="l">5183</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="7.html">org.mozilla.classfile</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>