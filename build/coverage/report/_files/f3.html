<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="12.html">org.mozilla.javascript.v8dtoa</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">FastDtoa.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>FastDtoa.java</TD><TD>100% (1/1)</TD><TD>90%  (9/10)</TD><TD>92%  (607/663)</TD><TD>91%  (109/120)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">FastDtoa</A></TD><TD>100% (1/1)</TD><TD>90%  (9/10)</TD><TD>92%  (607/663)</TD><TD>91%  (109/120)</TD></TR><TR><TD CLASS="f"><A HREF="#0">FastDtoa (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">dtoa (double, FastDtoaBuilder): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (20/32)</TD><TD CLASS="h">68%  (2.7/4)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">75%  (6/8)</TD><TD CLASS="h">75%  (0.8/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">biggestPowerTen (int, int): long</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>86%  (87/101)</TD><TD>83%  (39/47)</TD></TR><TR><TD CLASS="f"><A HREF="#5">grisu3 (double, FastDtoaBuilder): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (89/101)</TD><TD>97%  (12.6/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">digitGen (DiyFp, DiyFp, DiyFp, FastDtoaBuilder, int): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (258/270)</TD><TD>98%  (38.2/39)</TD></TR><TR><TD CLASS="f"><A HREF="#7">uint64_lte (long, long): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>97%  (31/32)</TD><TD>96%  (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">numberToString (double): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (13/13)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#9">numberToString (double, FastDtoaBuilder): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (16/16)</TD><TD>100% (5/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">roundWeed (FastDtoaBuilder, long, long, long, long, long): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (87/87)</TD><TD>100% (8/8)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>// Copyright 2010 the V8 project authors. All rights reserved.</TD></TR><TR><TD CLASS="l">2</TD><TD>// Redistribution and use in source and binary forms, with or without</TD></TR><TR><TD CLASS="l">3</TD><TD>// modification, are permitted provided that the following conditions are</TD></TR><TR><TD CLASS="l">4</TD><TD>// met:</TD></TR><TR><TD CLASS="l">5</TD><TD>//</TD></TR><TR><TD CLASS="l">6</TD><TD>//     * Redistributions of source code must retain the above copyright</TD></TR><TR><TD CLASS="l">7</TD><TD>//       notice, this list of conditions and the following disclaimer.</TD></TR><TR><TD CLASS="l">8</TD><TD>//     * Redistributions in binary form must reproduce the above</TD></TR><TR><TD CLASS="l">9</TD><TD>//       copyright notice, this list of conditions and the following</TD></TR><TR><TD CLASS="l">10</TD><TD>//       disclaimer in the documentation and/or other materials provided</TD></TR><TR><TD CLASS="l">11</TD><TD>//       with the distribution.</TD></TR><TR><TD CLASS="l">12</TD><TD>//     * Neither the name of Google Inc. nor the names of its</TD></TR><TR><TD CLASS="l">13</TD><TD>//       contributors may be used to endorse or promote products derived</TD></TR><TR><TD CLASS="l">14</TD><TD>//       from this software without specific prior written permission.</TD></TR><TR><TD CLASS="l">15</TD><TD>//</TD></TR><TR><TD CLASS="l">16</TD><TD>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</TD></TR><TR><TD CLASS="l">17</TD><TD>// &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</TD></TR><TR><TD CLASS="l">18</TD><TD>// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</TD></TR><TR><TD CLASS="l">19</TD><TD>// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</TD></TR><TR><TD CLASS="l">20</TD><TD>// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</TD></TR><TR><TD CLASS="l">21</TD><TD>// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</TD></TR><TR><TD CLASS="l">22</TD><TD>// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</TD></TR><TR><TD CLASS="l">23</TD><TD>// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</TD></TR><TR><TD CLASS="l">24</TD><TD>// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</TD></TR><TR><TD CLASS="l">25</TD><TD>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</TD></TR><TR><TD CLASS="l">26</TD><TD>// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</TD></TR><TR><TD CLASS="l">27</TD><TD> </TD></TR><TR><TD CLASS="l">28</TD><TD>// Ported to Java from Mozilla's version of V8-dtoa by Hannes Wallnoefer.</TD></TR><TR><TD CLASS="l"><A NAME="0">29</A></TD><TD>// The original revision was 67d1049b0bf9 from the mozilla-central tree.</TD></TR><TR><TD CLASS="l">30</TD><TD> </TD></TR><TR><TD CLASS="l">31</TD><TD>package org.mozilla.javascript.v8dtoa;</TD></TR><TR><TD CLASS="l">32</TD><TD> </TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="55% line coverage (6 out of 11 instructions)">33</TD><TD TITLE="55% line coverage (6 out of 11 instructions)">public class FastDtoa {</TD></TR><TR><TD CLASS="l">34</TD><TD> </TD></TR><TR><TD CLASS="l">35</TD><TD>    // FastDtoa will produce at most kFastDtoaMaximalLength digits.</TD></TR><TR><TD CLASS="l">36</TD><TD>    static final int kFastDtoaMaximalLength = 17;</TD></TR><TR><TD CLASS="l">37</TD><TD> </TD></TR><TR><TD CLASS="l">38</TD><TD> </TD></TR><TR><TD CLASS="l">39</TD><TD>    // The minimal and maximal target exponent define the range of w's binary</TD></TR><TR><TD CLASS="l">40</TD><TD>    // exponent, where 'w' is the result of multiplying the input by a cached power</TD></TR><TR><TD CLASS="l">41</TD><TD>    // of ten.</TD></TR><TR><TD CLASS="l">42</TD><TD>    //</TD></TR><TR><TD CLASS="l">43</TD><TD>    // A different range might be chosen on a different platform, to optimize digit</TD></TR><TR><TD CLASS="l">44</TD><TD>    // generation, but a smaller range requires more powers of ten to be cached.</TD></TR><TR><TD CLASS="l">45</TD><TD>    static final int minimal_target_exponent = -60;</TD></TR><TR><TD CLASS="l">46</TD><TD>    static final int maximal_target_exponent = -32;</TD></TR><TR><TD CLASS="l">47</TD><TD> </TD></TR><TR><TD CLASS="l">48</TD><TD> </TD></TR><TR><TD CLASS="l">49</TD><TD>    // Adjusts the last digit of the generated number, and screens out generated</TD></TR><TR><TD CLASS="l">50</TD><TD>    // solutions that may be inaccurate. A solution may be inaccurate if it is</TD></TR><TR><TD CLASS="l">51</TD><TD>    // outside the safe interval, or if we ctannot prove that it is closer to the</TD></TR><TR><TD CLASS="l">52</TD><TD>    // input than a neighboring representation of the same length.</TD></TR><TR><TD CLASS="l">53</TD><TD>    //</TD></TR><TR><TD CLASS="l">54</TD><TD>    // Input: * buffer containing the digits of too_high / 10^kappa</TD></TR><TR><TD CLASS="l">55</TD><TD>    //        * distance_too_high_w == (too_high - w).f() * unit</TD></TR><TR><TD CLASS="l">56</TD><TD>    //        * unsafe_interval == (too_high - too_low).f() * unit</TD></TR><TR><TD CLASS="l">57</TD><TD>    //        * rest = (too_high - buffer * 10^kappa).f() * unit</TD></TR><TR><TD CLASS="l">58</TD><TD>    //        * ten_kappa = 10^kappa * unit</TD></TR><TR><TD CLASS="l">59</TD><TD>    //        * unit = the common multiplier</TD></TR><TR><TD CLASS="l">60</TD><TD>    // Output: returns true if the buffer is guaranteed to contain the closest</TD></TR><TR><TD CLASS="l">61</TD><TD>    //    representable number to the input.</TD></TR><TR><TD CLASS="l">62</TD><TD>    //  Modifies the generated digits in the buffer to approach (round towards) w.</TD></TR><TR><TD CLASS="l">63</TD><TD>    static boolean roundWeed(FastDtoaBuilder buffer,</TD></TR><TR><TD CLASS="l">64</TD><TD>                             long distance_too_high_w,</TD></TR><TR><TD CLASS="l"><A NAME="a">65</A></TD><TD>                             long unsafe_interval,</TD></TR><TR><TD CLASS="l">66</TD><TD>                             long rest,</TD></TR><TR><TD CLASS="l">67</TD><TD>                             long ten_kappa,</TD></TR><TR><TD CLASS="l">68</TD><TD>                             long unit) {</TD></TR><TR CLASS="c"><TD CLASS="l">69</TD><TD>        long small_distance = distance_too_high_w - unit;</TD></TR><TR CLASS="c"><TD CLASS="l">70</TD><TD>        long big_distance = distance_too_high_w + unit;</TD></TR><TR><TD CLASS="l">71</TD><TD>        // Let w_low  = too_high - big_distance, and</TD></TR><TR><TD CLASS="l">72</TD><TD>        //     w_high = too_high - small_distance.</TD></TR><TR><TD CLASS="l">73</TD><TD>        // Note: w_low &lt; w &lt; w_high</TD></TR><TR><TD CLASS="l">74</TD><TD>        //</TD></TR><TR><TD CLASS="l">75</TD><TD>        // The real w (* unit) must lie somewhere inside the interval</TD></TR><TR><TD CLASS="l">76</TD><TD>        // ]w_low; w_low[ (often written as &#34;(w_low; w_low)&#34;)</TD></TR><TR><TD CLASS="l">77</TD><TD> </TD></TR><TR><TD CLASS="l">78</TD><TD>        // Basically the buffer currently contains a number in the unsafe interval</TD></TR><TR><TD CLASS="l">79</TD><TD>        // ]too_low; too_high[ with too_low &lt; w &lt; too_high</TD></TR><TR><TD CLASS="l">80</TD><TD>        //</TD></TR><TR><TD CLASS="l">81</TD><TD>        //  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</TD></TR><TR><TD CLASS="l">82</TD><TD>        //                     ^v 1 unit            ^      ^                 ^      ^</TD></TR><TR><TD CLASS="l">83</TD><TD>        //  boundary_high ---------------------     .      .                 .      .</TD></TR><TR><TD CLASS="l">84</TD><TD>        //                     ^v 1 unit            .      .                 .      .</TD></TR><TR><TD CLASS="l">85</TD><TD>        //   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .</TD></TR><TR><TD CLASS="l">86</TD><TD>        //                                          .      .         ^       .      .</TD></TR><TR><TD CLASS="l">87</TD><TD>        //                                          .  big_distance  .       .      .</TD></TR><TR><TD CLASS="l">88</TD><TD>        //                                          .      .         .       .    rest</TD></TR><TR><TD CLASS="l">89</TD><TD>        //                              small_distance     .         .       .      .</TD></TR><TR><TD CLASS="l">90</TD><TD>        //                                          v      .         .       .      .</TD></TR><TR><TD CLASS="l">91</TD><TD>        //  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .</TD></TR><TR><TD CLASS="l">92</TD><TD>        //                     ^v 1 unit                   .         .       .      .</TD></TR><TR><TD CLASS="l">93</TD><TD>        //  w ----------------------------------------     .         .       .      .</TD></TR><TR><TD CLASS="l">94</TD><TD>        //                     ^v 1 unit                   v         .       .      .</TD></TR><TR><TD CLASS="l">95</TD><TD>        //  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .</TD></TR><TR><TD CLASS="l">96</TD><TD>        //                                                           .       .      v</TD></TR><TR><TD CLASS="l">97</TD><TD>        //  buffer --------------------------------------------------+-------+--------</TD></TR><TR><TD CLASS="l">98</TD><TD>        //                                                           .       .</TD></TR><TR><TD CLASS="l">99</TD><TD>        //                                                  safe_interval    .</TD></TR><TR><TD CLASS="l">100</TD><TD>        //                                                           v       .</TD></TR><TR><TD CLASS="l">101</TD><TD>        //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .</TD></TR><TR><TD CLASS="l">102</TD><TD>        //                     ^v 1 unit                                     .</TD></TR><TR><TD CLASS="l">103</TD><TD>        //  boundary_low -------------------------                     unsafe_interval</TD></TR><TR><TD CLASS="l">104</TD><TD>        //                     ^v 1 unit                                     v</TD></TR><TR><TD CLASS="l">105</TD><TD>        //  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</TD></TR><TR><TD CLASS="l">106</TD><TD>        //</TD></TR><TR><TD CLASS="l">107</TD><TD>        //</TD></TR><TR><TD CLASS="l">108</TD><TD>        // Note that the value of buffer could lie anywhere inside the range too_low</TD></TR><TR><TD CLASS="l">109</TD><TD>        // to too_high.</TD></TR><TR><TD CLASS="l">110</TD><TD>        //</TD></TR><TR><TD CLASS="l">111</TD><TD>        // boundary_low, boundary_high and w are approximations of the real boundaries</TD></TR><TR><TD CLASS="l">112</TD><TD>        // and v (the input number). They are guaranteed to be precise up to one unit.</TD></TR><TR><TD CLASS="l">113</TD><TD>        // In fact the error is guaranteed to be strictly less than one unit.</TD></TR><TR><TD CLASS="l">114</TD><TD>        //</TD></TR><TR><TD CLASS="l">115</TD><TD>        // Anything that lies outside the unsafe interval is guaranteed not to round</TD></TR><TR><TD CLASS="l">116</TD><TD>        // to v when read again.</TD></TR><TR><TD CLASS="l">117</TD><TD>        // Anything that lies inside the safe interval is guaranteed to round to v</TD></TR><TR><TD CLASS="l">118</TD><TD>        // when read again.</TD></TR><TR><TD CLASS="l">119</TD><TD>        // If the number inside the buffer lies inside the unsafe interval but not</TD></TR><TR><TD CLASS="l">120</TD><TD>        // inside the safe interval then we simply do not know and bail out (returning</TD></TR><TR><TD CLASS="l">121</TD><TD>        // false).</TD></TR><TR><TD CLASS="l">122</TD><TD>        //</TD></TR><TR><TD CLASS="l">123</TD><TD>        // Similarly we have to take into account the imprecision of 'w' when rounding</TD></TR><TR><TD CLASS="l">124</TD><TD>        // the buffer. If we have two potential representations we need to make sure</TD></TR><TR><TD CLASS="l">125</TD><TD>        // that the chosen one is closer to w_low and w_high since v can be anywhere</TD></TR><TR><TD CLASS="l">126</TD><TD>        // between them.</TD></TR><TR><TD CLASS="l">127</TD><TD>        //</TD></TR><TR><TD CLASS="l">128</TD><TD>        // By generating the digits of too_high we got the largest (closest to</TD></TR><TR><TD CLASS="l">129</TD><TD>        // too_high) buffer that is still in the unsafe interval. In the case where</TD></TR><TR><TD CLASS="l">130</TD><TD>        // w_high &lt; buffer &lt; too_high we try to decrement the buffer.</TD></TR><TR><TD CLASS="l">131</TD><TD>        // This way the buffer approaches (rounds towards) w.</TD></TR><TR><TD CLASS="l">132</TD><TD>        // There are 3 conditions that stop the decrementation process:</TD></TR><TR><TD CLASS="l">133</TD><TD>        //   1) the buffer is already below w_high</TD></TR><TR><TD CLASS="l">134</TD><TD>        //   2) decrementing the buffer would make it leave the unsafe interval</TD></TR><TR><TD CLASS="l">135</TD><TD>        //   3) decrementing the buffer would yield a number below w_high and farther</TD></TR><TR><TD CLASS="l">136</TD><TD>        //      away than the current number. In other words:</TD></TR><TR><TD CLASS="l">137</TD><TD>        //              (buffer{-1} &lt; w_high) &amp;&amp; w_high - buffer{-1} &gt; buffer - w_high</TD></TR><TR><TD CLASS="l">138</TD><TD>        // Instead of using the buffer directly we use its distance to too_high.</TD></TR><TR><TD CLASS="l">139</TD><TD>        // Conceptually rest ~= too_high - buffer</TD></TR><TR><TD CLASS="l">140</TD><TD>        while (rest &lt; small_distance &amp;&amp;  // Negated condition 1</TD></TR><TR CLASS="c"><TD CLASS="l">141</TD><TD>                unsafe_interval - rest &gt;= ten_kappa &amp;&amp;  // Negated condition 2</TD></TR><TR><TD CLASS="l">142</TD><TD>                (rest + ten_kappa &lt; small_distance ||  // buffer{-1} &gt; w_high</TD></TR><TR><TD CLASS="l">143</TD><TD>                        small_distance - rest &gt;= rest + ten_kappa - small_distance)) {</TD></TR><TR CLASS="c"><TD CLASS="l">144</TD><TD>            buffer.decreaseLast();</TD></TR><TR CLASS="c"><TD CLASS="l">145</TD><TD>            rest += ten_kappa;</TD></TR><TR><TD CLASS="l">146</TD><TD>        }</TD></TR><TR><TD CLASS="l">147</TD><TD> </TD></TR><TR><TD CLASS="l">148</TD><TD>        // We have approached w+ as much as possible. We now test if approaching w-</TD></TR><TR><TD CLASS="l">149</TD><TD>        // would require changing the buffer. If yes, then we have two possible</TD></TR><TR><TD CLASS="l">150</TD><TD>        // representations close to w, but we cannot decide which one is closer.</TD></TR><TR CLASS="c"><TD CLASS="l">151</TD><TD>        if (rest &lt; big_distance &amp;&amp;</TD></TR><TR><TD CLASS="l">152</TD><TD>                unsafe_interval - rest &gt;= ten_kappa &amp;&amp;</TD></TR><TR><TD CLASS="l">153</TD><TD>                (rest + ten_kappa &lt; big_distance ||</TD></TR><TR><TD CLASS="l">154</TD><TD>                        big_distance - rest &gt; rest + ten_kappa - big_distance)) {</TD></TR><TR CLASS="c"><TD CLASS="l">155</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">156</TD><TD>        }</TD></TR><TR><TD CLASS="l">157</TD><TD> </TD></TR><TR><TD CLASS="l">158</TD><TD>        // Weeding test.</TD></TR><TR><TD CLASS="l">159</TD><TD>        //   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]</TD></TR><TR><TD CLASS="l">160</TD><TD>        //   Since too_low = too_high - unsafe_interval this is equivalent to</TD></TR><TR><TD CLASS="l">161</TD><TD>        //      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]</TD></TR><TR><TD CLASS="l">162</TD><TD>        //   Conceptually we have: rest ~= too_high - buffer</TD></TR><TR CLASS="c"><TD CLASS="l">163</TD><TD>        return (2 * unit &lt;= rest) &amp;&amp; (rest &lt;= unsafe_interval - 4 * unit);</TD></TR><TR><TD CLASS="l">164</TD><TD>    }</TD></TR><TR><TD CLASS="l">165</TD><TD> </TD></TR><TR><TD CLASS="l">166</TD><TD> </TD></TR><TR><TD CLASS="l">167</TD><TD> </TD></TR><TR><TD CLASS="l">168</TD><TD>    static final int kTen4 = 10000;</TD></TR><TR><TD CLASS="l">169</TD><TD>    static final int kTen5 = 100000;</TD></TR><TR><TD CLASS="l">170</TD><TD>    static final int kTen6 = 1000000;</TD></TR><TR><TD CLASS="l">171</TD><TD>    static final int kTen7 = 10000000;</TD></TR><TR><TD CLASS="l">172</TD><TD>    static final int kTen8 = 100000000;</TD></TR><TR><TD CLASS="l">173</TD><TD>    static final int kTen9 = 1000000000;</TD></TR><TR><TD CLASS="l">174</TD><TD> </TD></TR><TR><TD CLASS="l">175</TD><TD>    // Returns the biggest power of ten that is less than or equal than the given</TD></TR><TR><TD CLASS="l">176</TD><TD>    // number. We furthermore receive the maximum number of bits 'number' has.</TD></TR><TR><TD CLASS="l">177</TD><TD>    // If number_bits == 0 then 0^-1 is returned</TD></TR><TR><TD CLASS="l">178</TD><TD>    // The number of bits must be &lt;= 32.</TD></TR><TR><TD CLASS="l"><A NAME="4">179</A></TD><TD>    // Precondition: (1 &lt;&lt; number_bits) &lt;= number &lt; (1 &lt;&lt; (number_bits + 1)).</TD></TR><TR><TD CLASS="l">180</TD><TD>    static long biggestPowerTen(int number,</TD></TR><TR><TD CLASS="l">181</TD><TD>                                int number_bits) {</TD></TR><TR><TD CLASS="l">182</TD><TD>        int power, exponent;</TD></TR><TR CLASS="c"><TD CLASS="l">183</TD><TD>        switch (number_bits) {</TD></TR><TR><TD CLASS="l">184</TD><TD>            case 32:</TD></TR><TR><TD CLASS="l">185</TD><TD>            case 31:</TD></TR><TR><TD CLASS="l">186</TD><TD>            case 30:</TD></TR><TR CLASS="c"><TD CLASS="l">187</TD><TD>                if (kTen9 &lt;= number) {</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                    power = kTen9;</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                    exponent = 9;</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">191</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">192</TD><TD>            case 29:</TD></TR><TR><TD CLASS="l">193</TD><TD>            case 28:</TD></TR><TR><TD CLASS="l">194</TD><TD>            case 27:</TD></TR><TR CLASS="c"><TD CLASS="l">195</TD><TD>                if (kTen8 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">196</TD><TD>                    power = kTen8;</TD></TR><TR CLASS="c"><TD CLASS="l">197</TD><TD>                    exponent = 8;</TD></TR><TR CLASS="c"><TD CLASS="l">198</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">199</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">200</TD><TD>            case 26:</TD></TR><TR><TD CLASS="l">201</TD><TD>            case 25:</TD></TR><TR><TD CLASS="l">202</TD><TD>            case 24:</TD></TR><TR CLASS="c"><TD CLASS="l">203</TD><TD>                if (kTen7 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">204</TD><TD>                    power = kTen7;</TD></TR><TR CLASS="c"><TD CLASS="l">205</TD><TD>                    exponent = 7;</TD></TR><TR CLASS="c"><TD CLASS="l">206</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">207</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">208</TD><TD>            case 23:</TD></TR><TR><TD CLASS="l">209</TD><TD>            case 22:</TD></TR><TR><TD CLASS="l">210</TD><TD>            case 21:</TD></TR><TR><TD CLASS="l">211</TD><TD>            case 20:</TD></TR><TR CLASS="c"><TD CLASS="l">212</TD><TD>                if (kTen6 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">213</TD><TD>                    power = kTen6;</TD></TR><TR CLASS="c"><TD CLASS="l">214</TD><TD>                    exponent = 6;</TD></TR><TR CLASS="c"><TD CLASS="l">215</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">216</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">217</TD><TD>            case 19:</TD></TR><TR><TD CLASS="l">218</TD><TD>            case 18:</TD></TR><TR><TD CLASS="l">219</TD><TD>            case 17:</TD></TR><TR CLASS="c"><TD CLASS="l">220</TD><TD>                if (kTen5 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">221</TD><TD>                    power = kTen5;</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>                    exponent = 5;</TD></TR><TR CLASS="c"><TD CLASS="l">223</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">224</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">225</TD><TD>            case 16:</TD></TR><TR><TD CLASS="l">226</TD><TD>            case 15:</TD></TR><TR><TD CLASS="l">227</TD><TD>            case 14:</TD></TR><TR CLASS="c"><TD CLASS="l">228</TD><TD>                if (kTen4 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">229</TD><TD>                    power = kTen4;</TD></TR><TR CLASS="c"><TD CLASS="l">230</TD><TD>                    exponent = 4;</TD></TR><TR CLASS="c"><TD CLASS="l">231</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">232</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">233</TD><TD>            case 13:</TD></TR><TR><TD CLASS="l">234</TD><TD>            case 12:</TD></TR><TR><TD CLASS="l">235</TD><TD>            case 11:</TD></TR><TR><TD CLASS="l">236</TD><TD>            case 10:</TD></TR><TR CLASS="c"><TD CLASS="l">237</TD><TD>                if (1000 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">238</TD><TD>                    power = 1000;</TD></TR><TR CLASS="c"><TD CLASS="l">239</TD><TD>                    exponent = 3;</TD></TR><TR CLASS="c"><TD CLASS="l">240</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">241</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">242</TD><TD>            case 9:</TD></TR><TR><TD CLASS="l">243</TD><TD>            case 8:</TD></TR><TR><TD CLASS="l">244</TD><TD>            case 7:</TD></TR><TR CLASS="c"><TD CLASS="l">245</TD><TD>                if (100 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">246</TD><TD>                    power = 100;</TD></TR><TR CLASS="c"><TD CLASS="l">247</TD><TD>                    exponent = 2;</TD></TR><TR CLASS="c"><TD CLASS="l">248</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">249</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">250</TD><TD>            case 6:</TD></TR><TR><TD CLASS="l">251</TD><TD>            case 5:</TD></TR><TR><TD CLASS="l">252</TD><TD>            case 4:</TD></TR><TR CLASS="c"><TD CLASS="l">253</TD><TD>                if (10 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">254</TD><TD>                    power = 10;</TD></TR><TR CLASS="c"><TD CLASS="l">255</TD><TD>                    exponent = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">256</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">257</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">258</TD><TD>            case 3:</TD></TR><TR><TD CLASS="l">259</TD><TD>            case 2:</TD></TR><TR><TD CLASS="l">260</TD><TD>            case 1:</TD></TR><TR CLASS="c"><TD CLASS="l">261</TD><TD>                if (1 &lt;= number) {</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>                    power = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">263</TD><TD>                    exponent = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">264</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">265</TD><TD>                }  // else fallthrough</TD></TR><TR><TD CLASS="l">266</TD><TD>            case 0:</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                power = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                exponent = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                break;</TD></TR><TR><TD CLASS="l">270</TD><TD>            default:</TD></TR><TR><TD CLASS="l">271</TD><TD>                // Following assignments are here to silence compiler warnings.</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                power = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                exponent = 0;</TD></TR><TR><TD CLASS="l">274</TD><TD>                // UNREACHABLE();</TD></TR><TR><TD CLASS="l">275</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">276</TD><TD>        return ((long)power &lt;&lt; 32) | (0xffffffffL &amp; exponent);</TD></TR><TR><TD CLASS="l"><A NAME="7">277</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">278</TD><TD> </TD></TR><TR><TD CLASS="l">279</TD><TD>    private static boolean uint64_lte(long a, long b) {</TD></TR><TR><TD CLASS="l">280</TD><TD>        // less-or-equal for unsigned int64 in java-style...</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="97% line coverage (31 out of 32 instructions)">281</TD><TD TITLE="97% line coverage (31 out of 32 instructions)">        return (a == b) || ((a &lt; b) ^ (a &lt; 0) ^ (b &lt; 0));</TD></TR><TR><TD CLASS="l">282</TD><TD>    }</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR><TD CLASS="l">284</TD><TD>    // Generates the digits of input number w.</TD></TR><TR><TD CLASS="l">285</TD><TD>    // w is a floating-point number (DiyFp), consisting of a significand and an</TD></TR><TR><TD CLASS="l">286</TD><TD>    // exponent. Its exponent is bounded by minimal_target_exponent and</TD></TR><TR><TD CLASS="l">287</TD><TD>    // maximal_target_exponent.</TD></TR><TR><TD CLASS="l">288</TD><TD>    //       Hence -60 &lt;= w.e() &lt;= -32.</TD></TR><TR><TD CLASS="l">289</TD><TD>    //</TD></TR><TR><TD CLASS="l">290</TD><TD>    // Returns false if it fails, in which case the generated digits in the buffer</TD></TR><TR><TD CLASS="l">291</TD><TD>    // should not be used.</TD></TR><TR><TD CLASS="l">292</TD><TD>    // Preconditions:</TD></TR><TR><TD CLASS="l">293</TD><TD>    //  * low, w and high are correct up to 1 ulp (unit in the last place). That</TD></TR><TR><TD CLASS="l">294</TD><TD>    //    is, their error must be less that a unit of their last digits.</TD></TR><TR><TD CLASS="l">295</TD><TD>    //  * low.e() == w.e() == high.e()</TD></TR><TR><TD CLASS="l">296</TD><TD>    //  * low &lt; w &lt; high, and taking into account their error: low~ &lt;= high~</TD></TR><TR><TD CLASS="l">297</TD><TD>    //  * minimal_target_exponent &lt;= w.e() &lt;= maximal_target_exponent</TD></TR><TR><TD CLASS="l">298</TD><TD>    // Postconditions: returns false if procedure fails.</TD></TR><TR><TD CLASS="l">299</TD><TD>    //   otherwise:</TD></TR><TR><TD CLASS="l">300</TD><TD>    //     * buffer is not null-terminated, but len contains the number of digits.</TD></TR><TR><TD CLASS="l">301</TD><TD>    //     * buffer contains the shortest possible decimal digit-sequence</TD></TR><TR><TD CLASS="l">302</TD><TD>    //       such that LOW &lt; buffer * 10^kappa &lt; HIGH, where LOW and HIGH are the</TD></TR><TR><TD CLASS="l">303</TD><TD>    //       correct values of low and high (without their error).</TD></TR><TR><TD CLASS="l">304</TD><TD>    //     * if more than one decimal representation gives the minimal number of</TD></TR><TR><TD CLASS="l">305</TD><TD>    //       decimal digits then the one closest to W (where W is the correct value</TD></TR><TR><TD CLASS="l">306</TD><TD>    //       of w) is chosen.</TD></TR><TR><TD CLASS="l">307</TD><TD>    // Remark: this procedure takes into account the imprecision of its input</TD></TR><TR><TD CLASS="l">308</TD><TD>    //   numbers. If the precision is not enough to guarantee all the postconditions</TD></TR><TR><TD CLASS="l">309</TD><TD>    //   then false is returned. This usually happens rarely (~0.5%).</TD></TR><TR><TD CLASS="l">310</TD><TD>    //</TD></TR><TR><TD CLASS="l">311</TD><TD>    // Say, for the sake of example, that</TD></TR><TR><TD CLASS="l">312</TD><TD>    //   w.e() == -48, and w.f() == 0x1234567890abcdef</TD></TR><TR><TD CLASS="l">313</TD><TD>    // w's value can be computed by w.f() * 2^w.e()</TD></TR><TR><TD CLASS="l">314</TD><TD>    // We can obtain w's integral digits by simply shifting w.f() by -w.e().</TD></TR><TR><TD CLASS="l">315</TD><TD>    //  -&gt; w's integral part is 0x1234</TD></TR><TR><TD CLASS="l">316</TD><TD>    //  w's fractional part is therefore 0x567890abcdef.</TD></TR><TR><TD CLASS="l">317</TD><TD>    // Printing w's integral part is easy (simply print 0x1234 in decimal).</TD></TR><TR><TD CLASS="l">318</TD><TD>    // In order to print its fraction we repeatedly multiply the fraction by 10 and</TD></TR><TR><TD CLASS="l">319</TD><TD>    // get each digit. Example the first digit after the point would be computed by</TD></TR><TR><TD CLASS="l">320</TD><TD>    //   (0x567890abcdef * 10) &gt;&gt; 48. -&gt; 3</TD></TR><TR><TD CLASS="l">321</TD><TD>    // The whole thing becomes slightly more complicated because we want to stop</TD></TR><TR><TD CLASS="l">322</TD><TD>    // once we have enough digits. That is, once the digits inside the buffer</TD></TR><TR><TD CLASS="l">323</TD><TD>    // represent 'w' we can stop. Everything inside the interval low - high</TD></TR><TR><TD CLASS="l">324</TD><TD>    // represents w. However we have to pay attention to low, high and w's</TD></TR><TR><TD CLASS="l">325</TD><TD>    // imprecision.</TD></TR><TR><TD CLASS="l">326</TD><TD>    static boolean digitGen(DiyFp low,</TD></TR><TR><TD CLASS="l"><A NAME="6">327</A></TD><TD>                     DiyFp w,</TD></TR><TR><TD CLASS="l">328</TD><TD>                     DiyFp high,</TD></TR><TR><TD CLASS="l">329</TD><TD>                     FastDtoaBuilder buffer,</TD></TR><TR><TD CLASS="l">330</TD><TD>                     int mk) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (12 out of 16 instructions)">331</TD><TD TITLE="75% line coverage (12 out of 16 instructions)">        assert(low.e() == w.e() &amp;&amp; w.e() == high.e());</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (12 out of 16 instructions)">332</TD><TD TITLE="75% line coverage (12 out of 16 instructions)">        assert uint64_lte(low.f() + 1, high.f() - 1);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="71% line coverage (10 out of 14 instructions)">333</TD><TD TITLE="71% line coverage (10 out of 14 instructions)">        assert(minimal_target_exponent &lt;= w.e() &amp;&amp; w.e() &lt;= maximal_target_exponent);</TD></TR><TR><TD CLASS="l">334</TD><TD>        // low, w and high are imprecise, but by less than one ulp (unit in the last</TD></TR><TR><TD CLASS="l">335</TD><TD>        // place).</TD></TR><TR><TD CLASS="l">336</TD><TD>        // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that</TD></TR><TR><TD CLASS="l">337</TD><TD>        // the new numbers are outside of the interval we want the final</TD></TR><TR><TD CLASS="l">338</TD><TD>        // representation to lie in.</TD></TR><TR><TD CLASS="l">339</TD><TD>        // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield</TD></TR><TR><TD CLASS="l">340</TD><TD>        // numbers that are certain to lie in the interval. We will use this fact</TD></TR><TR><TD CLASS="l">341</TD><TD>        // later on.</TD></TR><TR><TD CLASS="l">342</TD><TD>        // We will now start by generating the digits within the uncertain</TD></TR><TR><TD CLASS="l">343</TD><TD>        // interval. Later we will weed out representations that lie outside the safe</TD></TR><TR><TD CLASS="l">344</TD><TD>        // interval and thus _might_ lie outside the correct interval.</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        long unit = 1;</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>        DiyFp too_low = new DiyFp(low.f() - unit, low.e());</TD></TR><TR CLASS="c"><TD CLASS="l">347</TD><TD>        DiyFp too_high = new DiyFp(high.f() + unit, high.e());</TD></TR><TR><TD CLASS="l">348</TD><TD>        // too_low and too_high are guaranteed to lie outside the interval we want the</TD></TR><TR><TD CLASS="l">349</TD><TD>        // generated number in.</TD></TR><TR CLASS="c"><TD CLASS="l">350</TD><TD>        DiyFp unsafe_interval = DiyFp.minus(too_high, too_low);</TD></TR><TR><TD CLASS="l">351</TD><TD>        // We now cut the input number into two parts: the integral digits and the</TD></TR><TR><TD CLASS="l">352</TD><TD>        // fractionals. We will not write any decimal separator though, but adapt</TD></TR><TR><TD CLASS="l">353</TD><TD>        // kappa instead.</TD></TR><TR><TD CLASS="l">354</TD><TD>        // Reminder: we are currently computing the digits (stored inside the buffer)</TD></TR><TR><TD CLASS="l">355</TD><TD>        // such that:   too_low &lt; buffer * 10^kappa &lt; too_high</TD></TR><TR><TD CLASS="l">356</TD><TD>        // We use too_high for the digit_generation and stop as soon as possible.</TD></TR><TR><TD CLASS="l">357</TD><TD>        // If we stop early we effectively round down.</TD></TR><TR CLASS="c"><TD CLASS="l">358</TD><TD>        DiyFp one = new DiyFp(1l &lt;&lt; -w.e(), w.e());</TD></TR><TR><TD CLASS="l">359</TD><TD>        // Division by one is a shift.</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        int integrals = (int)((too_high.f() &gt;&gt;&gt; -one.e()) &amp; 0xffffffffL);</TD></TR><TR><TD CLASS="l">361</TD><TD>        // Modulo by one is an and.</TD></TR><TR CLASS="c"><TD CLASS="l">362</TD><TD>        long fractionals = too_high.f() &amp; (one.f() - 1);</TD></TR><TR CLASS="c"><TD CLASS="l">363</TD><TD>        long result = biggestPowerTen(integrals, DiyFp.kSignificandSize - (-one.e()));</TD></TR><TR CLASS="c"><TD CLASS="l">364</TD><TD>        int divider = (int) ((result &gt;&gt;&gt; 32) &amp; 0xffffffffL);</TD></TR><TR CLASS="c"><TD CLASS="l">365</TD><TD>        int divider_exponent = (int) (result &amp; 0xffffffffL);</TD></TR><TR CLASS="c"><TD CLASS="l">366</TD><TD>        int kappa = divider_exponent + 1;</TD></TR><TR><TD CLASS="l">367</TD><TD>        // Loop invariant: buffer = too_high / 10^kappa  (integer division)</TD></TR><TR><TD CLASS="l">368</TD><TD>        // The invariant holds for the first iteration: kappa has been initialized</TD></TR><TR><TD CLASS="l">369</TD><TD>        // with the divider exponent + 1. And the divider is the biggest power of ten</TD></TR><TR><TD CLASS="l">370</TD><TD>        // that is smaller than integrals.</TD></TR><TR CLASS="c"><TD CLASS="l">371</TD><TD>        while (kappa &gt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">372</TD><TD>            int digit = integrals / divider;</TD></TR><TR CLASS="c"><TD CLASS="l">373</TD><TD>            buffer.append((char) ('0' + digit));</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>            integrals %= divider;</TD></TR><TR CLASS="c"><TD CLASS="l">375</TD><TD>            kappa--;</TD></TR><TR><TD CLASS="l">376</TD><TD>            // Note that kappa now equals the exponent of the divider and that the</TD></TR><TR><TD CLASS="l">377</TD><TD>            // invariant thus holds again.</TD></TR><TR CLASS="c"><TD CLASS="l">378</TD><TD>            long rest =</TD></TR><TR><TD CLASS="l">379</TD><TD>                    ((long)integrals &lt;&lt; -one.e()) + fractionals;</TD></TR><TR><TD CLASS="l">380</TD><TD>            // Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())</TD></TR><TR><TD CLASS="l">381</TD><TD>            // Reminder: unsafe_interval.e() == one.e()</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>            if (rest &lt; unsafe_interval.f()) {</TD></TR><TR><TD CLASS="l">383</TD><TD>                // Rounding down (by not emitting the remaining digits) yields a number</TD></TR><TR><TD CLASS="l">384</TD><TD>                // that lies within the unsafe interval.</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>                buffer.point = buffer.end - mk + kappa;</TD></TR><TR CLASS="c"><TD CLASS="l">386</TD><TD>                return roundWeed(buffer, DiyFp.minus(too_high, w).f(),</TD></TR><TR><TD CLASS="l">387</TD><TD>                        unsafe_interval.f(), rest,</TD></TR><TR><TD CLASS="l">388</TD><TD>                        (long)divider &lt;&lt; -one.e(), unit);</TD></TR><TR><TD CLASS="l">389</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">390</TD><TD>            divider /= 10;</TD></TR><TR CLASS="c"><TD CLASS="l">391</TD><TD>        }</TD></TR><TR><TD CLASS="l">392</TD><TD> </TD></TR><TR><TD CLASS="l">393</TD><TD>        // The integrals have been generated. We are at the point of the decimal</TD></TR><TR><TD CLASS="l">394</TD><TD>        // separator. In the following loop we simply multiply the remaining digits by</TD></TR><TR><TD CLASS="l">395</TD><TD>        // 10 and divide by one. We just need to pay attention to multiply associated</TD></TR><TR><TD CLASS="l">396</TD><TD>        // data (like the interval or 'unit'), too.</TD></TR><TR><TD CLASS="l">397</TD><TD>        // Instead of multiplying by 10 we multiply by 5 (cheaper operation) and</TD></TR><TR><TD CLASS="l">398</TD><TD>        // increase its (imaginary) exponent. At the same time we decrease the</TD></TR><TR><TD CLASS="l">399</TD><TD>        // divider's (one's) exponent and shift its significand.</TD></TR><TR><TD CLASS="l">400</TD><TD>        // Basically, if fractionals was a DiyFp (with fractionals.e == one.e):</TD></TR><TR><TD CLASS="l">401</TD><TD>        //      fractionals.f *= 10;</TD></TR><TR><TD CLASS="l">402</TD><TD>        //      fractionals.f &gt;&gt;= 1; fractionals.e++; // value remains unchanged.</TD></TR><TR><TD CLASS="l">403</TD><TD>        //      one.f &gt;&gt;= 1; one.e++;                 // value remains unchanged.</TD></TR><TR><TD CLASS="l">404</TD><TD>        //      and we have again fractionals.e == one.e which allows us to divide</TD></TR><TR><TD CLASS="l">405</TD><TD>        //           fractionals.f() by one.f()</TD></TR><TR><TD CLASS="l">406</TD><TD>        // We simply combine the *= 10 and the &gt;&gt;= 1.</TD></TR><TR><TD CLASS="l">407</TD><TD>        while (true) {</TD></TR><TR CLASS="c"><TD CLASS="l">408</TD><TD>            fractionals *= 5;</TD></TR><TR CLASS="c"><TD CLASS="l">409</TD><TD>            unit *= 5;</TD></TR><TR CLASS="c"><TD CLASS="l">410</TD><TD>            unsafe_interval.setF(unsafe_interval.f() * 5);</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>            unsafe_interval.setE(unsafe_interval.e() + 1);  // Will be optimized out.</TD></TR><TR CLASS="c"><TD CLASS="l">412</TD><TD>            one.setF(one.f() &gt;&gt;&gt; 1);</TD></TR><TR CLASS="c"><TD CLASS="l">413</TD><TD>            one.setE(one.e() + 1);</TD></TR><TR><TD CLASS="l">414</TD><TD>            // Integer division by one.</TD></TR><TR CLASS="c"><TD CLASS="l">415</TD><TD>            int digit = (int)((fractionals &gt;&gt;&gt; -one.e()) &amp; 0xffffffffL);</TD></TR><TR CLASS="c"><TD CLASS="l">416</TD><TD>            buffer.append((char) ('0' + digit));</TD></TR><TR CLASS="c"><TD CLASS="l">417</TD><TD>            fractionals &amp;= one.f() - 1;  // Modulo by one.</TD></TR><TR CLASS="c"><TD CLASS="l">418</TD><TD>            kappa--;</TD></TR><TR CLASS="c"><TD CLASS="l">419</TD><TD>            if (fractionals &lt; unsafe_interval.f()) {</TD></TR><TR CLASS="c"><TD CLASS="l">420</TD><TD>                buffer.point = buffer.end - mk + kappa;</TD></TR><TR CLASS="c"><TD CLASS="l">421</TD><TD>                return roundWeed(buffer, DiyFp.minus(too_high, w).f() * unit,</TD></TR><TR><TD CLASS="l">422</TD><TD>                        unsafe_interval.f(), fractionals, one.f(), unit);</TD></TR><TR><TD CLASS="l">423</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>        }</TD></TR><TR><TD CLASS="l">425</TD><TD>    }</TD></TR><TR><TD CLASS="l">426</TD><TD> </TD></TR><TR><TD CLASS="l">427</TD><TD> </TD></TR><TR><TD CLASS="l">428</TD><TD>    // Provides a decimal representation of v.</TD></TR><TR><TD CLASS="l">429</TD><TD>    // Returns true if it succeeds, otherwise the result cannot be trusted.</TD></TR><TR><TD CLASS="l">430</TD><TD>    // There will be *length digits inside the buffer (not null-terminated).</TD></TR><TR><TD CLASS="l">431</TD><TD>    // If the function returns true then</TD></TR><TR><TD CLASS="l">432</TD><TD>    //        v == (double) (buffer * 10^decimal_exponent).</TD></TR><TR><TD CLASS="l">433</TD><TD>    // The digits in the buffer are the shortest representation possible: no</TD></TR><TR><TD CLASS="l">434</TD><TD>    // 0.09999999999999999 instead of 0.1. The shorter representation will even be</TD></TR><TR><TD CLASS="l">435</TD><TD>    // chosen even if the longer one would be closer to v.</TD></TR><TR><TD CLASS="l"><A NAME="5">436</A></TD><TD>    // The last digit will be closest to the actual v. That is, even if several</TD></TR><TR><TD CLASS="l">437</TD><TD>    // digits might correctly yield 'v' when read again, the closest will be</TD></TR><TR><TD CLASS="l">438</TD><TD>    // computed.</TD></TR><TR><TD CLASS="l">439</TD><TD>    static boolean grisu3(double v, FastDtoaBuilder buffer) {</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>        long bits = Double.doubleToLongBits(v);</TD></TR><TR CLASS="c"><TD CLASS="l">441</TD><TD>        DiyFp w = DoubleHelper.asNormalizedDiyFp(bits);</TD></TR><TR><TD CLASS="l">442</TD><TD>        // boundary_minus and boundary_plus are the boundaries between v and its</TD></TR><TR><TD CLASS="l">443</TD><TD>        // closest floating-point neighbors. Any number strictly between</TD></TR><TR><TD CLASS="l">444</TD><TD>        // boundary_minus and boundary_plus will round to v when convert to a double.</TD></TR><TR><TD CLASS="l">445</TD><TD>        // Grisu3 will never output representations that lie exactly on a boundary.</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>        DiyFp boundary_minus = new DiyFp(), boundary_plus = new DiyFp();</TD></TR><TR CLASS="c"><TD CLASS="l">447</TD><TD>        DoubleHelper.normalizedBoundaries(bits, boundary_minus, boundary_plus);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="86% line coverage (25 out of 29 instructions)">448</TD><TD TITLE="86% line coverage (25 out of 29 instructions)">        assert(boundary_plus.e() == w.e());</TD></TR><TR CLASS="c"><TD CLASS="l">449</TD><TD>        DiyFp ten_mk = new DiyFp();  // Cached power of ten: 10^-k</TD></TR><TR CLASS="c"><TD CLASS="l">450</TD><TD>        int mk =  CachedPowers.getCachedPower(w.e() + DiyFp.kSignificandSize,</TD></TR><TR><TD CLASS="l">451</TD><TD>                minimal_target_exponent, maximal_target_exponent, ten_mk);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="89% line coverage (33 out of 37 instructions)">452</TD><TD TITLE="89% line coverage (33 out of 37 instructions)">        assert(minimal_target_exponent &lt;= w.e() + ten_mk.e() +</TD></TR><TR><TD CLASS="l">453</TD><TD>                DiyFp.kSignificandSize &amp;&amp;</TD></TR><TR><TD CLASS="l">454</TD><TD>                maximal_target_exponent &gt;= w.e() + ten_mk.e() +</TD></TR><TR><TD CLASS="l">455</TD><TD>                        DiyFp.kSignificandSize);</TD></TR><TR><TD CLASS="l">456</TD><TD>        // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a</TD></TR><TR><TD CLASS="l">457</TD><TD>        // 64 bit significand and ten_mk is thus only precise up to 64 bits.</TD></TR><TR><TD CLASS="l">458</TD><TD> </TD></TR><TR><TD CLASS="l">459</TD><TD>        // The DiyFp::Times procedure rounds its result, and ten_mk is approximated</TD></TR><TR><TD CLASS="l">460</TD><TD>        // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now</TD></TR><TR><TD CLASS="l">461</TD><TD>        // off by a small amount.</TD></TR><TR><TD CLASS="l">462</TD><TD>        // In fact: scaled_w - w*10^k &lt; 1ulp (unit in the last place) of scaled_w.</TD></TR><TR><TD CLASS="l">463</TD><TD>        // In other words: let f = scaled_w.f() and e = scaled_w.e(), then</TD></TR><TR><TD CLASS="l">464</TD><TD>        //           (f-1) * 2^e &lt; w*10^k &lt; (f+1) * 2^e</TD></TR><TR CLASS="c"><TD CLASS="l">465</TD><TD>        DiyFp scaled_w = DiyFp.times(w, ten_mk);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="80% line coverage (16 out of 20 instructions)">466</TD><TD TITLE="80% line coverage (16 out of 20 instructions)">        assert(scaled_w.e() ==</TD></TR><TR><TD CLASS="l">467</TD><TD>                boundary_plus.e() + ten_mk.e() + DiyFp.kSignificandSize);</TD></TR><TR><TD CLASS="l">468</TD><TD>        // In theory it would be possible to avoid some recomputations by computing</TD></TR><TR><TD CLASS="l">469</TD><TD>        // the difference between w and boundary_minus/plus (a power of 2) and to</TD></TR><TR><TD CLASS="l">470</TD><TD>        // compute scaled_boundary_minus/plus by subtracting/adding from</TD></TR><TR><TD CLASS="l">471</TD><TD>        // scaled_w. However the code becomes much less readable and the speed</TD></TR><TR><TD CLASS="l">472</TD><TD>        // enhancements are not terriffic.</TD></TR><TR CLASS="c"><TD CLASS="l">473</TD><TD>        DiyFp scaled_boundary_minus = DiyFp.times(boundary_minus, ten_mk);</TD></TR><TR CLASS="c"><TD CLASS="l">474</TD><TD>        DiyFp scaled_boundary_plus  = DiyFp.times(boundary_plus,  ten_mk);</TD></TR><TR><TD CLASS="l">475</TD><TD> </TD></TR><TR><TD CLASS="l">476</TD><TD>        // DigitGen will generate the digits of scaled_w. Therefore we have</TD></TR><TR><TD CLASS="l">477</TD><TD>        // v == (double) (scaled_w * 10^-mk).</TD></TR><TR><TD CLASS="l">478</TD><TD>        // Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an</TD></TR><TR><TD CLASS="l">479</TD><TD>        // integer than it will be updated. For instance if scaled_w == 1.23 then</TD></TR><TR><TD CLASS="l">480</TD><TD>        // the buffer will be filled with &#34;123&#34; und the decimal_exponent will be</TD></TR><TR><TD CLASS="l">481</TD><TD>        // decreased by 2.</TD></TR><TR CLASS="c"><TD CLASS="l">482</TD><TD>        return digitGen(scaled_boundary_minus, scaled_w, scaled_boundary_plus,</TD></TR><TR><TD CLASS="l">483</TD><TD>                buffer, mk);</TD></TR><TR><TD CLASS="l"><A NAME="2">484</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR><TD CLASS="l">486</TD><TD> </TD></TR><TR><TD CLASS="l">487</TD><TD>    public static boolean dtoa(double v, FastDtoaBuilder buffer) {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="60% line coverage (6 out of 10 instructions)">488</TD><TD TITLE="60% line coverage (6 out of 10 instructions)">        assert(v &gt; 0);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="56% line coverage (5 out of 9 instructions)">489</TD><TD TITLE="56% line coverage (5 out of 9 instructions)">        assert(!Double.isNaN(v));</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="56% line coverage (5 out of 9 instructions)">490</TD><TD TITLE="56% line coverage (5 out of 9 instructions)">        assert(!Double.isInfinite(v));</TD></TR><TR><TD CLASS="l">491</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="8">492</A></TD><TD>        return grisu3(v, buffer);</TD></TR><TR><TD CLASS="l">493</TD><TD>    }</TD></TR><TR><TD CLASS="l">494</TD><TD> </TD></TR><TR><TD CLASS="l">495</TD><TD>    public static String numberToString(double v) {</TD></TR><TR CLASS="c"><TD CLASS="l">496</TD><TD>        FastDtoaBuilder buffer = new FastDtoaBuilder();</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="9">497</A></TD><TD>        return numberToString(v, buffer) ? buffer.format() : null;</TD></TR><TR><TD CLASS="l">498</TD><TD>    }</TD></TR><TR><TD CLASS="l">499</TD><TD> </TD></TR><TR><TD CLASS="l">500</TD><TD>    public static boolean numberToString(double v, FastDtoaBuilder buffer) {</TD></TR><TR CLASS="c"><TD CLASS="l">501</TD><TD>        buffer.reset();</TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>        if (v &lt; 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">503</TD><TD>            buffer.append('-');</TD></TR><TR CLASS="c"><TD CLASS="l">504</TD><TD>            v = -v;</TD></TR><TR><TD CLASS="l">505</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">506</TD><TD>        return dtoa(v, buffer);</TD></TR><TR><TD CLASS="l">507</TD><TD>    }</TD></TR><TR><TD CLASS="l">508</TD><TD> </TD></TR><TR><TD CLASS="l">509</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="12.html">org.mozilla.javascript.v8dtoa</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>