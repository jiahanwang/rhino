<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Mon Oct 27 16:08:44 PDT 2014)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Context.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Context.java</TD><TD>100% (3/3)</TD><TD CLASS="h">66%  (86/131)</TD><TD CLASS="h">54%  (1090/2014)</TD><TD CLASS="h">53%  (274.2/518)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Context</A></TD><TD>100% (1/1)</TD><TD CLASS="h">65%  (82/126)</TD><TD CLASS="h">53%  (1052/1972)</TD><TD CLASS="h">53%  (271.2/514)</TD></TR><TR><TD CLASS="f"><A HREF="#1">Context (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">access$000 (Context): ClassShutter</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3">addActivationName (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">addContextListener (ContextListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#5">addPropertyChangeListener (PropertyChangeListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">call (ContextAction): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#7">compileFunction (Scriptable, String, String, int, Object): Function</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">decompileFunction (Function, int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9">decompileFunctionBody (Function, int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">firePropertyChange (String, Object, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#b">firePropertyChangeImpl (Object, String, Object, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">getDebuggableView (Script): DebuggableScript</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#d">getDebugger (): Debugger</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">getDebuggerContextData (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getImplementationVersion (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getInstructionObserverThreshold (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getThreadLocal (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">isActivationNeeded (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">newObject (Scriptable, String): Scriptable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">notifyDebugger_r (Context, DebuggableScript, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#15">onSealedMutation (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">putThreadLocal (Object, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#17">removeActivationName (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">removeContextListener (ContextListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#19">removePropertyChangeListener (PropertyChangeListener): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">removeThreadLocal (Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">reportError (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">reportRuntimeError3 (String, Object, Object, Object): EvaluatorException</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">reportWarning (String, Throwable): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">seal (Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">setApplicationClassLoader (ClassLoader): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">setCachingEnabled (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#21">setClassShutter (ClassShutter): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">setDebugger (Debugger, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#23">setGeneratingSource (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">setLocale (Locale): Locale</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#25">setMaximumInterpreterStackDepth (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">setSecurityController (SecurityController): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#27">setWrapFactory (WrapFactory): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">stringIsCompilableUnit (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#29">toBoolean (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">toObject (Object, Scriptable, Class): Scriptable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">toType (Object, Class): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">unseal (Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">reportError (String, String, int, String, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">17%  (4/23)</TD><TD CLASS="h">40%  (2/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">checkLanguageVersion (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">25%  (4/16)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">checkOptimizationLevel (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">25%  (4/16)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">setLanguageVersion (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">50%  (14/28)</TD><TD CLASS="h">77%  (5.4/7)</TD></TR><TR><TD CLASS="f"><A HREF="#31">getApplicationClassLoader (): ClassLoader</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">51%  (21/41)</TD><TD CLASS="h">54%  (7/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">throwAsScriptRuntimeEx (Throwable): RuntimeException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">52%  (17/33)</TD><TD CLASS="h">56%  (5/9)</TD></TR><TR><TD CLASS="f"><A HREF="#33">getContext (): Context</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">55%  (6/11)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">reportRuntimeError (String, String, int, String, int): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">59%  (13/22)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR><TD CLASS="f"><A HREF="#35">callFunctionWithContinuations (Callable, Scriptable, Object []): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (16/26)</TD><TD CLASS="h">67%  (4/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">setErrorReporter (ErrorReporter): ErrorReporter</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (21/34)</TD><TD CLASS="h">71%  (7.1/10)</TD></TR><TR><TD CLASS="f"><A HREF="#37">setGeneratingDebug (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">63%  (12/19)</TD><TD CLASS="h">73%  (4.4/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">enter (Context, ContextFactory): Context</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">66%  (38/58)</TD><TD CLASS="h">73%  (11.7/16)</TD></TR><TR><TD CLASS="f"><A HREF="#39">isValidLanguageVersion (int): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">67%  (4/6)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">reportWarning (String, String, int, String, int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">68%  (15/22)</TD><TD>80%  (4/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">compileImpl (Scriptable, Reader, String, String, int, Object, boolean, Evalua...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">71%  (126/177)</TD><TD CLASS="h">72%  (30/42)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">setInstructionObserverThreshold (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">71%  (15/21)</TD><TD CLASS="h">80%  (4/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">compileFunction (Scriptable, String, Evaluator, ErrorReporter, String, int, O...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">72%  (13/18)</TD><TD CLASS="h">33%  (1/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">compileString (String, Evaluator, ErrorReporter, String, int, Object): Script</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">72%  (13/18)</TD><TD CLASS="h">33%  (1/3)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">executeScriptWithContinuations (Script, Scriptable): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">74%  (14/19)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">setOptimizationLevel (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">74%  (14/19)</TD><TD CLASS="h">72%  (5.8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#41">getSecurityController (): SecurityController</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">78%  (7/9)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">javaToJS (Object, Scriptable): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">78%  (25/32)</TD><TD CLASS="h">67%  (4/6)</TD></TR><TR><TD CLASS="f"><A HREF="#43">newArray (Scriptable, Object []): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>80%  (16/20)</TD><TD>80%  (4/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">exit (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>81%  (30/37)</TD><TD>85%  (7.7/9)</TD></TR><TR><TD CLASS="f"><A HREF="#45">Context (ContextFactory): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>81%  (26/32)</TD><TD>89%  (8.9/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">compileString (String, String, int, Object): Script</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>85%  (11/13)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR><TD CLASS="f"><A HREF="#47">getClassShutterSetter (): Context$ClassShutterSetter</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>85%  (11/13)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">call (ContextFactory, Callable, Scriptable, Scriptable, Object []): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>86%  (12/14)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR><TD CLASS="f"><A HREF="#49">evaluateString (Scriptable, String, String, int, Object): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (14/16)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">compileReader (Reader, String, int, Object): Script</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (15/17)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">evaluateReader (Scriptable, Reader, String, int, Object): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (15/17)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">newObject (Scriptable, String, Object []): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>89%  (16/18)</TD><TD>96%  (3.8/4)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">isValidOptimizationLevel (int): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>90%  (9/10)</TD><TD>90%  (0.9/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">getSourcePositionFromStack (int []): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (124/131)</TD><TD>91%  (30/33)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">access$002 (Context, ClassShutter): ClassShutter</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#51">call (ContextFactory, ContextAction): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">captureContinuation (): ContinuationPending</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#53">compileReader (Scriptable, Reader, String, int, Object): Script</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">createClassLoader (ClassLoader): GeneratedClassLoader</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#55">createCompiler (): Evaluator</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (17/17)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">createInterpreter (): Evaluator</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#57">decompileScript (Script, int): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#58">enter (): Context</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#59">enter (Context): Context</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">getClassShutter (): ClassShutter</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">getCurrentContext (): Context</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">getE4xImplementationFactory (): XMLLib$Factory</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">getElements (Scriptable): Object []</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">getErrorReporter (): ErrorReporter</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#5f">getFactory (): ContextFactory</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#60">getLanguageVersion (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#61">getLocale (): Locale</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">getMaximumInterpreterStackDepth (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#63">getOptimizationLevel (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#64">getRegExpProxy (): RegExpProxy</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (16/16)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#65">getUndefinedValue (): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (2/2)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#66">getWrapFactory (): WrapFactory</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#67">hasFeature (int): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#68">initStandardObjects (): ScriptableObject</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#69">initStandardObjects (ScriptableObject): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6a">initStandardObjects (ScriptableObject, boolean): ScriptableObject</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6b">isGeneratingDebug (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6c">isGeneratingDebugChanged (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6d">isGeneratingSource (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6e">isSealed (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6f">isVersionECMA1 (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#70">jsToJava (Object, Class): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#71">newArray (Scriptable, int): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (12/12)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#72">newObject (Scriptable): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#73">observeInstructionCount (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#74">reportRuntimeError (String): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#75">reportRuntimeError0 (String): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#76">reportRuntimeError1 (String, Object): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (7/7)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#77">reportRuntimeError2 (String, Object, Object): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#78">reportRuntimeError4 (String, Object, Object, Object, Object): EvaluatorException</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#79">reportWarning (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7a">resumeContinuation (Object, Scriptable, Object): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (14/14)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7b">setGenerateObserverCount (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7c">toNumber (Object): double</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#7d">toObject (Object, Scriptable): Scriptable</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7e">toString (Object): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#7f">Context$2</A></TD><TD>100% (1/1)</TD><TD CLASS="h">67%  (2/3)</TD><TD CLASS="h">75%  (12/16)</TD><TD CLASS="h">75%  (3/4)</TD></TR><TR><TD CLASS="f"><A HREF="#80">getClassShutter (): ClassShutter</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7f">Context$2 (Context): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#82">setClassShutter (ClassShutter): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#83">Context$1</A></TD><TD>100% (1/1)</TD><TD>100% (2/2)</TD><TD>100% (26/26)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#83">Context$1 (Callable, Scriptable, Scriptable, Object []): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#85">run (Context): Object</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</TD></TR><TR><TD CLASS="l">2</TD><TD> *</TD></TR><TR><TD CLASS="l">3</TD><TD> * This Source Code Form is subject to the terms of the Mozilla Public</TD></TR><TR><TD CLASS="l">4</TD><TD> * License, v. 2.0. If a copy of the MPL was not distributed with this</TD></TR><TR><TD CLASS="l">5</TD><TD> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</TD></TR><TR><TD CLASS="l">6</TD><TD> </TD></TR><TR><TD CLASS="l">7</TD><TD>// API class</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>package org.mozilla.javascript;</TD></TR><TR><TD CLASS="l">10</TD><TD> </TD></TR><TR><TD CLASS="l">11</TD><TD>import java.beans.PropertyChangeEvent;</TD></TR><TR><TD CLASS="l">12</TD><TD>import java.beans.PropertyChangeListener;</TD></TR><TR><TD CLASS="l">13</TD><TD>import java.io.CharArrayWriter;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">15</TD><TD>import java.io.PrintWriter;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.io.Reader;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.io.StringWriter;</TD></TR><TR><TD CLASS="l">18</TD><TD>import java.io.Writer;</TD></TR><TR><TD CLASS="l">19</TD><TD>import java.lang.reflect.InvocationTargetException;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.lang.reflect.Method;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.util.Locale;</TD></TR><TR><TD CLASS="l">26</TD><TD> </TD></TR><TR><TD CLASS="l">27</TD><TD>import org.mozilla.javascript.ast.AstRoot;</TD></TR><TR><TD CLASS="l">28</TD><TD>import org.mozilla.javascript.ast.ScriptNode;</TD></TR><TR><TD CLASS="l">29</TD><TD>import org.mozilla.javascript.debug.DebuggableScript;</TD></TR><TR><TD CLASS="l">30</TD><TD>import org.mozilla.javascript.debug.Debugger;</TD></TR><TR><TD CLASS="l">31</TD><TD>import org.mozilla.javascript.xml.XMLLib;</TD></TR><TR><TD CLASS="l">32</TD><TD> </TD></TR><TR><TD CLASS="l">33</TD><TD>/**</TD></TR><TR><TD CLASS="l">34</TD><TD> * This class represents the runtime context of an executing script.</TD></TR><TR><TD CLASS="l">35</TD><TD> *</TD></TR><TR><TD CLASS="l">36</TD><TD> * Before executing a script, an instance of Context must be created</TD></TR><TR><TD CLASS="l">37</TD><TD> * and associated with the thread that will be executing the script.</TD></TR><TR><TD CLASS="l">38</TD><TD> * The Context will be used to store information about the executing</TD></TR><TR><TD CLASS="l">39</TD><TD> * of the script such as the call stack. Contexts are associated with</TD></TR><TR><TD CLASS="l">40</TD><TD> * the current thread  using the {@link #call(ContextAction)}</TD></TR><TR><TD CLASS="l">41</TD><TD> * or {@link #enter()} methods.&lt;p&gt;</TD></TR><TR><TD CLASS="l">42</TD><TD> *</TD></TR><TR><TD CLASS="l">43</TD><TD> * Different forms of script execution are supported. Scripts may be</TD></TR><TR><TD CLASS="l">44</TD><TD> * evaluated from the source directly, or first compiled and then later</TD></TR><TR><TD CLASS="l">45</TD><TD> * executed. Interactive execution is also supported.&lt;p&gt;</TD></TR><TR><TD CLASS="l">46</TD><TD> *</TD></TR><TR><TD CLASS="l">47</TD><TD> * Some aspects of script execution, such as type conversions and</TD></TR><TR><TD CLASS="l">48</TD><TD> * object creation, may be accessed directly through methods of</TD></TR><TR><TD CLASS="l">49</TD><TD> * Context.</TD></TR><TR><TD CLASS="l">50</TD><TD> *</TD></TR><TR><TD CLASS="l">51</TD><TD> * @see Scriptable</TD></TR><TR><TD CLASS="l"><A NAME="0">52</A></TD><TD> * @author Norris Boyd</TD></TR><TR><TD CLASS="l">53</TD><TD> * @author Brendan Eich</TD></TR><TR><TD CLASS="l">54</TD><TD> */</TD></TR><TR><TD CLASS="l">55</TD><TD> </TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="62% line coverage (5 out of 8 instructions)">56</TD><TD TITLE="62% line coverage (5 out of 8 instructions)">public class Context</TD></TR><TR><TD CLASS="l">57</TD><TD>{</TD></TR><TR><TD CLASS="l">58</TD><TD>    /**</TD></TR><TR><TD CLASS="l">59</TD><TD>     * Language versions.</TD></TR><TR><TD CLASS="l">60</TD><TD>     *</TD></TR><TR><TD CLASS="l">61</TD><TD>     * All integral values are reserved for future version numbers.</TD></TR><TR><TD CLASS="l">62</TD><TD>     */</TD></TR><TR><TD CLASS="l">63</TD><TD> </TD></TR><TR><TD CLASS="l">64</TD><TD>    /**</TD></TR><TR><TD CLASS="l">65</TD><TD>     * The unknown version.</TD></TR><TR><TD CLASS="l">66</TD><TD>     */</TD></TR><TR><TD CLASS="l">67</TD><TD>    public static final int VERSION_UNKNOWN =   -1;</TD></TR><TR><TD CLASS="l">68</TD><TD> </TD></TR><TR><TD CLASS="l">69</TD><TD>    /**</TD></TR><TR><TD CLASS="l">70</TD><TD>     * The default version.</TD></TR><TR><TD CLASS="l">71</TD><TD>     */</TD></TR><TR><TD CLASS="l">72</TD><TD>    public static final int VERSION_DEFAULT =    0;</TD></TR><TR><TD CLASS="l">73</TD><TD> </TD></TR><TR><TD CLASS="l">74</TD><TD>    /**</TD></TR><TR><TD CLASS="l">75</TD><TD>     * JavaScript 1.0</TD></TR><TR><TD CLASS="l">76</TD><TD>     */</TD></TR><TR><TD CLASS="l">77</TD><TD>    public static final int VERSION_1_0 =      100;</TD></TR><TR><TD CLASS="l">78</TD><TD> </TD></TR><TR><TD CLASS="l">79</TD><TD>    /**</TD></TR><TR><TD CLASS="l">80</TD><TD>     * JavaScript 1.1</TD></TR><TR><TD CLASS="l">81</TD><TD>     */</TD></TR><TR><TD CLASS="l">82</TD><TD>    public static final int VERSION_1_1 =      110;</TD></TR><TR><TD CLASS="l">83</TD><TD> </TD></TR><TR><TD CLASS="l">84</TD><TD>    /**</TD></TR><TR><TD CLASS="l">85</TD><TD>     * JavaScript 1.2</TD></TR><TR><TD CLASS="l">86</TD><TD>     */</TD></TR><TR><TD CLASS="l">87</TD><TD>    public static final int VERSION_1_2 =      120;</TD></TR><TR><TD CLASS="l">88</TD><TD> </TD></TR><TR><TD CLASS="l">89</TD><TD>    /**</TD></TR><TR><TD CLASS="l">90</TD><TD>     * JavaScript 1.3</TD></TR><TR><TD CLASS="l">91</TD><TD>     */</TD></TR><TR><TD CLASS="l">92</TD><TD>    public static final int VERSION_1_3 =      130;</TD></TR><TR><TD CLASS="l">93</TD><TD> </TD></TR><TR><TD CLASS="l">94</TD><TD>    /**</TD></TR><TR><TD CLASS="l">95</TD><TD>     * JavaScript 1.4</TD></TR><TR><TD CLASS="l">96</TD><TD>     */</TD></TR><TR><TD CLASS="l">97</TD><TD>    public static final int VERSION_1_4 =      140;</TD></TR><TR><TD CLASS="l">98</TD><TD> </TD></TR><TR><TD CLASS="l">99</TD><TD>    /**</TD></TR><TR><TD CLASS="l">100</TD><TD>     * JavaScript 1.5</TD></TR><TR><TD CLASS="l">101</TD><TD>     */</TD></TR><TR><TD CLASS="l">102</TD><TD>    public static final int VERSION_1_5 =      150;</TD></TR><TR><TD CLASS="l">103</TD><TD> </TD></TR><TR><TD CLASS="l">104</TD><TD>    /**</TD></TR><TR><TD CLASS="l">105</TD><TD>     * JavaScript 1.6</TD></TR><TR><TD CLASS="l">106</TD><TD>     */</TD></TR><TR><TD CLASS="l">107</TD><TD>    public static final int VERSION_1_6 =      160;</TD></TR><TR><TD CLASS="l">108</TD><TD> </TD></TR><TR><TD CLASS="l">109</TD><TD>    /**</TD></TR><TR><TD CLASS="l">110</TD><TD>     * JavaScript 1.7</TD></TR><TR><TD CLASS="l">111</TD><TD>     */</TD></TR><TR><TD CLASS="l">112</TD><TD>    public static final int VERSION_1_7 =      170;</TD></TR><TR><TD CLASS="l">113</TD><TD> </TD></TR><TR><TD CLASS="l">114</TD><TD>    /**</TD></TR><TR><TD CLASS="l">115</TD><TD>     * JavaScript 1.8</TD></TR><TR><TD CLASS="l">116</TD><TD>     */</TD></TR><TR><TD CLASS="l">117</TD><TD>    public static final int VERSION_1_8 =      180;</TD></TR><TR><TD CLASS="l">118</TD><TD> </TD></TR><TR><TD CLASS="l">119</TD><TD>    /**</TD></TR><TR><TD CLASS="l">120</TD><TD>     * Controls behaviour of &lt;tt&gt;Date.prototype.getYear()&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">121</TD><TD>     * If &lt;tt&gt;hasFeature(FEATURE_NON_ECMA_GET_YEAR)&lt;/tt&gt; returns true,</TD></TR><TR><TD CLASS="l">122</TD><TD>     * Date.prototype.getYear subtructs 1900 only if 1900 &lt;= date &lt; 2000.</TD></TR><TR><TD CLASS="l">123</TD><TD>     * The default behavior of {@link #hasFeature(int)} is always to subtruct</TD></TR><TR><TD CLASS="l">124</TD><TD>     * 1900 as rquired by ECMAScript B.2.4.</TD></TR><TR><TD CLASS="l">125</TD><TD>     */</TD></TR><TR><TD CLASS="l">126</TD><TD>    public static final int FEATURE_NON_ECMA_GET_YEAR = 1;</TD></TR><TR><TD CLASS="l">127</TD><TD> </TD></TR><TR><TD CLASS="l">128</TD><TD>    /**</TD></TR><TR><TD CLASS="l">129</TD><TD>     * Control if member expression as function name extension is available.</TD></TR><TR><TD CLASS="l">130</TD><TD>     * If &lt;tt&gt;hasFeature(FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME)&lt;/tt&gt; returns</TD></TR><TR><TD CLASS="l">131</TD><TD>     * true, allow &lt;tt&gt;function memberExpression(args) { body }&lt;/tt&gt; to be</TD></TR><TR><TD CLASS="l">132</TD><TD>     * syntax sugar for &lt;tt&gt;memberExpression = function(args) { body }&lt;/tt&gt;,</TD></TR><TR><TD CLASS="l">133</TD><TD>     * when memberExpression is not a simple identifier.</TD></TR><TR><TD CLASS="l">134</TD><TD>     * See ECMAScript-262, section 11.2 for definition of memberExpression.</TD></TR><TR><TD CLASS="l">135</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">136</TD><TD>     */</TD></TR><TR><TD CLASS="l">137</TD><TD>    public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;</TD></TR><TR><TD CLASS="l">138</TD><TD> </TD></TR><TR><TD CLASS="l">139</TD><TD>    /**</TD></TR><TR><TD CLASS="l">140</TD><TD>     * Control if reserved keywords are treated as identifiers.</TD></TR><TR><TD CLASS="l">141</TD><TD>     * If &lt;tt&gt;hasFeature(RESERVED_KEYWORD_AS_IDENTIFIER)&lt;/tt&gt; returns true,</TD></TR><TR><TD CLASS="l">142</TD><TD>     * treat future reserved keyword (see  Ecma-262, section 7.5.3) as ordinary</TD></TR><TR><TD CLASS="l">143</TD><TD>     * identifiers but warn about this usage.</TD></TR><TR><TD CLASS="l">144</TD><TD>     *</TD></TR><TR><TD CLASS="l">145</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">146</TD><TD>     */</TD></TR><TR><TD CLASS="l">147</TD><TD>    public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;</TD></TR><TR><TD CLASS="l">148</TD><TD> </TD></TR><TR><TD CLASS="l">149</TD><TD>    /**</TD></TR><TR><TD CLASS="l">150</TD><TD>     * Control if &lt;tt&gt;toString()&lt;/tt&gt; should returns the same result</TD></TR><TR><TD CLASS="l">151</TD><TD>     * as  &lt;tt&gt;toSource()&lt;/tt&gt; when applied to objects and arrays.</TD></TR><TR><TD CLASS="l">152</TD><TD>     * If &lt;tt&gt;hasFeature(FEATURE_TO_STRING_AS_SOURCE)&lt;/tt&gt; returns true,</TD></TR><TR><TD CLASS="l">153</TD><TD>     * calling &lt;tt&gt;toString()&lt;/tt&gt; on JS objects gives the same result as</TD></TR><TR><TD CLASS="l">154</TD><TD>     * calling &lt;tt&gt;toSource()&lt;/tt&gt;. That is it returns JS source with code</TD></TR><TR><TD CLASS="l">155</TD><TD>     * to create an object with all enumeratable fields of the original object</TD></TR><TR><TD CLASS="l">156</TD><TD>     * instead of printing &lt;tt&gt;[object &lt;i&gt;result of</TD></TR><TR><TD CLASS="l">157</TD><TD>     * {@link Scriptable#getClassName()}&lt;/i&gt;]&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">158</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">159</TD><TD>     * By default {@link #hasFeature(int)} returns true only if</TD></TR><TR><TD CLASS="l">160</TD><TD>     * the current JS version is set to {@link #VERSION_1_2}.</TD></TR><TR><TD CLASS="l">161</TD><TD>     */</TD></TR><TR><TD CLASS="l">162</TD><TD>    public static final int FEATURE_TO_STRING_AS_SOURCE = 4;</TD></TR><TR><TD CLASS="l">163</TD><TD> </TD></TR><TR><TD CLASS="l">164</TD><TD>    /**</TD></TR><TR><TD CLASS="l">165</TD><TD>     * Control if properties &lt;tt&gt;__proto__&lt;/tt&gt; and &lt;tt&gt;__parent__&lt;/tt&gt;</TD></TR><TR><TD CLASS="l">166</TD><TD>     * are treated specially.</TD></TR><TR><TD CLASS="l">167</TD><TD>     * If &lt;tt&gt;hasFeature(FEATURE_PARENT_PROTO_PROPERTIES)&lt;/tt&gt; returns true,</TD></TR><TR><TD CLASS="l">168</TD><TD>     * treat &lt;tt&gt;__parent__&lt;/tt&gt; and &lt;tt&gt;__proto__&lt;/tt&gt; as special properties.</TD></TR><TR><TD CLASS="l">169</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">170</TD><TD>     * The properties allow to query and set scope and prototype chains for the</TD></TR><TR><TD CLASS="l">171</TD><TD>     * objects. The special meaning of the properties is available</TD></TR><TR><TD CLASS="l">172</TD><TD>     * only when they are used as the right hand side of the dot operator.</TD></TR><TR><TD CLASS="l">173</TD><TD>     * For example, while &lt;tt&gt;x.__proto__ = y&lt;/tt&gt; changes the prototype</TD></TR><TR><TD CLASS="l">174</TD><TD>     * chain of the object &lt;tt&gt;x&lt;/tt&gt; to point to &lt;tt&gt;y&lt;/tt&gt;,</TD></TR><TR><TD CLASS="l">175</TD><TD>     * &lt;tt&gt;x[&#34;__proto__&#34;] = y&lt;/tt&gt; simply assigns a new value to the property</TD></TR><TR><TD CLASS="l">176</TD><TD>     * &lt;tt&gt;__proto__&lt;/tt&gt; in &lt;tt&gt;x&lt;/tt&gt; even when the feature is on.</TD></TR><TR><TD CLASS="l">177</TD><TD>     *</TD></TR><TR><TD CLASS="l">178</TD><TD>     * By default {@link #hasFeature(int)} returns true.</TD></TR><TR><TD CLASS="l">179</TD><TD>     */</TD></TR><TR><TD CLASS="l">180</TD><TD>    public static final int FEATURE_PARENT_PROTO_PROPERTIES = 5;</TD></TR><TR><TD CLASS="l">181</TD><TD> </TD></TR><TR><TD CLASS="l">182</TD><TD>        /**</TD></TR><TR><TD CLASS="l">183</TD><TD>         * @deprecated In previous releases, this name was given to</TD></TR><TR><TD CLASS="l">184</TD><TD>         * FEATURE_PARENT_PROTO_PROPERTIES.</TD></TR><TR><TD CLASS="l">185</TD><TD>         */</TD></TR><TR><TD CLASS="l">186</TD><TD>    public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;</TD></TR><TR><TD CLASS="l">187</TD><TD> </TD></TR><TR><TD CLASS="l">188</TD><TD>    /**</TD></TR><TR><TD CLASS="l">189</TD><TD>     * Control if support for E4X(ECMAScript for XML) extension is available.</TD></TR><TR><TD CLASS="l">190</TD><TD>     * If hasFeature(FEATURE_E4X) returns true, the XML syntax is available.</TD></TR><TR><TD CLASS="l">191</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">192</TD><TD>     * By default {@link #hasFeature(int)} returns true if</TD></TR><TR><TD CLASS="l">193</TD><TD>     * the current JS version is set to {@link #VERSION_DEFAULT}</TD></TR><TR><TD CLASS="l">194</TD><TD>     * or is at least {@link #VERSION_1_6}.</TD></TR><TR><TD CLASS="l">195</TD><TD>     * @since 1.6 Release 1</TD></TR><TR><TD CLASS="l">196</TD><TD>     */</TD></TR><TR><TD CLASS="l">197</TD><TD>    public static final int FEATURE_E4X = 6;</TD></TR><TR><TD CLASS="l">198</TD><TD> </TD></TR><TR><TD CLASS="l">199</TD><TD>    /**</TD></TR><TR><TD CLASS="l">200</TD><TD>     * Control if dynamic scope should be used for name access.</TD></TR><TR><TD CLASS="l">201</TD><TD>     * If hasFeature(FEATURE_DYNAMIC_SCOPE) returns true, then the name lookup</TD></TR><TR><TD CLASS="l">202</TD><TD>     * during name resolution will use the top scope of the script or function</TD></TR><TR><TD CLASS="l">203</TD><TD>     * which is at the top of JS execution stack instead of the top scope of the</TD></TR><TR><TD CLASS="l">204</TD><TD>     * script or function from the current stack frame if the top scope of</TD></TR><TR><TD CLASS="l">205</TD><TD>     * the top stack frame contains the top scope of the current stack frame</TD></TR><TR><TD CLASS="l">206</TD><TD>     * on its prototype chain.</TD></TR><TR><TD CLASS="l">207</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">208</TD><TD>     * This is useful to define shared scope containing functions that can</TD></TR><TR><TD CLASS="l">209</TD><TD>     * be called from scripts and functions using private scopes.</TD></TR><TR><TD CLASS="l">210</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">211</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">212</TD><TD>     * @since 1.6 Release 1</TD></TR><TR><TD CLASS="l">213</TD><TD>     */</TD></TR><TR><TD CLASS="l">214</TD><TD>    public static final int FEATURE_DYNAMIC_SCOPE = 7;</TD></TR><TR><TD CLASS="l">215</TD><TD> </TD></TR><TR><TD CLASS="l">216</TD><TD>    /**</TD></TR><TR><TD CLASS="l">217</TD><TD>     * Control if strict variable mode is enabled.</TD></TR><TR><TD CLASS="l">218</TD><TD>     * When the feature is on Rhino reports runtime errors if assignment</TD></TR><TR><TD CLASS="l">219</TD><TD>     * to a global variable that does not exist is executed. When the feature</TD></TR><TR><TD CLASS="l">220</TD><TD>     * is off such assignments create a new variable in the global scope as</TD></TR><TR><TD CLASS="l">221</TD><TD>     * required by ECMA 262.</TD></TR><TR><TD CLASS="l">222</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">223</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">224</TD><TD>     * @since 1.6 Release 1</TD></TR><TR><TD CLASS="l">225</TD><TD>     */</TD></TR><TR><TD CLASS="l">226</TD><TD>    public static final int FEATURE_STRICT_VARS = 8;</TD></TR><TR><TD CLASS="l">227</TD><TD> </TD></TR><TR><TD CLASS="l">228</TD><TD>    /**</TD></TR><TR><TD CLASS="l">229</TD><TD>     * Control if strict eval mode is enabled.</TD></TR><TR><TD CLASS="l">230</TD><TD>     * When the feature is on Rhino reports runtime errors if non-string</TD></TR><TR><TD CLASS="l">231</TD><TD>     * argument is passed to the eval function. When the feature is off</TD></TR><TR><TD CLASS="l">232</TD><TD>     * eval simply return non-string argument as is without performing any</TD></TR><TR><TD CLASS="l">233</TD><TD>     * evaluation as required by ECMA 262.</TD></TR><TR><TD CLASS="l">234</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">235</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">236</TD><TD>     * @since 1.6 Release 1</TD></TR><TR><TD CLASS="l">237</TD><TD>     */</TD></TR><TR><TD CLASS="l">238</TD><TD>    public static final int FEATURE_STRICT_EVAL = 9;</TD></TR><TR><TD CLASS="l">239</TD><TD> </TD></TR><TR><TD CLASS="l">240</TD><TD>    /**</TD></TR><TR><TD CLASS="l">241</TD><TD>     * When the feature is on Rhino will add a &#34;fileName&#34; and &#34;lineNumber&#34;</TD></TR><TR><TD CLASS="l">242</TD><TD>     * properties to Error objects automatically. When the feature is off, you</TD></TR><TR><TD CLASS="l">243</TD><TD>     * have to explicitly pass them as the second and third argument to the</TD></TR><TR><TD CLASS="l">244</TD><TD>     * Error constructor. Note that neither behavior is fully ECMA 262</TD></TR><TR><TD CLASS="l">245</TD><TD>     * compliant (as 262 doesn't specify a three-arg constructor), but keeping</TD></TR><TR><TD CLASS="l">246</TD><TD>     * the feature off results in Error objects that don't have</TD></TR><TR><TD CLASS="l">247</TD><TD>     * additional non-ECMA properties when constructed using the ECMA-defined</TD></TR><TR><TD CLASS="l">248</TD><TD>     * single-arg constructor and is thus desirable if a stricter ECMA</TD></TR><TR><TD CLASS="l">249</TD><TD>     * compliance is desired, specifically adherence to the point 15.11.5. of</TD></TR><TR><TD CLASS="l">250</TD><TD>     * the standard.</TD></TR><TR><TD CLASS="l">251</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">252</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">253</TD><TD>     * @since 1.6 Release 6</TD></TR><TR><TD CLASS="l">254</TD><TD>     */</TD></TR><TR><TD CLASS="l">255</TD><TD>    public static final int FEATURE_LOCATION_INFORMATION_IN_ERROR = 10;</TD></TR><TR><TD CLASS="l">256</TD><TD> </TD></TR><TR><TD CLASS="l">257</TD><TD>    /**</TD></TR><TR><TD CLASS="l">258</TD><TD>     * Controls whether JS 1.5 'strict mode' is enabled.</TD></TR><TR><TD CLASS="l">259</TD><TD>     * When the feature is on, Rhino reports more than a dozen different</TD></TR><TR><TD CLASS="l">260</TD><TD>     * warnings.  When the feature is off, these warnings are not generated.</TD></TR><TR><TD CLASS="l">261</TD><TD>     * FEATURE_STRICT_MODE implies FEATURE_STRICT_VARS and FEATURE_STRICT_EVAL.</TD></TR><TR><TD CLASS="l">262</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">263</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">264</TD><TD>     * @since 1.6 Release 6</TD></TR><TR><TD CLASS="l">265</TD><TD>     */</TD></TR><TR><TD CLASS="l">266</TD><TD>    public static final int FEATURE_STRICT_MODE = 11;</TD></TR><TR><TD CLASS="l">267</TD><TD> </TD></TR><TR><TD CLASS="l">268</TD><TD>    /**</TD></TR><TR><TD CLASS="l">269</TD><TD>     * Controls whether a warning should be treated as an error.</TD></TR><TR><TD CLASS="l">270</TD><TD>     * @since 1.6 Release 6</TD></TR><TR><TD CLASS="l">271</TD><TD>     */</TD></TR><TR><TD CLASS="l">272</TD><TD>    public static final int FEATURE_WARNING_AS_ERROR = 12;</TD></TR><TR><TD CLASS="l">273</TD><TD> </TD></TR><TR><TD CLASS="l">274</TD><TD>    /**</TD></TR><TR><TD CLASS="l">275</TD><TD>     * Enables enhanced access to Java.</TD></TR><TR><TD CLASS="l">276</TD><TD>     * Specifically, controls whether private and protected members can be</TD></TR><TR><TD CLASS="l">277</TD><TD>     * accessed, and whether scripts can catch all Java exceptions.</TD></TR><TR><TD CLASS="l">278</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">279</TD><TD>     * Note that this feature should only be enabled for trusted scripts.</TD></TR><TR><TD CLASS="l">280</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">281</TD><TD>     * By default {@link #hasFeature(int)} returns false.</TD></TR><TR><TD CLASS="l">282</TD><TD>     * @since 1.7 Release 1</TD></TR><TR><TD CLASS="l">283</TD><TD>     */</TD></TR><TR><TD CLASS="l">284</TD><TD>    public static final int FEATURE_ENHANCED_JAVA_ACCESS = 13;</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR><TD CLASS="l">286</TD><TD>    public static final String languageVersionProperty = &#34;language version&#34;;</TD></TR><TR><TD CLASS="l">287</TD><TD>    public static final String errorReporterProperty   = &#34;error reporter&#34;;</TD></TR><TR><TD CLASS="l"><A NAME="4f">288</A></TD><TD> </TD></TR><TR><TD CLASS="l">289</TD><TD>    /**</TD></TR><TR><TD CLASS="l">290</TD><TD>     * Convenient value to use as zero-length array of objects.</TD></TR><TR><TD CLASS="l">291</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">292</TD><TD>    public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;</TD></TR><TR><TD CLASS="l">293</TD><TD> </TD></TR><TR><TD CLASS="l">294</TD><TD>    /**</TD></TR><TR><TD CLASS="l">295</TD><TD>     * Creates a new Context. The context will be associated with the {@link</TD></TR><TR><TD CLASS="l">296</TD><TD>     * ContextFactory#getGlobal() global context factory}.</TD></TR><TR><TD CLASS="l">297</TD><TD>     *</TD></TR><TR><TD CLASS="l">298</TD><TD>     * Note that the Context must be associated with a thread before</TD></TR><TR><TD CLASS="l">299</TD><TD>     * it can be used to execute a script.</TD></TR><TR><TD CLASS="l">300</TD><TD>     * @deprecated this constructor is deprecated because it creates a</TD></TR><TR><TD CLASS="l">301</TD><TD>     * dependency on a static singleton context factory. Use</TD></TR><TR><TD CLASS="l">302</TD><TD>     * {@link ContextFactory#enter()} or</TD></TR><TR><TD CLASS="l">303</TD><TD>     * {@link ContextFactory#call(ContextAction)} instead. If you subclass</TD></TR><TR><TD CLASS="l">304</TD><TD>     * this class, consider using {@link #Context(ContextFactory)} constructor</TD></TR><TR><TD CLASS="l"><A NAME="1">305</A></TD><TD>     * instead in the subclasses' constructors.</TD></TR><TR><TD CLASS="l">306</TD><TD>     */</TD></TR><TR><TD CLASS="l">307</TD><TD>    public Context()</TD></TR><TR><TD CLASS="l">308</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">309</TD><TD>        this(ContextFactory.getGlobal());</TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>    }</TD></TR><TR><TD CLASS="l">311</TD><TD> </TD></TR><TR><TD CLASS="l">312</TD><TD>    /**</TD></TR><TR><TD CLASS="l">313</TD><TD>     * Creates a new context. Provided as a preferred super constructor for</TD></TR><TR><TD CLASS="l">314</TD><TD>     * subclasses in place of the deprecated default public constructor.</TD></TR><TR><TD CLASS="l">315</TD><TD>     * @param factory the context factory associated with this context (most</TD></TR><TR><TD CLASS="l">316</TD><TD>     * likely, the one that created the context). Can not be null. The context</TD></TR><TR><TD CLASS="l">317</TD><TD>     * features are inherited from the factory, and the context will also</TD></TR><TR><TD CLASS="l"><A NAME="45">318</A></TD><TD>     * otherwise use its factory's services.</TD></TR><TR><TD CLASS="l">319</TD><TD>     * @throws IllegalArgumentException if factory parameter is null.</TD></TR><TR><TD CLASS="l">320</TD><TD>     */</TD></TR><TR><TD CLASS="l">321</TD><TD>    protected Context(ContextFactory factory)</TD></TR><TR CLASS="c"><TD CLASS="l">322</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">323</TD><TD>        if(factory == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>            throw new IllegalArgumentException(&#34;factory == null&#34;);</TD></TR><TR><TD CLASS="l">325</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">326</TD><TD>        this.factory = factory;</TD></TR><TR CLASS="c"><TD CLASS="l">327</TD><TD>        version = VERSION_DEFAULT;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="94% line coverage (16 out of 17 instructions)">328</TD><TD TITLE="94% line coverage (16 out of 17 instructions)">        optimizationLevel = codegenClass != null ? 0 : -1;</TD></TR><TR CLASS="c"><TD CLASS="l">329</TD><TD>        maximumInterpreterStackDepth = Integer.MAX_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>    }</TD></TR><TR><TD CLASS="l">331</TD><TD> </TD></TR><TR><TD CLASS="l">332</TD><TD>    /**</TD></TR><TR><TD CLASS="l">333</TD><TD>     * Get the current Context.</TD></TR><TR><TD CLASS="l">334</TD><TD>     *</TD></TR><TR><TD CLASS="l">335</TD><TD>     * The current Context is per-thread; this method looks up</TD></TR><TR><TD CLASS="l">336</TD><TD>     * the Context associated with the current thread. &lt;p&gt;</TD></TR><TR><TD CLASS="l">337</TD><TD>     *</TD></TR><TR><TD CLASS="l">338</TD><TD>     * @return the Context associated with the current thread, or</TD></TR><TR><TD CLASS="l">339</TD><TD>     *         null if no context is associated with the current</TD></TR><TR><TD CLASS="l">340</TD><TD>     *         thread.</TD></TR><TR><TD CLASS="l">341</TD><TD>     * @see ContextFactory#enterContext()</TD></TR><TR><TD CLASS="l"><A NAME="5b">342</A></TD><TD>     * @see ContextFactory#call(ContextAction)</TD></TR><TR><TD CLASS="l">343</TD><TD>     */</TD></TR><TR><TD CLASS="l">344</TD><TD>    public static Context getCurrentContext()</TD></TR><TR><TD CLASS="l">345</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>        Object helper = VMBridge.instance.getThreadContextHelper();</TD></TR><TR CLASS="c"><TD CLASS="l">347</TD><TD>        return VMBridge.instance.getContext(helper);</TD></TR><TR><TD CLASS="l">348</TD><TD>    }</TD></TR><TR><TD CLASS="l">349</TD><TD> </TD></TR><TR><TD CLASS="l">350</TD><TD>    /**</TD></TR><TR><TD CLASS="l">351</TD><TD>     * Same as calling {@link ContextFactory#enterContext()} on the global</TD></TR><TR><TD CLASS="l">352</TD><TD>     * ContextFactory instance.</TD></TR><TR><TD CLASS="l">353</TD><TD>     * @return a Context associated with the current thread</TD></TR><TR><TD CLASS="l">354</TD><TD>     * @see #getCurrentContext()</TD></TR><TR><TD CLASS="l">355</TD><TD>     * @see #exit()</TD></TR><TR><TD CLASS="l"><A NAME="58">356</A></TD><TD>     * @see #call(ContextAction)</TD></TR><TR><TD CLASS="l">357</TD><TD>     */</TD></TR><TR><TD CLASS="l">358</TD><TD>    public static Context enter()</TD></TR><TR><TD CLASS="l">359</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        return enter(null);</TD></TR><TR><TD CLASS="l">361</TD><TD>    }</TD></TR><TR><TD CLASS="l">362</TD><TD> </TD></TR><TR><TD CLASS="l">363</TD><TD>    /**</TD></TR><TR><TD CLASS="l">364</TD><TD>     * Get a Context associated with the current thread, using</TD></TR><TR><TD CLASS="l">365</TD><TD>     * the given Context if need be.</TD></TR><TR><TD CLASS="l">366</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">367</TD><TD>     * The same as &lt;code&gt;enter()&lt;/code&gt; except that &lt;code&gt;cx&lt;/code&gt;</TD></TR><TR><TD CLASS="l">368</TD><TD>     * is associated with the current thread and returned if</TD></TR><TR><TD CLASS="l">369</TD><TD>     * the current thread has no associated context and &lt;code&gt;cx&lt;/code&gt;</TD></TR><TR><TD CLASS="l">370</TD><TD>     * is not associated with any other thread.</TD></TR><TR><TD CLASS="l">371</TD><TD>     * @param cx a Context to associate with the thread if possible</TD></TR><TR><TD CLASS="l">372</TD><TD>     * @return a Context associated with the current thread</TD></TR><TR><TD CLASS="l">373</TD><TD>     * @deprecated use {@link ContextFactory#enterContext(Context)} instead as</TD></TR><TR><TD CLASS="l">374</TD><TD>     * this method relies on usage of a static singleton &#34;global&#34; ContextFactory.</TD></TR><TR><TD CLASS="l">375</TD><TD>     * @see ContextFactory#enterContext(Context)</TD></TR><TR><TD CLASS="l"><A NAME="59">376</A></TD><TD>     * @see ContextFactory#call(ContextAction)</TD></TR><TR><TD CLASS="l">377</TD><TD>     */</TD></TR><TR><TD CLASS="l">378</TD><TD>    public static Context enter(Context cx)</TD></TR><TR><TD CLASS="l">379</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>        return enter(cx, ContextFactory.getGlobal());</TD></TR><TR><TD CLASS="l"><A NAME="38">381</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">382</TD><TD> </TD></TR><TR><TD CLASS="l">383</TD><TD>    static final Context enter(Context cx, ContextFactory factory)</TD></TR><TR><TD CLASS="l">384</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>        Object helper = VMBridge.instance.getThreadContextHelper();</TD></TR><TR CLASS="c"><TD CLASS="l">386</TD><TD>        Context old = VMBridge.instance.getContext(helper);</TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>        if (old != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">388</TD><TD>            cx = old;</TD></TR><TR><TD CLASS="l">389</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">390</TD><TD>            if (cx == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">391</TD><TD>                cx = factory.makeContext();</TD></TR><TR CLASS="c"><TD CLASS="l">392</TD><TD>                if (cx.enterCount != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>                    throw new IllegalStateException(&#34;factory.makeContext() returned Context instance already associated with some thread&#34;);</TD></TR><TR><TD CLASS="l">394</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">395</TD><TD>                factory.onContextCreated(cx);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (6 out of 9 instructions)">396</TD><TD TITLE="67% line coverage (6 out of 9 instructions)">                if (factory.isSealed() &amp;&amp; !cx.isSealed()) {</TD></TR><TR CLASS="z"><TD CLASS="l">397</TD><TD>                    cx.seal(null);</TD></TR><TR><TD CLASS="l">398</TD><TD>                }</TD></TR><TR><TD CLASS="l">399</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                if (cx.enterCount != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                    throw new IllegalStateException(&#34;can not use Context instance already associated with some thread&#34;);</TD></TR><TR><TD CLASS="l">402</TD><TD>                }</TD></TR><TR><TD CLASS="l">403</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">404</TD><TD>            VMBridge.instance.setContext(helper, cx);</TD></TR><TR><TD CLASS="l">405</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">406</TD><TD>        ++cx.enterCount;</TD></TR><TR CLASS="c"><TD CLASS="l">407</TD><TD>        return cx;</TD></TR><TR><TD CLASS="l">408</TD><TD>     }</TD></TR><TR><TD CLASS="l">409</TD><TD> </TD></TR><TR><TD CLASS="l">410</TD><TD>    /**</TD></TR><TR><TD CLASS="l">411</TD><TD>     * Exit a block of code requiring a Context.</TD></TR><TR><TD CLASS="l">412</TD><TD>     *</TD></TR><TR><TD CLASS="l">413</TD><TD>     * Calling &lt;code&gt;exit()&lt;/code&gt; will remove the association between</TD></TR><TR><TD CLASS="l">414</TD><TD>     * the current thread and a Context if the prior call to</TD></TR><TR><TD CLASS="l">415</TD><TD>     * {@link ContextFactory#enterContext()} on this thread newly associated a</TD></TR><TR><TD CLASS="l">416</TD><TD>     * Context with this thread. Once the current thread no longer has an</TD></TR><TR><TD CLASS="l">417</TD><TD>     * associated Context, it cannot be used to execute JavaScript until it is</TD></TR><TR><TD CLASS="l">418</TD><TD>     * again associated with a Context.</TD></TR><TR><TD CLASS="l"><A NAME="44">419</A></TD><TD>     * @see ContextFactory#enterContext()</TD></TR><TR><TD CLASS="l">420</TD><TD>     */</TD></TR><TR><TD CLASS="l">421</TD><TD>    public static void exit()</TD></TR><TR><TD CLASS="l">422</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">423</TD><TD>        Object helper = VMBridge.instance.getThreadContextHelper();</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>        Context cx = VMBridge.instance.getContext(helper);</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>        if (cx == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>            throw new IllegalStateException(</TD></TR><TR><TD CLASS="l">427</TD><TD>                &#34;Calling Context.exit without previous Context.enter&#34;);</TD></TR><TR><TD CLASS="l">428</TD><TD>        }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="67% line coverage (4 out of 6 instructions)">429</TD><TD TITLE="67% line coverage (4 out of 6 instructions)">        if (cx.enterCount &lt; 1) Kit.codeBug();</TD></TR><TR CLASS="c"><TD CLASS="l">430</TD><TD>        if (--cx.enterCount == 0) {</TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>            VMBridge.instance.setContext(helper, null);</TD></TR><TR CLASS="c"><TD CLASS="l">432</TD><TD>            cx.factory.onContextReleased(cx);</TD></TR><TR><TD CLASS="l">433</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">434</TD><TD>    }</TD></TR><TR><TD CLASS="l">435</TD><TD> </TD></TR><TR><TD CLASS="l">436</TD><TD>    /**</TD></TR><TR><TD CLASS="l">437</TD><TD>     * Call {@link ContextAction#run(Context cx)}</TD></TR><TR><TD CLASS="l">438</TD><TD>     * using the Context instance associated with the current thread.</TD></TR><TR><TD CLASS="l">439</TD><TD>     * If no Context is associated with the thread, then</TD></TR><TR><TD CLASS="l">440</TD><TD>     * &lt;tt&gt;ContextFactory.getGlobal().makeContext()&lt;/tt&gt; will be called to</TD></TR><TR><TD CLASS="l">441</TD><TD>     * construct new Context instance. The instance will be temporary</TD></TR><TR><TD CLASS="l">442</TD><TD>     * associated with the thread during call to</TD></TR><TR><TD CLASS="l">443</TD><TD>     * {@link ContextAction#run(Context)}.</TD></TR><TR><TD CLASS="l">444</TD><TD>     * @deprecated use {@link ContextFactory#call(ContextAction)} instead as</TD></TR><TR><TD CLASS="l">445</TD><TD>     * this method relies on usage of a static singleton &#34;global&#34;</TD></TR><TR><TD CLASS="l">446</TD><TD>     * ContextFactory.</TD></TR><TR><TD CLASS="l"><A NAME="6">447</A></TD><TD>     * @return The result of {@link ContextAction#run(Context)}.</TD></TR><TR><TD CLASS="l">448</TD><TD>     */</TD></TR><TR><TD CLASS="l">449</TD><TD>    public static Object call(ContextAction action)</TD></TR><TR><TD CLASS="l">450</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>        return call(ContextFactory.getGlobal(), action);</TD></TR><TR><TD CLASS="l">452</TD><TD>    }</TD></TR><TR><TD CLASS="l">453</TD><TD> </TD></TR><TR><TD CLASS="l">454</TD><TD>    /**</TD></TR><TR><TD CLASS="l">455</TD><TD>     * Call {@link</TD></TR><TR><TD CLASS="l">456</TD><TD>     * Callable#call(Context cx, Scriptable scope, Scriptable thisObj,</TD></TR><TR><TD CLASS="l">457</TD><TD>     *               Object[] args)}</TD></TR><TR><TD CLASS="l">458</TD><TD>     * using the Context instance associated with the current thread.</TD></TR><TR><TD CLASS="l">459</TD><TD>     * If no Context is associated with the thread, then</TD></TR><TR><TD CLASS="l">460</TD><TD>     * {@link ContextFactory#makeContext()} will be called to construct</TD></TR><TR><TD CLASS="l">461</TD><TD>     * new Context instance. The instance will be temporary associated</TD></TR><TR><TD CLASS="l">462</TD><TD>     * with the thread during call to {@link ContextAction#run(Context)}.</TD></TR><TR><TD CLASS="l">463</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">464</TD><TD>     * It is allowed but not advisable to use null for &lt;tt&gt;factory&lt;/tt&gt;</TD></TR><TR><TD CLASS="l">465</TD><TD>     * argument in which case the global static singleton ContextFactory</TD></TR><TR><TD CLASS="l">466</TD><TD>     * instance will be used to create new context instances.</TD></TR><TR><TD CLASS="l">467</TD><TD>     * @see ContextFactory#call(ContextAction)</TD></TR><TR><TD CLASS="l">468</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="48">469</A></TD><TD>    public static Object call(ContextFactory factory, final Callable callable,</TD></TR><TR><TD CLASS="l">470</TD><TD>                              final Scriptable scope, final Scriptable thisObj,</TD></TR><TR><TD CLASS="l">471</TD><TD>                              final Object[] args)</TD></TR><TR><TD CLASS="l"><A NAME="83">472</A></TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">473</TD><TD>        if(factory == null) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="85">474</A></TD><TD>            factory = ContextFactory.getGlobal();</TD></TR><TR><TD CLASS="l">475</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">476</TD><TD>        return call(factory, new ContextAction() {</TD></TR><TR><TD CLASS="l">477</TD><TD>            public Object run(Context cx) {</TD></TR><TR CLASS="c"><TD CLASS="l">478</TD><TD>                return callable.call(cx, scope, thisObj, args);</TD></TR><TR><TD CLASS="l">479</TD><TD>            }</TD></TR><TR><TD CLASS="l">480</TD><TD>        });</TD></TR><TR><TD CLASS="l">481</TD><TD>    }</TD></TR><TR><TD CLASS="l">482</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="51">483</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">484</TD><TD>     * The method implements {@link ContextFactory#call(ContextAction)} logic.</TD></TR><TR><TD CLASS="l">485</TD><TD>     */</TD></TR><TR><TD CLASS="l">486</TD><TD>    static Object call(ContextFactory factory, ContextAction action) {</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>        Context cx = enter(null, factory);</TD></TR><TR><TD CLASS="l">488</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">489</TD><TD>            return action.run(cx);</TD></TR><TR><TD CLASS="l">490</TD><TD>        }</TD></TR><TR><TD CLASS="l">491</TD><TD>        finally {</TD></TR><TR CLASS="c"><TD CLASS="l">492</TD><TD>            exit();</TD></TR><TR><TD CLASS="l">493</TD><TD>        }</TD></TR><TR><TD CLASS="l">494</TD><TD>    }</TD></TR><TR><TD CLASS="l">495</TD><TD> </TD></TR><TR><TD CLASS="l">496</TD><TD>    /**</TD></TR><TR><TD CLASS="l">497</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">498</TD><TD>     * @see ContextFactory#addListener(org.mozilla.javascript.ContextFactory.Listener)</TD></TR><TR><TD CLASS="l">499</TD><TD>     * @see ContextFactory#getGlobal()</TD></TR><TR><TD CLASS="l"><A NAME="4">500</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">501</TD><TD>    public static void addContextListener(ContextListener listener)</TD></TR><TR><TD CLASS="l">502</TD><TD>    {</TD></TR><TR><TD CLASS="l">503</TD><TD>        // Special workaround for the debugger</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>        String DBG = &#34;org.mozilla.javascript.tools.debugger.Main&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>        if (DBG.equals(listener.getClass().getName())) {</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>            Class&lt;?&gt; cl = listener.getClass();</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>            Class&lt;?&gt; factoryClass = Kit.classOrNull(</TD></TR><TR><TD CLASS="l">508</TD><TD>                &#34;org.mozilla.javascript.ContextFactory&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>            Class&lt;?&gt;[] sig = { factoryClass };</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>            Object[] args = { ContextFactory.getGlobal() };</TD></TR><TR><TD CLASS="l">511</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                Method m = cl.getMethod(&#34;attachTo&#34;, sig);</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>                m.invoke(listener, args);</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>            } catch (Exception ex) {</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>                RuntimeException rex = new RuntimeException();</TD></TR><TR CLASS="z"><TD CLASS="l">516</TD><TD>                Kit.initCause(rex, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">517</TD><TD>                throw rex;</TD></TR><TR CLASS="z"><TD CLASS="l">518</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>            return;</TD></TR><TR><TD CLASS="l">520</TD><TD>        }</TD></TR><TR><TD CLASS="l">521</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>        ContextFactory.getGlobal().addListener(listener);</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>    }</TD></TR><TR><TD CLASS="l">524</TD><TD> </TD></TR><TR><TD CLASS="l">525</TD><TD>    /**</TD></TR><TR><TD CLASS="l">526</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">527</TD><TD>     * @see ContextFactory#removeListener(org.mozilla.javascript.ContextFactory.Listener)</TD></TR><TR><TD CLASS="l"><A NAME="18">528</A></TD><TD>     * @see ContextFactory#getGlobal()</TD></TR><TR><TD CLASS="l">529</TD><TD>     */</TD></TR><TR><TD CLASS="l">530</TD><TD>    public static void removeContextListener(ContextListener listener)</TD></TR><TR><TD CLASS="l">531</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>        ContextFactory.getGlobal().addListener(listener);</TD></TR><TR CLASS="z"><TD CLASS="l">533</TD><TD>    }</TD></TR><TR><TD CLASS="l">534</TD><TD> </TD></TR><TR><TD CLASS="l">535</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="5f">536</A></TD><TD>     * Return {@link ContextFactory} instance used to create this Context.</TD></TR><TR><TD CLASS="l">537</TD><TD>     */</TD></TR><TR><TD CLASS="l">538</TD><TD>    public final ContextFactory getFactory()</TD></TR><TR><TD CLASS="l">539</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">540</TD><TD>        return factory;</TD></TR><TR><TD CLASS="l">541</TD><TD>    }</TD></TR><TR><TD CLASS="l">542</TD><TD> </TD></TR><TR><TD CLASS="l">543</TD><TD>    /**</TD></TR><TR><TD CLASS="l">544</TD><TD>     * Checks if this is a sealed Context. A sealed Context instance does not</TD></TR><TR><TD CLASS="l">545</TD><TD>     * allow to modify any of its properties and will throw an exception</TD></TR><TR><TD CLASS="l">546</TD><TD>     * on any such attempt.</TD></TR><TR><TD CLASS="l"><A NAME="6e">547</A></TD><TD>     * @see #seal(Object sealKey)</TD></TR><TR><TD CLASS="l">548</TD><TD>     */</TD></TR><TR><TD CLASS="l">549</TD><TD>    public final boolean isSealed()</TD></TR><TR><TD CLASS="l">550</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">551</TD><TD>        return sealed;</TD></TR><TR><TD CLASS="l">552</TD><TD>    }</TD></TR><TR><TD CLASS="l">553</TD><TD> </TD></TR><TR><TD CLASS="l">554</TD><TD>    /**</TD></TR><TR><TD CLASS="l">555</TD><TD>     * Seal this Context object so any attempt to modify any of its properties</TD></TR><TR><TD CLASS="l">556</TD><TD>     * including calling {@link #enter()} and {@link #exit()} methods will</TD></TR><TR><TD CLASS="l">557</TD><TD>     * throw an exception.</TD></TR><TR><TD CLASS="l">558</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">559</TD><TD>     * If &lt;tt&gt;sealKey&lt;/tt&gt; is not null, calling</TD></TR><TR><TD CLASS="l">560</TD><TD>     * {@link #unseal(Object sealKey)} with the same key unseals</TD></TR><TR><TD CLASS="l">561</TD><TD>     * the object. If &lt;tt&gt;sealKey&lt;/tt&gt; is null, unsealing is no longer possible.</TD></TR><TR><TD CLASS="l">562</TD><TD>     *</TD></TR><TR><TD CLASS="l">563</TD><TD>     * @see #isSealed()</TD></TR><TR><TD CLASS="l"><A NAME="1e">564</A></TD><TD>     * @see #unseal(Object)</TD></TR><TR><TD CLASS="l">565</TD><TD>     */</TD></TR><TR><TD CLASS="l">566</TD><TD>    public final void seal(Object sealKey)</TD></TR><TR><TD CLASS="l">567</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">569</TD><TD>        sealed = true;</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>        this.sealKey = sealKey;</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>    }</TD></TR><TR><TD CLASS="l">572</TD><TD> </TD></TR><TR><TD CLASS="l">573</TD><TD>    /**</TD></TR><TR><TD CLASS="l">574</TD><TD>     * Unseal previously sealed Context object.</TD></TR><TR><TD CLASS="l">575</TD><TD>     * The &lt;tt&gt;sealKey&lt;/tt&gt; argument should not be null and should match</TD></TR><TR><TD CLASS="l">576</TD><TD>     * &lt;tt&gt;sealKey&lt;/tt&gt; suplied with the last call to</TD></TR><TR><TD CLASS="l">577</TD><TD>     * {@link #seal(Object)} or an exception will be thrown.</TD></TR><TR><TD CLASS="l">578</TD><TD>     *</TD></TR><TR><TD CLASS="l">579</TD><TD>     * @see #isSealed()</TD></TR><TR><TD CLASS="l"><A NAME="2c">580</A></TD><TD>     * @see #seal(Object sealKey)</TD></TR><TR><TD CLASS="l">581</TD><TD>     */</TD></TR><TR><TD CLASS="l">582</TD><TD>    public final void unseal(Object sealKey)</TD></TR><TR><TD CLASS="l">583</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>        if (sealKey == null) throw new IllegalArgumentException();</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>        if (this.sealKey != sealKey) throw new IllegalArgumentException();</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>        if (!sealed) throw new IllegalStateException();</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>        sealed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>        this.sealKey = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="15">589</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">590</TD><TD> </TD></TR><TR><TD CLASS="l">591</TD><TD>    static void onSealedMutation()</TD></TR><TR><TD CLASS="l">592</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">593</TD><TD>        throw new IllegalStateException();</TD></TR><TR><TD CLASS="l">594</TD><TD>    }</TD></TR><TR><TD CLASS="l">595</TD><TD> </TD></TR><TR><TD CLASS="l">596</TD><TD>    /**</TD></TR><TR><TD CLASS="l">597</TD><TD>     * Get the current language version.</TD></TR><TR><TD CLASS="l">598</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">599</TD><TD>     * The language version number affects JavaScript semantics as detailed</TD></TR><TR><TD CLASS="l">600</TD><TD>     * in the overview documentation.</TD></TR><TR><TD CLASS="l">601</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="60">602</A></TD><TD>     * @return an integer that is one of VERSION_1_0, VERSION_1_1, etc.</TD></TR><TR><TD CLASS="l">603</TD><TD>     */</TD></TR><TR><TD CLASS="l">604</TD><TD>    public final int getLanguageVersion()</TD></TR><TR><TD CLASS="l">605</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">606</TD><TD>       return version;</TD></TR><TR><TD CLASS="l">607</TD><TD>    }</TD></TR><TR><TD CLASS="l">608</TD><TD> </TD></TR><TR><TD CLASS="l">609</TD><TD>    /**</TD></TR><TR><TD CLASS="l">610</TD><TD>     * Set the language version.</TD></TR><TR><TD CLASS="l">611</TD><TD>     *</TD></TR><TR><TD CLASS="l">612</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">613</TD><TD>     * Setting the language version will affect functions and scripts compiled</TD></TR><TR><TD CLASS="l">614</TD><TD>     * subsequently. See the overview documentation for version-specific</TD></TR><TR><TD CLASS="l">615</TD><TD>     * behavior.</TD></TR><TR><TD CLASS="l">616</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="30">617</A></TD><TD>     * @param version the version as specified by VERSION_1_0, VERSION_1_1, etc.</TD></TR><TR><TD CLASS="l">618</TD><TD>     */</TD></TR><TR><TD CLASS="l">619</TD><TD>    public void setLanguageVersion(int version)</TD></TR><TR><TD CLASS="l">620</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (3 out of 4 instructions)">621</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (sealed) onSealedMutation();</TD></TR><TR CLASS="c"><TD CLASS="l">622</TD><TD>        checkLanguageVersion(version);</TD></TR><TR CLASS="c"><TD CLASS="l">623</TD><TD>        Object listeners = propertyListeners;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="64% line coverage (7 out of 11 instructions)">624</TD><TD TITLE="64% line coverage (7 out of 11 instructions)">        if (listeners != null &amp;&amp; version != this.version) {</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>            firePropertyChangeImpl(listeners, languageVersionProperty,</TD></TR><TR><TD CLASS="l">626</TD><TD>                               Integer.valueOf(this.version),</TD></TR><TR><TD CLASS="l">627</TD><TD>                               Integer.valueOf(version));</TD></TR><TR><TD CLASS="l">628</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">629</TD><TD>        this.version = version;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="39">630</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">631</TD><TD> </TD></TR><TR><TD CLASS="l">632</TD><TD>    public static boolean isValidLanguageVersion(int version)</TD></TR><TR><TD CLASS="l">633</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">634</TD><TD>        switch (version) {</TD></TR><TR><TD CLASS="l">635</TD><TD>            case VERSION_DEFAULT:</TD></TR><TR><TD CLASS="l">636</TD><TD>            case VERSION_1_0:</TD></TR><TR><TD CLASS="l">637</TD><TD>            case VERSION_1_1:</TD></TR><TR><TD CLASS="l">638</TD><TD>            case VERSION_1_2:</TD></TR><TR><TD CLASS="l">639</TD><TD>            case VERSION_1_3:</TD></TR><TR><TD CLASS="l">640</TD><TD>            case VERSION_1_4:</TD></TR><TR><TD CLASS="l">641</TD><TD>            case VERSION_1_5:</TD></TR><TR><TD CLASS="l">642</TD><TD>            case VERSION_1_6:</TD></TR><TR><TD CLASS="l">643</TD><TD>            case VERSION_1_7:</TD></TR><TR><TD CLASS="l">644</TD><TD>            case VERSION_1_8:</TD></TR><TR CLASS="c"><TD CLASS="l">645</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">646</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>        return false;</TD></TR><TR><TD CLASS="l"><A NAME="2e">648</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">649</TD><TD> </TD></TR><TR><TD CLASS="l">650</TD><TD>    public static void checkLanguageVersion(int version)</TD></TR><TR><TD CLASS="l">651</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">652</TD><TD>        if (isValidLanguageVersion(version)) {</TD></TR><TR CLASS="c"><TD CLASS="l">653</TD><TD>            return;</TD></TR><TR><TD CLASS="l">654</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>        throw new IllegalArgumentException(&#34;Bad language version: &#34;+version);</TD></TR><TR><TD CLASS="l">656</TD><TD>    }</TD></TR><TR><TD CLASS="l">657</TD><TD> </TD></TR><TR><TD CLASS="l">658</TD><TD>    /**</TD></TR><TR><TD CLASS="l">659</TD><TD>     * Get the implementation version.</TD></TR><TR><TD CLASS="l">660</TD><TD>     *</TD></TR><TR><TD CLASS="l">661</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">662</TD><TD>     * The implementation version is of the form</TD></TR><TR><TD CLASS="l">663</TD><TD>     * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">664</TD><TD>     *    &#34;&lt;i&gt;name langVer&lt;/i&gt; &lt;code&gt;release&lt;/code&gt; &lt;i&gt;relNum date&lt;/i&gt;&#34;</TD></TR><TR><TD CLASS="l">665</TD><TD>     * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">666</TD><TD>     * where &lt;i&gt;name&lt;/i&gt; is the name of the product, &lt;i&gt;langVer&lt;/i&gt; is</TD></TR><TR><TD CLASS="l">667</TD><TD>     * the language version, &lt;i&gt;relNum&lt;/i&gt; is the release number, and</TD></TR><TR><TD CLASS="l">668</TD><TD>     * &lt;i&gt;date&lt;/i&gt; is the release date for that specific</TD></TR><TR><TD CLASS="l">669</TD><TD>     * release in the form &#34;yyyy mm dd&#34;.</TD></TR><TR><TD CLASS="l">670</TD><TD>     *</TD></TR><TR><TD CLASS="l">671</TD><TD>     * @return a string that encodes the product, language version, release</TD></TR><TR><TD CLASS="l">672</TD><TD>     *         number, and date.</TD></TR><TR><TD CLASS="l">673</TD><TD>     */</TD></TR><TR><TD CLASS="l">674</TD><TD>    public final String getImplementationVersion()</TD></TR><TR><TD CLASS="l"><A NAME="f">675</A></TD><TD>    {</TD></TR><TR><TD CLASS="l">676</TD><TD>        // XXX Probably it would be better to embed this directly into source</TD></TR><TR><TD CLASS="l">677</TD><TD>        // with special build preprocessing but that would require some ant</TD></TR><TR><TD CLASS="l">678</TD><TD>        // tweaking and then replacing token in resource files was simpler</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>        if (implementationVersion == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>            implementationVersion</TD></TR><TR><TD CLASS="l">681</TD><TD>                = ScriptRuntime.getMessage0(&#34;implementation.version&#34;);</TD></TR><TR><TD CLASS="l">682</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>        return implementationVersion;</TD></TR><TR><TD CLASS="l">684</TD><TD>    }</TD></TR><TR><TD CLASS="l">685</TD><TD> </TD></TR><TR><TD CLASS="l">686</TD><TD>    /**</TD></TR><TR><TD CLASS="l">687</TD><TD>     * Get the current error reporter.</TD></TR><TR><TD CLASS="l">688</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="5e">689</A></TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">690</TD><TD>     */</TD></TR><TR><TD CLASS="l">691</TD><TD>    public final ErrorReporter getErrorReporter()</TD></TR><TR><TD CLASS="l">692</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">693</TD><TD>        if (errorReporter == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">694</TD><TD>            return DefaultErrorReporter.instance;</TD></TR><TR><TD CLASS="l">695</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">696</TD><TD>        return errorReporter;</TD></TR><TR><TD CLASS="l">697</TD><TD>    }</TD></TR><TR><TD CLASS="l">698</TD><TD> </TD></TR><TR><TD CLASS="l">699</TD><TD>    /**</TD></TR><TR><TD CLASS="l">700</TD><TD>     * Change the current error reporter.</TD></TR><TR><TD CLASS="l">701</TD><TD>     *</TD></TR><TR><TD CLASS="l">702</TD><TD>     * @return the previous error reporter</TD></TR><TR><TD CLASS="l"><A NAME="36">703</A></TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">704</TD><TD>     */</TD></TR><TR><TD CLASS="l">705</TD><TD>    public final ErrorReporter setErrorReporter(ErrorReporter reporter)</TD></TR><TR><TD CLASS="l">706</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (3 out of 4 instructions)">707</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (sealed) onSealedMutation();</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="33% line coverage (2 out of 6 instructions)">708</TD><TD TITLE="33% line coverage (2 out of 6 instructions)">        if (reporter == null) throw new IllegalArgumentException();</TD></TR><TR CLASS="c"><TD CLASS="l">709</TD><TD>        ErrorReporter old = getErrorReporter();</TD></TR><TR CLASS="c"><TD CLASS="l">710</TD><TD>        if (reporter == old) {</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>            return old;</TD></TR><TR><TD CLASS="l">712</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">713</TD><TD>        Object listeners = propertyListeners;</TD></TR><TR CLASS="c"><TD CLASS="l">714</TD><TD>        if (listeners != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>            firePropertyChangeImpl(listeners, errorReporterProperty,</TD></TR><TR><TD CLASS="l">716</TD><TD>                                   old, reporter);</TD></TR><TR><TD CLASS="l">717</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">718</TD><TD>        this.errorReporter = reporter;</TD></TR><TR CLASS="c"><TD CLASS="l">719</TD><TD>        return old;</TD></TR><TR><TD CLASS="l">720</TD><TD>    }</TD></TR><TR><TD CLASS="l">721</TD><TD> </TD></TR><TR><TD CLASS="l">722</TD><TD>    /**</TD></TR><TR><TD CLASS="l">723</TD><TD>     * Get the current locale.  Returns the default locale if none has</TD></TR><TR><TD CLASS="l">724</TD><TD>     * been set.</TD></TR><TR><TD CLASS="l">725</TD><TD>     *</TD></TR><TR><TD CLASS="l">726</TD><TD>     * @see java.util.Locale</TD></TR><TR><TD CLASS="l"><A NAME="61">727</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">728</TD><TD> </TD></TR><TR><TD CLASS="l">729</TD><TD>    public final Locale getLocale()</TD></TR><TR><TD CLASS="l">730</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">731</TD><TD>        if (locale == null)</TD></TR><TR CLASS="c"><TD CLASS="l">732</TD><TD>            locale = Locale.getDefault();</TD></TR><TR CLASS="c"><TD CLASS="l">733</TD><TD>        return locale;</TD></TR><TR><TD CLASS="l">734</TD><TD>    }</TD></TR><TR><TD CLASS="l">735</TD><TD> </TD></TR><TR><TD CLASS="l">736</TD><TD>    /**</TD></TR><TR><TD CLASS="l">737</TD><TD>     * Set the current locale.</TD></TR><TR><TD CLASS="l">738</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="24">739</A></TD><TD>     * @see java.util.Locale</TD></TR><TR><TD CLASS="l">740</TD><TD>     */</TD></TR><TR><TD CLASS="l">741</TD><TD>    public final Locale setLocale(Locale loc)</TD></TR><TR><TD CLASS="l">742</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">744</TD><TD>        Locale result = locale;</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>        locale = loc;</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">747</TD><TD>    }</TD></TR><TR><TD CLASS="l">748</TD><TD> </TD></TR><TR><TD CLASS="l">749</TD><TD>    /**</TD></TR><TR><TD CLASS="l">750</TD><TD>     * Register an object to receive notifications when a bound property</TD></TR><TR><TD CLASS="l">751</TD><TD>     * has changed</TD></TR><TR><TD CLASS="l">752</TD><TD>     * @see java.beans.PropertyChangeEvent</TD></TR><TR><TD CLASS="l">753</TD><TD>     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)</TD></TR><TR><TD CLASS="l"><A NAME="5">754</A></TD><TD>     * @param l the listener</TD></TR><TR><TD CLASS="l">755</TD><TD>     */</TD></TR><TR><TD CLASS="l">756</TD><TD>    public final void addPropertyChangeListener(PropertyChangeListener l)</TD></TR><TR><TD CLASS="l">757</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>        propertyListeners = Kit.addListener(propertyListeners, l);</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>    }</TD></TR><TR><TD CLASS="l">761</TD><TD> </TD></TR><TR><TD CLASS="l">762</TD><TD>    /**</TD></TR><TR><TD CLASS="l">763</TD><TD>     * Remove an object from the list of objects registered to receive</TD></TR><TR><TD CLASS="l">764</TD><TD>     * notification of changes to a bounded property</TD></TR><TR><TD CLASS="l">765</TD><TD>     * @see java.beans.PropertyChangeEvent</TD></TR><TR><TD CLASS="l">766</TD><TD>     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)</TD></TR><TR><TD CLASS="l"><A NAME="19">767</A></TD><TD>     * @param l the listener</TD></TR><TR><TD CLASS="l">768</TD><TD>     */</TD></TR><TR><TD CLASS="l">769</TD><TD>    public final void removePropertyChangeListener(PropertyChangeListener l)</TD></TR><TR><TD CLASS="l">770</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>        propertyListeners = Kit.removeListener(propertyListeners, l);</TD></TR><TR CLASS="z"><TD CLASS="l">773</TD><TD>    }</TD></TR><TR><TD CLASS="l">774</TD><TD> </TD></TR><TR><TD CLASS="l">775</TD><TD>    /**</TD></TR><TR><TD CLASS="l">776</TD><TD>     * Notify any registered listeners that a bounded property has changed</TD></TR><TR><TD CLASS="l">777</TD><TD>     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)</TD></TR><TR><TD CLASS="l">778</TD><TD>     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)</TD></TR><TR><TD CLASS="l">779</TD><TD>     * @see java.beans.PropertyChangeListener</TD></TR><TR><TD CLASS="l">780</TD><TD>     * @see java.beans.PropertyChangeEvent</TD></TR><TR><TD CLASS="l">781</TD><TD>     * @param  property  the bound property</TD></TR><TR><TD CLASS="l">782</TD><TD>     * @param  oldValue  the old value</TD></TR><TR><TD CLASS="l">783</TD><TD>     * @param  newValue   the new value</TD></TR><TR><TD CLASS="l"><A NAME="a">784</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">785</TD><TD>    final void firePropertyChange(String property, Object oldValue,</TD></TR><TR><TD CLASS="l">786</TD><TD>                                  Object newValue)</TD></TR><TR><TD CLASS="l">787</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>        Object listeners = propertyListeners;</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>        if (listeners != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>            firePropertyChangeImpl(listeners, property, oldValue, newValue);</TD></TR><TR><TD CLASS="l">791</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="b">793</A></TD><TD> </TD></TR><TR><TD CLASS="l">794</TD><TD>    private void firePropertyChangeImpl(Object listeners, String property,</TD></TR><TR><TD CLASS="l">795</TD><TD>                                        Object oldValue, Object newValue)</TD></TR><TR><TD CLASS="l">796</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">797</TD><TD>        for (int i = 0; ; ++i) {</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>            Object l = Kit.getListener(listeners, i);</TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>            if (l == null)</TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>                break;</TD></TR><TR CLASS="z"><TD CLASS="l">801</TD><TD>            if (l instanceof PropertyChangeListener) {</TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>                PropertyChangeListener pcl = (PropertyChangeListener)l;</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>                pcl.propertyChange(new PropertyChangeEvent(</TD></TR><TR><TD CLASS="l">804</TD><TD>                    this, property, oldValue, newValue));</TD></TR><TR><TD CLASS="l">805</TD><TD>            }</TD></TR><TR><TD CLASS="l">806</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">807</TD><TD>    }</TD></TR><TR><TD CLASS="l">808</TD><TD> </TD></TR><TR><TD CLASS="l">809</TD><TD>    /**</TD></TR><TR><TD CLASS="l">810</TD><TD>     * Report a warning using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">811</TD><TD>     *</TD></TR><TR><TD CLASS="l">812</TD><TD>     * @param message the warning message to report</TD></TR><TR><TD CLASS="l">813</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">814</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">815</TD><TD>     * @param lineSource the text of the line (may be null)</TD></TR><TR><TD CLASS="l">816</TD><TD>     * @param lineOffset the offset into lineSource where problem was detected</TD></TR><TR><TD CLASS="l">817</TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">818</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="3a">819</A></TD><TD>    public static void reportWarning(String message, String sourceName,</TD></TR><TR><TD CLASS="l">820</TD><TD>                                     int lineno, String lineSource,</TD></TR><TR><TD CLASS="l">821</TD><TD>                                     int lineOffset)</TD></TR><TR><TD CLASS="l">822</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">823</TD><TD>        Context cx = Context.getContext();</TD></TR><TR CLASS="c"><TD CLASS="l">824</TD><TD>        if (cx.hasFeature(FEATURE_WARNING_AS_ERROR))</TD></TR><TR CLASS="z"><TD CLASS="l">825</TD><TD>            reportError(message, sourceName, lineno, lineSource, lineOffset);</TD></TR><TR><TD CLASS="l">826</TD><TD>        else</TD></TR><TR CLASS="c"><TD CLASS="l">827</TD><TD>            cx.getErrorReporter().warning(message, sourceName, lineno,</TD></TR><TR><TD CLASS="l">828</TD><TD>                                          lineSource, lineOffset);</TD></TR><TR CLASS="c"><TD CLASS="l">829</TD><TD>    }</TD></TR><TR><TD CLASS="l">830</TD><TD> </TD></TR><TR><TD CLASS="l">831</TD><TD>    /**</TD></TR><TR><TD CLASS="l">832</TD><TD>     * Report a warning using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">833</TD><TD>     *</TD></TR><TR><TD CLASS="l">834</TD><TD>     * @param message the warning message to report</TD></TR><TR><TD CLASS="l"><A NAME="79">835</A></TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">836</TD><TD>     */</TD></TR><TR><TD CLASS="l">837</TD><TD>    public static void reportWarning(String message)</TD></TR><TR><TD CLASS="l">838</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">839</TD><TD>        int[] linep = { 0 };</TD></TR><TR CLASS="c"><TD CLASS="l">840</TD><TD>        String filename = getSourcePositionFromStack(linep);</TD></TR><TR CLASS="c"><TD CLASS="l">841</TD><TD>        Context.reportWarning(message, filename, linep[0], null, 0);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="1d">842</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">843</TD><TD> </TD></TR><TR><TD CLASS="l">844</TD><TD>    public static void reportWarning(String message, Throwable t)</TD></TR><TR><TD CLASS="l">845</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">846</TD><TD>        int[] linep = { 0 };</TD></TR><TR CLASS="z"><TD CLASS="l">847</TD><TD>        String filename = getSourcePositionFromStack(linep);</TD></TR><TR CLASS="z"><TD CLASS="l">848</TD><TD>        Writer sw = new StringWriter();</TD></TR><TR CLASS="z"><TD CLASS="l">849</TD><TD>        PrintWriter pw = new PrintWriter(sw);</TD></TR><TR CLASS="z"><TD CLASS="l">850</TD><TD>        pw.println(message);</TD></TR><TR CLASS="z"><TD CLASS="l">851</TD><TD>        t.printStackTrace(pw);</TD></TR><TR CLASS="z"><TD CLASS="l">852</TD><TD>        pw.flush();</TD></TR><TR CLASS="z"><TD CLASS="l">853</TD><TD>        Context.reportWarning(sw.toString(), filename, linep[0], null, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">854</TD><TD>    }</TD></TR><TR><TD CLASS="l">855</TD><TD> </TD></TR><TR><TD CLASS="l">856</TD><TD>    /**</TD></TR><TR><TD CLASS="l">857</TD><TD>     * Report an error using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">858</TD><TD>     *</TD></TR><TR><TD CLASS="l">859</TD><TD>     * @param message the error message to report</TD></TR><TR><TD CLASS="l">860</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">861</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">862</TD><TD>     * @param lineSource the text of the line (may be null)</TD></TR><TR><TD CLASS="l">863</TD><TD>     * @param lineOffset the offset into lineSource where problem was detected</TD></TR><TR><TD CLASS="l">864</TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">865</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="2d">866</A></TD><TD>    public static void reportError(String message, String sourceName,</TD></TR><TR><TD CLASS="l">867</TD><TD>                                   int lineno, String lineSource,</TD></TR><TR><TD CLASS="l">868</TD><TD>                                   int lineOffset)</TD></TR><TR><TD CLASS="l">869</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">870</TD><TD>        Context cx = getCurrentContext();</TD></TR><TR CLASS="c"><TD CLASS="l">871</TD><TD>        if (cx != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">872</TD><TD>            cx.getErrorReporter().error(message, sourceName, lineno,</TD></TR><TR><TD CLASS="l">873</TD><TD>                                        lineSource, lineOffset);</TD></TR><TR><TD CLASS="l">874</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>            throw new EvaluatorException(message, sourceName, lineno,</TD></TR><TR><TD CLASS="l">876</TD><TD>                                         lineSource, lineOffset);</TD></TR><TR><TD CLASS="l">877</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">878</TD><TD>    }</TD></TR><TR><TD CLASS="l">879</TD><TD> </TD></TR><TR><TD CLASS="l">880</TD><TD>    /**</TD></TR><TR><TD CLASS="l">881</TD><TD>     * Report an error using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">882</TD><TD>     *</TD></TR><TR><TD CLASS="l">883</TD><TD>     * @param message the error message to report</TD></TR><TR><TD CLASS="l"><A NAME="1b">884</A></TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">885</TD><TD>     */</TD></TR><TR><TD CLASS="l">886</TD><TD>    public static void reportError(String message)</TD></TR><TR><TD CLASS="l">887</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>        int[] linep = { 0 };</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>        String filename = getSourcePositionFromStack(linep);</TD></TR><TR CLASS="z"><TD CLASS="l">890</TD><TD>        Context.reportError(message, filename, linep[0], null, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">891</TD><TD>    }</TD></TR><TR><TD CLASS="l">892</TD><TD> </TD></TR><TR><TD CLASS="l">893</TD><TD>    /**</TD></TR><TR><TD CLASS="l">894</TD><TD>     * Report a runtime error using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">895</TD><TD>     *</TD></TR><TR><TD CLASS="l">896</TD><TD>     * @param message the error message to report</TD></TR><TR><TD CLASS="l">897</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">898</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">899</TD><TD>     * @param lineSource the text of the line (may be null)</TD></TR><TR><TD CLASS="l">900</TD><TD>     * @param lineOffset the offset into lineSource where problem was detected</TD></TR><TR><TD CLASS="l">901</TD><TD>     * @return a runtime exception that will be thrown to terminate the</TD></TR><TR><TD CLASS="l">902</TD><TD>     *         execution of the script</TD></TR><TR><TD CLASS="l">903</TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">904</TD><TD>     */</TD></TR><TR><TD CLASS="l">905</TD><TD>    public static EvaluatorException reportRuntimeError(String message,</TD></TR><TR><TD CLASS="l">906</TD><TD>                                                        String sourceName,</TD></TR><TR><TD CLASS="l"><A NAME="34">907</A></TD><TD>                                                        int lineno,</TD></TR><TR><TD CLASS="l">908</TD><TD>                                                        String lineSource,</TD></TR><TR><TD CLASS="l">909</TD><TD>                                                        int lineOffset)</TD></TR><TR><TD CLASS="l">910</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">911</TD><TD>        Context cx = getCurrentContext();</TD></TR><TR CLASS="c"><TD CLASS="l">912</TD><TD>        if (cx != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">913</TD><TD>            return cx.getErrorReporter().</TD></TR><TR><TD CLASS="l">914</TD><TD>                            runtimeError(message, sourceName, lineno,</TD></TR><TR><TD CLASS="l">915</TD><TD>                                         lineSource, lineOffset);</TD></TR><TR><TD CLASS="l">916</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">917</TD><TD>            throw new EvaluatorException(message, sourceName, lineno,</TD></TR><TR><TD CLASS="l">918</TD><TD>                                         lineSource, lineOffset);</TD></TR><TR><TD CLASS="l">919</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="75">920</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">921</TD><TD> </TD></TR><TR><TD CLASS="l">922</TD><TD>    static EvaluatorException reportRuntimeError0(String messageId)</TD></TR><TR><TD CLASS="l">923</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">924</TD><TD>        String msg = ScriptRuntime.getMessage0(messageId);</TD></TR><TR CLASS="c"><TD CLASS="l">925</TD><TD>        return reportRuntimeError(msg);</TD></TR><TR><TD CLASS="l">926</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="76">927</A></TD><TD> </TD></TR><TR><TD CLASS="l">928</TD><TD>    static EvaluatorException reportRuntimeError1(String messageId,</TD></TR><TR><TD CLASS="l">929</TD><TD>                                                  Object arg1)</TD></TR><TR><TD CLASS="l">930</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">931</TD><TD>        String msg = ScriptRuntime.getMessage1(messageId, arg1);</TD></TR><TR CLASS="c"><TD CLASS="l">932</TD><TD>        return reportRuntimeError(msg);</TD></TR><TR><TD CLASS="l">933</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="77">934</A></TD><TD> </TD></TR><TR><TD CLASS="l">935</TD><TD>    static EvaluatorException reportRuntimeError2(String messageId,</TD></TR><TR><TD CLASS="l">936</TD><TD>                                                  Object arg1, Object arg2)</TD></TR><TR><TD CLASS="l">937</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">938</TD><TD>        String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);</TD></TR><TR CLASS="c"><TD CLASS="l">939</TD><TD>        return reportRuntimeError(msg);</TD></TR><TR><TD CLASS="l">940</TD><TD>    }</TD></TR><TR><TD CLASS="l">941</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="1c">942</A></TD><TD>    static EvaluatorException reportRuntimeError3(String messageId,</TD></TR><TR><TD CLASS="l">943</TD><TD>                                                  Object arg1, Object arg2,</TD></TR><TR><TD CLASS="l">944</TD><TD>                                                  Object arg3)</TD></TR><TR><TD CLASS="l">945</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>        String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>        return reportRuntimeError(msg);</TD></TR><TR><TD CLASS="l">948</TD><TD>    }</TD></TR><TR><TD CLASS="l">949</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="78">950</A></TD><TD>    static EvaluatorException reportRuntimeError4(String messageId,</TD></TR><TR><TD CLASS="l">951</TD><TD>                                                  Object arg1, Object arg2,</TD></TR><TR><TD CLASS="l">952</TD><TD>                                                  Object arg3, Object arg4)</TD></TR><TR><TD CLASS="l">953</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">954</TD><TD>        String msg</TD></TR><TR><TD CLASS="l">955</TD><TD>            = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);</TD></TR><TR CLASS="c"><TD CLASS="l">956</TD><TD>        return reportRuntimeError(msg);</TD></TR><TR><TD CLASS="l">957</TD><TD>    }</TD></TR><TR><TD CLASS="l">958</TD><TD> </TD></TR><TR><TD CLASS="l">959</TD><TD>    /**</TD></TR><TR><TD CLASS="l">960</TD><TD>     * Report a runtime error using the error reporter for the current thread.</TD></TR><TR><TD CLASS="l">961</TD><TD>     *</TD></TR><TR><TD CLASS="l">962</TD><TD>     * @param message the error message to report</TD></TR><TR><TD CLASS="l"><A NAME="74">963</A></TD><TD>     * @see org.mozilla.javascript.ErrorReporter</TD></TR><TR><TD CLASS="l">964</TD><TD>     */</TD></TR><TR><TD CLASS="l">965</TD><TD>    public static EvaluatorException reportRuntimeError(String message)</TD></TR><TR><TD CLASS="l">966</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">967</TD><TD>        int[] linep = { 0 };</TD></TR><TR CLASS="c"><TD CLASS="l">968</TD><TD>        String filename = getSourcePositionFromStack(linep);</TD></TR><TR CLASS="c"><TD CLASS="l">969</TD><TD>        return Context.reportRuntimeError(message, filename, linep[0], null, 0);</TD></TR><TR><TD CLASS="l">970</TD><TD>    }</TD></TR><TR><TD CLASS="l">971</TD><TD> </TD></TR><TR><TD CLASS="l">972</TD><TD>    /**</TD></TR><TR><TD CLASS="l">973</TD><TD>     * Initialize the standard objects.</TD></TR><TR><TD CLASS="l">974</TD><TD>     *</TD></TR><TR><TD CLASS="l">975</TD><TD>     * Creates instances of the standard objects and their constructors</TD></TR><TR><TD CLASS="l">976</TD><TD>     * (Object, String, Number, Date, etc.), setting up 'scope' to act</TD></TR><TR><TD CLASS="l">977</TD><TD>     * as a global object as in ECMA 15.1.&lt;p&gt;</TD></TR><TR><TD CLASS="l">978</TD><TD>     *</TD></TR><TR><TD CLASS="l">979</TD><TD>     * This method must be called to initialize a scope before scripts</TD></TR><TR><TD CLASS="l">980</TD><TD>     * can be evaluated in that scope.&lt;p&gt;</TD></TR><TR><TD CLASS="l">981</TD><TD>     *</TD></TR><TR><TD CLASS="l">982</TD><TD>     * This method does not affect the Context it is called upon.</TD></TR><TR><TD CLASS="l">983</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="68">984</A></TD><TD>     * @return the initialized scope</TD></TR><TR><TD CLASS="l">985</TD><TD>     */</TD></TR><TR><TD CLASS="l">986</TD><TD>    public final ScriptableObject initStandardObjects()</TD></TR><TR><TD CLASS="l">987</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">988</TD><TD>        return initStandardObjects(null, false);</TD></TR><TR><TD CLASS="l">989</TD><TD>    }</TD></TR><TR><TD CLASS="l">990</TD><TD> </TD></TR><TR><TD CLASS="l">991</TD><TD>    /**</TD></TR><TR><TD CLASS="l">992</TD><TD>     * Initialize the standard objects.</TD></TR><TR><TD CLASS="l">993</TD><TD>     *</TD></TR><TR><TD CLASS="l">994</TD><TD>     * Creates instances of the standard objects and their constructors</TD></TR><TR><TD CLASS="l">995</TD><TD>     * (Object, String, Number, Date, etc.), setting up 'scope' to act</TD></TR><TR><TD CLASS="l">996</TD><TD>     * as a global object as in ECMA 15.1.&lt;p&gt;</TD></TR><TR><TD CLASS="l">997</TD><TD>     *</TD></TR><TR><TD CLASS="l">998</TD><TD>     * This method must be called to initialize a scope before scripts</TD></TR><TR><TD CLASS="l">999</TD><TD>     * can be evaluated in that scope.&lt;p&gt;</TD></TR><TR><TD CLASS="l">1000</TD><TD>     *</TD></TR><TR><TD CLASS="l">1001</TD><TD>     * This method does not affect the Context it is called upon.</TD></TR><TR><TD CLASS="l">1002</TD><TD>     *</TD></TR><TR><TD CLASS="l">1003</TD><TD>     * @param scope the scope to initialize, or null, in which case a new</TD></TR><TR><TD CLASS="l">1004</TD><TD>     *        object will be created to serve as the scope</TD></TR><TR><TD CLASS="l">1005</TD><TD>     * @return the initialized scope. The method returns the value of the scope</TD></TR><TR><TD CLASS="l">1006</TD><TD>     *         argument if it is not null or newly allocated scope object which</TD></TR><TR><TD CLASS="l"><A NAME="69">1007</A></TD><TD>     *         is an instance {@link ScriptableObject}.</TD></TR><TR><TD CLASS="l">1008</TD><TD>     */</TD></TR><TR><TD CLASS="l">1009</TD><TD>    public final Scriptable initStandardObjects(ScriptableObject scope)</TD></TR><TR><TD CLASS="l">1010</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1011</TD><TD>        return initStandardObjects(scope, false);</TD></TR><TR><TD CLASS="l">1012</TD><TD>    }</TD></TR><TR><TD CLASS="l">1013</TD><TD> </TD></TR><TR><TD CLASS="l">1014</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1015</TD><TD>     * Initialize the standard objects.</TD></TR><TR><TD CLASS="l">1016</TD><TD>     *</TD></TR><TR><TD CLASS="l">1017</TD><TD>     * Creates instances of the standard objects and their constructors</TD></TR><TR><TD CLASS="l">1018</TD><TD>     * (Object, String, Number, Date, etc.), setting up 'scope' to act</TD></TR><TR><TD CLASS="l">1019</TD><TD>     * as a global object as in ECMA 15.1.&lt;p&gt;</TD></TR><TR><TD CLASS="l">1020</TD><TD>     *</TD></TR><TR><TD CLASS="l">1021</TD><TD>     * This method must be called to initialize a scope before scripts</TD></TR><TR><TD CLASS="l">1022</TD><TD>     * can be evaluated in that scope.&lt;p&gt;</TD></TR><TR><TD CLASS="l">1023</TD><TD>     *</TD></TR><TR><TD CLASS="l">1024</TD><TD>     * This method does not affect the Context it is called upon.&lt;p&gt;</TD></TR><TR><TD CLASS="l">1025</TD><TD>     *</TD></TR><TR><TD CLASS="l">1026</TD><TD>     * This form of the method also allows for creating &#34;sealed&#34; standard</TD></TR><TR><TD CLASS="l">1027</TD><TD>     * objects. An object that is sealed cannot have properties added, changed,</TD></TR><TR><TD CLASS="l">1028</TD><TD>     * or removed. This is useful to create a &#34;superglobal&#34; that can be shared</TD></TR><TR><TD CLASS="l">1029</TD><TD>     * among several top-level objects. Note that sealing is not allowed in</TD></TR><TR><TD CLASS="l">1030</TD><TD>     * the current ECMA/ISO language specification, but is likely for</TD></TR><TR><TD CLASS="l">1031</TD><TD>     * the next version.</TD></TR><TR><TD CLASS="l">1032</TD><TD>     *</TD></TR><TR><TD CLASS="l">1033</TD><TD>     * @param scope the scope to initialize, or null, in which case a new</TD></TR><TR><TD CLASS="l">1034</TD><TD>     *        object will be created to serve as the scope</TD></TR><TR><TD CLASS="l">1035</TD><TD>     * @param sealed whether or not to create sealed standard objects that</TD></TR><TR><TD CLASS="l">1036</TD><TD>     *        cannot be modified.</TD></TR><TR><TD CLASS="l">1037</TD><TD>     * @return the initialized scope. The method returns the value of the scope</TD></TR><TR><TD CLASS="l">1038</TD><TD>     *         argument if it is not null or newly allocated scope object.</TD></TR><TR><TD CLASS="l">1039</TD><TD>     * @since 1.4R3</TD></TR><TR><TD CLASS="l"><A NAME="6a">1040</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1041</TD><TD>    public ScriptableObject initStandardObjects(ScriptableObject scope,</TD></TR><TR><TD CLASS="l">1042</TD><TD>                                                boolean sealed)</TD></TR><TR><TD CLASS="l">1043</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1044</TD><TD>        return ScriptRuntime.initStandardObjects(this, scope, sealed);</TD></TR><TR><TD CLASS="l">1045</TD><TD>    }</TD></TR><TR><TD CLASS="l">1046</TD><TD> </TD></TR><TR><TD CLASS="l">1047</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="65">1048</A></TD><TD>     * Get the singleton object that represents the JavaScript Undefined value.</TD></TR><TR><TD CLASS="l">1049</TD><TD>     */</TD></TR><TR><TD CLASS="l">1050</TD><TD>    public static Object getUndefinedValue()</TD></TR><TR><TD CLASS="l">1051</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1052</TD><TD>        return Undefined.instance;</TD></TR><TR><TD CLASS="l">1053</TD><TD>    }</TD></TR><TR><TD CLASS="l">1054</TD><TD> </TD></TR><TR><TD CLASS="l">1055</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1056</TD><TD>     * Evaluate a JavaScript source string.</TD></TR><TR><TD CLASS="l">1057</TD><TD>     *</TD></TR><TR><TD CLASS="l">1058</TD><TD>     * The provided source name and line number are used for error messages</TD></TR><TR><TD CLASS="l">1059</TD><TD>     * and for producing debug information.</TD></TR><TR><TD CLASS="l">1060</TD><TD>     *</TD></TR><TR><TD CLASS="l">1061</TD><TD>     * @param scope the scope to execute in</TD></TR><TR><TD CLASS="l">1062</TD><TD>     * @param source the JavaScript source</TD></TR><TR><TD CLASS="l">1063</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">1064</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">1065</TD><TD>     * @param securityDomain an arbitrary object that specifies security</TD></TR><TR><TD CLASS="l">1066</TD><TD>     *        information about the origin or owner of the script. For</TD></TR><TR><TD CLASS="l">1067</TD><TD>     *        implementations that don't care about security, this value</TD></TR><TR><TD CLASS="l">1068</TD><TD>     *        may be null.</TD></TR><TR><TD CLASS="l">1069</TD><TD>     * @return the result of evaluating the string</TD></TR><TR><TD CLASS="l">1070</TD><TD>     * @see org.mozilla.javascript.SecurityController</TD></TR><TR><TD CLASS="l">1071</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="49">1072</A></TD><TD>    public final Object evaluateString(Scriptable scope, String source,</TD></TR><TR><TD CLASS="l">1073</TD><TD>                                       String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1074</TD><TD>                                       Object securityDomain)</TD></TR><TR><TD CLASS="l">1075</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1076</TD><TD>        Script script = compileString(source, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1077</TD><TD>                                      securityDomain);</TD></TR><TR CLASS="c"><TD CLASS="l">1078</TD><TD>        if (script != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1079</TD><TD>            return script.exec(this, scope);</TD></TR><TR><TD CLASS="l">1080</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">1082</TD><TD>        }</TD></TR><TR><TD CLASS="l">1083</TD><TD>    }</TD></TR><TR><TD CLASS="l">1084</TD><TD> </TD></TR><TR><TD CLASS="l">1085</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1086</TD><TD>     * Evaluate a reader as JavaScript source.</TD></TR><TR><TD CLASS="l">1087</TD><TD>     *</TD></TR><TR><TD CLASS="l">1088</TD><TD>     * All characters of the reader are consumed.</TD></TR><TR><TD CLASS="l">1089</TD><TD>     *</TD></TR><TR><TD CLASS="l">1090</TD><TD>     * @param scope the scope to execute in</TD></TR><TR><TD CLASS="l">1091</TD><TD>     * @param in the Reader to get JavaScript source from</TD></TR><TR><TD CLASS="l">1092</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">1093</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">1094</TD><TD>     * @param securityDomain an arbitrary object that specifies security</TD></TR><TR><TD CLASS="l">1095</TD><TD>     *        information about the origin or owner of the script. For</TD></TR><TR><TD CLASS="l">1096</TD><TD>     *        implementations that don't care about security, this value</TD></TR><TR><TD CLASS="l">1097</TD><TD>     *        may be null.</TD></TR><TR><TD CLASS="l">1098</TD><TD>     * @return the result of evaluating the source</TD></TR><TR><TD CLASS="l">1099</TD><TD>     *</TD></TR><TR><TD CLASS="l">1100</TD><TD>     * @exception IOException if an IOException was generated by the Reader</TD></TR><TR><TD CLASS="l">1101</TD><TD>     */</TD></TR><TR><TD CLASS="l">1102</TD><TD>    public final Object evaluateReader(Scriptable scope, Reader in,</TD></TR><TR><TD CLASS="l"><A NAME="4b">1103</A></TD><TD>                                       String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1104</TD><TD>                                       Object securityDomain)</TD></TR><TR><TD CLASS="l">1105</TD><TD>        throws IOException</TD></TR><TR><TD CLASS="l">1106</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1107</TD><TD>        Script script = compileReader(scope, in, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1108</TD><TD>                                      securityDomain);</TD></TR><TR CLASS="c"><TD CLASS="l">1109</TD><TD>        if (script != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">1110</TD><TD>            return script.exec(this, scope);</TD></TR><TR><TD CLASS="l">1111</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1112</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">1113</TD><TD>        }</TD></TR><TR><TD CLASS="l">1114</TD><TD>    }</TD></TR><TR><TD CLASS="l">1115</TD><TD> </TD></TR><TR><TD CLASS="l">1116</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1117</TD><TD>     * Execute script that may pause execution by capturing a continuation.</TD></TR><TR><TD CLASS="l">1118</TD><TD>     * Caller must be prepared to catch a ContinuationPending exception</TD></TR><TR><TD CLASS="l">1119</TD><TD>     * and resume execution by calling</TD></TR><TR><TD CLASS="l">1120</TD><TD>     * {@link #resumeContinuation(Object, Scriptable, Object)}.</TD></TR><TR><TD CLASS="l">1121</TD><TD>     * @param script The script to execute. Script must have been compiled</TD></TR><TR><TD CLASS="l">1122</TD><TD>     *      with interpreted mode (optimization level -1)</TD></TR><TR><TD CLASS="l">1123</TD><TD>     * @param scope The scope to execute the script against</TD></TR><TR><TD CLASS="l">1124</TD><TD>     * @throws ContinuationPending if the script calls a function that results</TD></TR><TR><TD CLASS="l">1125</TD><TD>     *      in a call to {@link #captureContinuation()}</TD></TR><TR><TD CLASS="l">1126</TD><TD>     * @since 1.7 Release 2</TD></TR><TR><TD CLASS="l">1127</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="3f">1128</A></TD><TD>    public Object executeScriptWithContinuations(Script script,</TD></TR><TR><TD CLASS="l">1129</TD><TD>            Scriptable scope)</TD></TR><TR><TD CLASS="l">1130</TD><TD>        throws ContinuationPending</TD></TR><TR><TD CLASS="l">1131</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1132</TD><TD>        if (!(script instanceof InterpretedFunction) ||</TD></TR><TR><TD CLASS="l">1133</TD><TD>            !((InterpretedFunction)script).isScript())</TD></TR><TR><TD CLASS="l">1134</TD><TD>        {</TD></TR><TR><TD CLASS="l">1135</TD><TD>            // Can only be applied to scripts</TD></TR><TR CLASS="z"><TD CLASS="l">1136</TD><TD>            throw new IllegalArgumentException(&#34;Script argument was not&#34; +</TD></TR><TR><TD CLASS="l">1137</TD><TD>                    &#34; a script or was not created by interpreted mode &#34;);</TD></TR><TR><TD CLASS="l">1138</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1139</TD><TD>        return callFunctionWithContinuations((InterpretedFunction) script,</TD></TR><TR><TD CLASS="l">1140</TD><TD>                scope, ScriptRuntime.emptyArgs);</TD></TR><TR><TD CLASS="l">1141</TD><TD>    }</TD></TR><TR><TD CLASS="l">1142</TD><TD> </TD></TR><TR><TD CLASS="l">1143</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1144</TD><TD>     * Call function that may pause execution by capturing a continuation.</TD></TR><TR><TD CLASS="l">1145</TD><TD>     * Caller must be prepared to catch a ContinuationPending exception</TD></TR><TR><TD CLASS="l">1146</TD><TD>     * and resume execution by calling</TD></TR><TR><TD CLASS="l">1147</TD><TD>     * {@link #resumeContinuation(Object, Scriptable, Object)}.</TD></TR><TR><TD CLASS="l">1148</TD><TD>     * @param function The function to call. The function must have been</TD></TR><TR><TD CLASS="l">1149</TD><TD>     *      compiled with interpreted mode (optimization level -1)</TD></TR><TR><TD CLASS="l">1150</TD><TD>     * @param scope The scope to execute the script against</TD></TR><TR><TD CLASS="l">1151</TD><TD>     * @param args The arguments for the function</TD></TR><TR><TD CLASS="l">1152</TD><TD>     * @throws ContinuationPending if the script calls a function that results</TD></TR><TR><TD CLASS="l">1153</TD><TD>     *      in a call to {@link #captureContinuation()}</TD></TR><TR><TD CLASS="l">1154</TD><TD>     * @since 1.7 Release 2</TD></TR><TR><TD CLASS="l">1155</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="35">1156</A></TD><TD>    public Object callFunctionWithContinuations(Callable function,</TD></TR><TR><TD CLASS="l">1157</TD><TD>            Scriptable scope, Object[] args)</TD></TR><TR><TD CLASS="l">1158</TD><TD>        throws ContinuationPending</TD></TR><TR><TD CLASS="l">1159</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1160</TD><TD>        if (!(function instanceof InterpretedFunction)) {</TD></TR><TR><TD CLASS="l">1161</TD><TD>            // Can only be applied to scripts</TD></TR><TR CLASS="z"><TD CLASS="l">1162</TD><TD>            throw new IllegalArgumentException(&#34;Function argument was not&#34; +</TD></TR><TR><TD CLASS="l">1163</TD><TD>                    &#34; created by interpreted mode &#34;);</TD></TR><TR><TD CLASS="l">1164</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1165</TD><TD>        if (ScriptRuntime.hasTopCall(this)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1166</TD><TD>            throw new IllegalStateException(&#34;Cannot have any pending top &#34; +</TD></TR><TR><TD CLASS="l">1167</TD><TD>                    &#34;calls when executing a script with continuations&#34;);</TD></TR><TR><TD CLASS="l">1168</TD><TD>        }</TD></TR><TR><TD CLASS="l">1169</TD><TD>        // Annotate so we can check later to ensure no java code in</TD></TR><TR><TD CLASS="l">1170</TD><TD>        // intervening frames</TD></TR><TR CLASS="c"><TD CLASS="l">1171</TD><TD>        isContinuationsTopCall = true;</TD></TR><TR CLASS="c"><TD CLASS="l">1172</TD><TD>        return ScriptRuntime.doTopCall(function, this, scope, scope, args);</TD></TR><TR><TD CLASS="l">1173</TD><TD>    }</TD></TR><TR><TD CLASS="l">1174</TD><TD> </TD></TR><TR><TD CLASS="l">1175</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1176</TD><TD>     * Capture a continuation from the current execution. The execution must</TD></TR><TR><TD CLASS="l">1177</TD><TD>     * have been started via a call to</TD></TR><TR><TD CLASS="l">1178</TD><TD>     * {@link #executeScriptWithContinuations(Script, Scriptable)} or</TD></TR><TR><TD CLASS="l">1179</TD><TD>     * {@link #callFunctionWithContinuations(Callable, Scriptable, Object[])}.</TD></TR><TR><TD CLASS="l">1180</TD><TD>     * This implies that the code calling</TD></TR><TR><TD CLASS="l">1181</TD><TD>     * this method must have been called as a function from the</TD></TR><TR><TD CLASS="l">1182</TD><TD>     * JavaScript script. Also, there cannot be any non-JavaScript code</TD></TR><TR><TD CLASS="l">1183</TD><TD>     * between the JavaScript frames (e.g., a call to eval()). The</TD></TR><TR><TD CLASS="l">1184</TD><TD>     * ContinuationPending exception returned must be thrown.</TD></TR><TR><TD CLASS="l"><A NAME="52">1185</A></TD><TD>     * @return A ContinuationPending exception that must be thrown</TD></TR><TR><TD CLASS="l">1186</TD><TD>     * @since 1.7 Release 2</TD></TR><TR><TD CLASS="l">1187</TD><TD>     */</TD></TR><TR><TD CLASS="l">1188</TD><TD>    public ContinuationPending captureContinuation() {</TD></TR><TR CLASS="c"><TD CLASS="l">1189</TD><TD>        return new ContinuationPending(</TD></TR><TR><TD CLASS="l">1190</TD><TD>                Interpreter.captureContinuation(this));</TD></TR><TR><TD CLASS="l">1191</TD><TD>    }</TD></TR><TR><TD CLASS="l">1192</TD><TD> </TD></TR><TR><TD CLASS="l">1193</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1194</TD><TD>     * Restarts execution of the JavaScript suspended at the call</TD></TR><TR><TD CLASS="l">1195</TD><TD>     * to {@link #captureContinuation()}. Execution of the code will resume</TD></TR><TR><TD CLASS="l">1196</TD><TD>     * with the functionResult as the result of the call that captured the</TD></TR><TR><TD CLASS="l">1197</TD><TD>     * continuation.</TD></TR><TR><TD CLASS="l">1198</TD><TD>     * Execution of the script will either conclude normally and the</TD></TR><TR><TD CLASS="l">1199</TD><TD>     * result returned, another continuation will be captured and</TD></TR><TR><TD CLASS="l">1200</TD><TD>     * thrown, or the script will terminate abnormally and throw an exception.</TD></TR><TR><TD CLASS="l">1201</TD><TD>     * @param continuation The value returned by</TD></TR><TR><TD CLASS="l">1202</TD><TD>     * {@link ContinuationPending#getContinuation()}</TD></TR><TR><TD CLASS="l">1203</TD><TD>     * @param functionResult This value will appear to the code being resumed</TD></TR><TR><TD CLASS="l">1204</TD><TD>     *      as the result of the function that captured the continuation</TD></TR><TR><TD CLASS="l">1205</TD><TD>     * @throws ContinuationPending if another continuation is captured before</TD></TR><TR><TD CLASS="l">1206</TD><TD>     *      the code terminates</TD></TR><TR><TD CLASS="l">1207</TD><TD>     * @since 1.7 Release 2</TD></TR><TR><TD CLASS="l">1208</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="7a">1209</A></TD><TD>    public Object resumeContinuation(Object continuation,</TD></TR><TR><TD CLASS="l">1210</TD><TD>            Scriptable scope, Object functionResult)</TD></TR><TR><TD CLASS="l">1211</TD><TD>            throws ContinuationPending</TD></TR><TR><TD CLASS="l">1212</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1213</TD><TD>        Object[] args = { functionResult };</TD></TR><TR CLASS="c"><TD CLASS="l">1214</TD><TD>        return Interpreter.restartContinuation(</TD></TR><TR><TD CLASS="l">1215</TD><TD>                (org.mozilla.javascript.NativeContinuation) continuation,</TD></TR><TR><TD CLASS="l">1216</TD><TD>                this, scope, args);</TD></TR><TR><TD CLASS="l">1217</TD><TD>    }</TD></TR><TR><TD CLASS="l">1218</TD><TD> </TD></TR><TR><TD CLASS="l">1219</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1220</TD><TD>     * Check whether a string is ready to be compiled.</TD></TR><TR><TD CLASS="l">1221</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1222</TD><TD>     * stringIsCompilableUnit is intended to support interactive compilation of</TD></TR><TR><TD CLASS="l">1223</TD><TD>     * JavaScript.  If compiling the string would result in an error</TD></TR><TR><TD CLASS="l">1224</TD><TD>     * that might be fixed by appending more source, this method</TD></TR><TR><TD CLASS="l">1225</TD><TD>     * returns false.  In every other case, it returns true.</TD></TR><TR><TD CLASS="l">1226</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1227</TD><TD>     * Interactive shells may accumulate source lines, using this</TD></TR><TR><TD CLASS="l">1228</TD><TD>     * method after each new line is appended to check whether the</TD></TR><TR><TD CLASS="l">1229</TD><TD>     * statement being entered is complete.</TD></TR><TR><TD CLASS="l">1230</TD><TD>     *</TD></TR><TR><TD CLASS="l">1231</TD><TD>     * @param source the source buffer to check</TD></TR><TR><TD CLASS="l">1232</TD><TD>     * @return whether the source is ready for compilation</TD></TR><TR><TD CLASS="l"><A NAME="28">1233</A></TD><TD>     * @since 1.4 Release 2</TD></TR><TR><TD CLASS="l">1234</TD><TD>     */</TD></TR><TR><TD CLASS="l">1235</TD><TD>    public final boolean stringIsCompilableUnit(String source)</TD></TR><TR><TD CLASS="l">1236</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1237</TD><TD>        boolean errorseen = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1238</TD><TD>        CompilerEnvirons compilerEnv = new CompilerEnvirons();</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>        compilerEnv.initFromContext(this);</TD></TR><TR><TD CLASS="l">1240</TD><TD>        // no source name or source text manager, because we're just</TD></TR><TR><TD CLASS="l">1241</TD><TD>        // going to throw away the result.</TD></TR><TR CLASS="z"><TD CLASS="l">1242</TD><TD>        compilerEnv.setGeneratingSource(false);</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>        Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);</TD></TR><TR><TD CLASS="l">1244</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1245</TD><TD>            p.parse(source, null, 1);</TD></TR><TR CLASS="z"><TD CLASS="l">1246</TD><TD>        } catch (EvaluatorException ee) {</TD></TR><TR CLASS="z"><TD CLASS="l">1247</TD><TD>            errorseen = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1248</TD><TD>        }</TD></TR><TR><TD CLASS="l">1249</TD><TD>        // Return false only if an error occurred as a result of reading past</TD></TR><TR><TD CLASS="l">1250</TD><TD>        // the end of the file, i.e. if the source could be fixed by</TD></TR><TR><TD CLASS="l">1251</TD><TD>        // appending more source.</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>        if (errorseen &amp;&amp; p.eof())</TD></TR><TR CLASS="z"><TD CLASS="l">1253</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">1254</TD><TD>        else</TD></TR><TR CLASS="z"><TD CLASS="l">1255</TD><TD>            return true;</TD></TR><TR><TD CLASS="l">1256</TD><TD>    }</TD></TR><TR><TD CLASS="l">1257</TD><TD> </TD></TR><TR><TD CLASS="l">1258</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1259</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">1260</TD><TD>     * @see #compileReader(Reader in, String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1261</TD><TD>     *                     Object securityDomain)</TD></TR><TR><TD CLASS="l">1262</TD><TD>     */</TD></TR><TR><TD CLASS="l">1263</TD><TD>    public final Script compileReader(Scriptable scope, Reader in,</TD></TR><TR><TD CLASS="l"><A NAME="53">1264</A></TD><TD>                                      String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1265</TD><TD>                                      Object securityDomain)</TD></TR><TR><TD CLASS="l">1266</TD><TD>        throws IOException</TD></TR><TR><TD CLASS="l">1267</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1268</TD><TD>        return compileReader(in, sourceName, lineno, securityDomain);</TD></TR><TR><TD CLASS="l">1269</TD><TD>    }</TD></TR><TR><TD CLASS="l">1270</TD><TD> </TD></TR><TR><TD CLASS="l">1271</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1272</TD><TD>     * Compiles the source in the given reader.</TD></TR><TR><TD CLASS="l">1273</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1274</TD><TD>     * Returns a script that may later be executed.</TD></TR><TR><TD CLASS="l">1275</TD><TD>     * Will consume all the source in the reader.</TD></TR><TR><TD CLASS="l">1276</TD><TD>     *</TD></TR><TR><TD CLASS="l">1277</TD><TD>     * @param in the input reader</TD></TR><TR><TD CLASS="l">1278</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">1279</TD><TD>     * @param lineno the starting line number for reporting errors</TD></TR><TR><TD CLASS="l">1280</TD><TD>     * @param securityDomain an arbitrary object that specifies security</TD></TR><TR><TD CLASS="l">1281</TD><TD>     *        information about the origin or owner of the script. For</TD></TR><TR><TD CLASS="l">1282</TD><TD>     *        implementations that don't care about security, this value</TD></TR><TR><TD CLASS="l">1283</TD><TD>     *        may be null.</TD></TR><TR><TD CLASS="l">1284</TD><TD>     * @return a script that may later be executed</TD></TR><TR><TD CLASS="l">1285</TD><TD>     * @exception IOException if an IOException was generated by the Reader</TD></TR><TR><TD CLASS="l">1286</TD><TD>     * @see org.mozilla.javascript.Script</TD></TR><TR><TD CLASS="l">1287</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="4a">1288</A></TD><TD>    public final Script compileReader(Reader in, String sourceName,</TD></TR><TR><TD CLASS="l">1289</TD><TD>                                      int lineno, Object securityDomain)</TD></TR><TR><TD CLASS="l">1290</TD><TD>        throws IOException</TD></TR><TR><TD CLASS="l">1291</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1292</TD><TD>        if (lineno &lt; 0) {</TD></TR><TR><TD CLASS="l">1293</TD><TD>            // For compatibility IllegalArgumentException can not be thrown here</TD></TR><TR CLASS="z"><TD CLASS="l">1294</TD><TD>            lineno = 0;</TD></TR><TR><TD CLASS="l">1295</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1296</TD><TD>        return (Script) compileImpl(null, in, null, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1297</TD><TD>                                    securityDomain, false, null, null);</TD></TR><TR><TD CLASS="l">1298</TD><TD>    }</TD></TR><TR><TD CLASS="l">1299</TD><TD> </TD></TR><TR><TD CLASS="l">1300</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1301</TD><TD>     * Compiles the source in the given string.</TD></TR><TR><TD CLASS="l">1302</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1303</TD><TD>     * Returns a script that may later be executed.</TD></TR><TR><TD CLASS="l">1304</TD><TD>     *</TD></TR><TR><TD CLASS="l">1305</TD><TD>     * @param source the source string</TD></TR><TR><TD CLASS="l">1306</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">1307</TD><TD>     * @param lineno the starting line number for reporting errors. Use</TD></TR><TR><TD CLASS="l">1308</TD><TD>     *        0 if the line number is unknown.</TD></TR><TR><TD CLASS="l">1309</TD><TD>     * @param securityDomain an arbitrary object that specifies security</TD></TR><TR><TD CLASS="l">1310</TD><TD>     *        information about the origin or owner of the script. For</TD></TR><TR><TD CLASS="l">1311</TD><TD>     *        implementations that don't care about security, this value</TD></TR><TR><TD CLASS="l">1312</TD><TD>     *        may be null.</TD></TR><TR><TD CLASS="l">1313</TD><TD>     * @return a script that may later be executed</TD></TR><TR><TD CLASS="l">1314</TD><TD>     * @see org.mozilla.javascript.Script</TD></TR><TR><TD CLASS="l">1315</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="46">1316</A></TD><TD>    public final Script compileString(String source,</TD></TR><TR><TD CLASS="l">1317</TD><TD>                                      String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1318</TD><TD>                                      Object securityDomain)</TD></TR><TR><TD CLASS="l">1319</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1320</TD><TD>        if (lineno &lt; 0) {</TD></TR><TR><TD CLASS="l">1321</TD><TD>            // For compatibility IllegalArgumentException can not be thrown here</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>            lineno = 0;</TD></TR><TR><TD CLASS="l">1323</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1324</TD><TD>        return compileString(source, null, null, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1325</TD><TD>                             securityDomain);</TD></TR><TR><TD CLASS="l">1326</TD><TD>    }</TD></TR><TR><TD CLASS="l">1327</TD><TD> </TD></TR><TR><TD CLASS="l">1328</TD><TD>    final Script compileString(String source,</TD></TR><TR><TD CLASS="l">1329</TD><TD>                               Evaluator compiler,</TD></TR><TR><TD CLASS="l">1330</TD><TD>                               ErrorReporter compilationErrorReporter,</TD></TR><TR><TD CLASS="l"><A NAME="3e">1331</A></TD><TD>                               String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1332</TD><TD>                               Object securityDomain)</TD></TR><TR><TD CLASS="l">1333</TD><TD>    {</TD></TR><TR><TD CLASS="l">1334</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">1335</TD><TD>            return (Script) compileImpl(null, null, source, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1336</TD><TD>                                        securityDomain, false,</TD></TR><TR><TD CLASS="l">1337</TD><TD>                                        compiler, compilationErrorReporter);</TD></TR><TR CLASS="z"><TD CLASS="l">1338</TD><TD>        } catch (IOException ex) {</TD></TR><TR><TD CLASS="l">1339</TD><TD>            // Should not happen when dealing with source as string</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>            throw new RuntimeException();</TD></TR><TR><TD CLASS="l">1341</TD><TD>        }</TD></TR><TR><TD CLASS="l">1342</TD><TD>    }</TD></TR><TR><TD CLASS="l">1343</TD><TD> </TD></TR><TR><TD CLASS="l">1344</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1345</TD><TD>     * Compile a JavaScript function.</TD></TR><TR><TD CLASS="l">1346</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1347</TD><TD>     * The function source must be a function definition as defined by</TD></TR><TR><TD CLASS="l">1348</TD><TD>     * ECMA (e.g., &#34;function f(a) { return a; }&#34;).</TD></TR><TR><TD CLASS="l">1349</TD><TD>     *</TD></TR><TR><TD CLASS="l">1350</TD><TD>     * @param scope the scope to compile relative to</TD></TR><TR><TD CLASS="l">1351</TD><TD>     * @param source the function definition source</TD></TR><TR><TD CLASS="l">1352</TD><TD>     * @param sourceName a string describing the source, such as a filename</TD></TR><TR><TD CLASS="l">1353</TD><TD>     * @param lineno the starting line number</TD></TR><TR><TD CLASS="l">1354</TD><TD>     * @param securityDomain an arbitrary object that specifies security</TD></TR><TR><TD CLASS="l">1355</TD><TD>     *        information about the origin or owner of the script. For</TD></TR><TR><TD CLASS="l">1356</TD><TD>     *        implementations that don't care about security, this value</TD></TR><TR><TD CLASS="l">1357</TD><TD>     *        may be null.</TD></TR><TR><TD CLASS="l">1358</TD><TD>     * @return a Function that may later be called</TD></TR><TR><TD CLASS="l">1359</TD><TD>     * @see org.mozilla.javascript.Function</TD></TR><TR><TD CLASS="l">1360</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="7">1361</A></TD><TD>    public final Function compileFunction(Scriptable scope, String source,</TD></TR><TR><TD CLASS="l">1362</TD><TD>                                          String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1363</TD><TD>                                          Object securityDomain)</TD></TR><TR><TD CLASS="l">1364</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1365</TD><TD>        return compileFunction(scope, source, null, null, sourceName, lineno,</TD></TR><TR><TD CLASS="l">1366</TD><TD>                               securityDomain);</TD></TR><TR><TD CLASS="l">1367</TD><TD>    }</TD></TR><TR><TD CLASS="l">1368</TD><TD> </TD></TR><TR><TD CLASS="l">1369</TD><TD>    final Function compileFunction(Scriptable scope, String source,</TD></TR><TR><TD CLASS="l">1370</TD><TD>                                   Evaluator compiler,</TD></TR><TR><TD CLASS="l">1371</TD><TD>                                   ErrorReporter compilationErrorReporter,</TD></TR><TR><TD CLASS="l"><A NAME="3d">1372</A></TD><TD>                                   String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">1373</TD><TD>                                   Object securityDomain)</TD></TR><TR><TD CLASS="l">1374</TD><TD>    {</TD></TR><TR><TD CLASS="l">1375</TD><TD>        try {</TD></TR><TR CLASS="c"><TD CLASS="l">1376</TD><TD>            return (Function) compileImpl(scope, null, source, sourceName,</TD></TR><TR><TD CLASS="l">1377</TD><TD>                                          lineno, securityDomain, true,</TD></TR><TR><TD CLASS="l">1378</TD><TD>                                          compiler, compilationErrorReporter);</TD></TR><TR><TD CLASS="l">1379</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1380</TD><TD>        catch (IOException ioe) {</TD></TR><TR><TD CLASS="l">1381</TD><TD>            // Should never happen because we just made the reader</TD></TR><TR><TD CLASS="l">1382</TD><TD>            // from a String</TD></TR><TR CLASS="z"><TD CLASS="l">1383</TD><TD>            throw new RuntimeException();</TD></TR><TR><TD CLASS="l">1384</TD><TD>        }</TD></TR><TR><TD CLASS="l">1385</TD><TD>    }</TD></TR><TR><TD CLASS="l">1386</TD><TD> </TD></TR><TR><TD CLASS="l">1387</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1388</TD><TD>     * Decompile the script.</TD></TR><TR><TD CLASS="l">1389</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1390</TD><TD>     * The canonical source of the script is returned.</TD></TR><TR><TD CLASS="l">1391</TD><TD>     *</TD></TR><TR><TD CLASS="l">1392</TD><TD>     * @param script the script to decompile</TD></TR><TR><TD CLASS="l">1393</TD><TD>     * @param indent the number of spaces to indent the result</TD></TR><TR><TD CLASS="l"><A NAME="57">1394</A></TD><TD>     * @return a string representing the script source</TD></TR><TR><TD CLASS="l">1395</TD><TD>     */</TD></TR><TR><TD CLASS="l">1396</TD><TD>    public final String decompileScript(Script script, int indent)</TD></TR><TR><TD CLASS="l">1397</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1398</TD><TD>        NativeFunction scriptImpl = (NativeFunction) script;</TD></TR><TR CLASS="c"><TD CLASS="l">1399</TD><TD>        return scriptImpl.decompile(indent, 0);</TD></TR><TR><TD CLASS="l">1400</TD><TD>    }</TD></TR><TR><TD CLASS="l">1401</TD><TD> </TD></TR><TR><TD CLASS="l">1402</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1403</TD><TD>     * Decompile a JavaScript Function.</TD></TR><TR><TD CLASS="l">1404</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1405</TD><TD>     * Decompiles a previously compiled JavaScript function object to</TD></TR><TR><TD CLASS="l">1406</TD><TD>     * canonical source.</TD></TR><TR><TD CLASS="l">1407</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1408</TD><TD>     * Returns function body of '[native code]' if no decompilation</TD></TR><TR><TD CLASS="l">1409</TD><TD>     * information is available.</TD></TR><TR><TD CLASS="l">1410</TD><TD>     *</TD></TR><TR><TD CLASS="l">1411</TD><TD>     * @param fun the JavaScript function to decompile</TD></TR><TR><TD CLASS="l">1412</TD><TD>     * @param indent the number of spaces to indent the result</TD></TR><TR><TD CLASS="l"><A NAME="8">1413</A></TD><TD>     * @return a string representing the function source</TD></TR><TR><TD CLASS="l">1414</TD><TD>     */</TD></TR><TR><TD CLASS="l">1415</TD><TD>    public final String decompileFunction(Function fun, int indent)</TD></TR><TR><TD CLASS="l">1416</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1417</TD><TD>        if (fun instanceof BaseFunction)</TD></TR><TR CLASS="z"><TD CLASS="l">1418</TD><TD>            return ((BaseFunction)fun).decompile(indent, 0);</TD></TR><TR><TD CLASS="l">1419</TD><TD>        else</TD></TR><TR CLASS="z"><TD CLASS="l">1420</TD><TD>            return &#34;function &#34; + fun.getClassName() +</TD></TR><TR><TD CLASS="l">1421</TD><TD>                   &#34;() {\n\t[native code]\n}\n&#34;;</TD></TR><TR><TD CLASS="l">1422</TD><TD>    }</TD></TR><TR><TD CLASS="l">1423</TD><TD> </TD></TR><TR><TD CLASS="l">1424</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1425</TD><TD>     * Decompile the body of a JavaScript Function.</TD></TR><TR><TD CLASS="l">1426</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1427</TD><TD>     * Decompiles the body a previously compiled JavaScript Function</TD></TR><TR><TD CLASS="l">1428</TD><TD>     * object to canonical source, omitting the function header and</TD></TR><TR><TD CLASS="l">1429</TD><TD>     * trailing brace.</TD></TR><TR><TD CLASS="l">1430</TD><TD>     *</TD></TR><TR><TD CLASS="l">1431</TD><TD>     * Returns '[native code]' if no decompilation information is available.</TD></TR><TR><TD CLASS="l">1432</TD><TD>     *</TD></TR><TR><TD CLASS="l">1433</TD><TD>     * @param fun the JavaScript function to decompile</TD></TR><TR><TD CLASS="l">1434</TD><TD>     * @param indent the number of spaces to indent the result</TD></TR><TR><TD CLASS="l"><A NAME="9">1435</A></TD><TD>     * @return a string representing the function body source.</TD></TR><TR><TD CLASS="l">1436</TD><TD>     */</TD></TR><TR><TD CLASS="l">1437</TD><TD>    public final String decompileFunctionBody(Function fun, int indent)</TD></TR><TR><TD CLASS="l">1438</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>        if (fun instanceof BaseFunction) {</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>            BaseFunction bf = (BaseFunction)fun;</TD></TR><TR CLASS="z"><TD CLASS="l">1441</TD><TD>            return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);</TD></TR><TR><TD CLASS="l">1442</TD><TD>        }</TD></TR><TR><TD CLASS="l">1443</TD><TD>        // ALERT: not sure what the right response here is.</TD></TR><TR CLASS="z"><TD CLASS="l">1444</TD><TD>        return &#34;[native code]\n&#34;;</TD></TR><TR><TD CLASS="l">1445</TD><TD>    }</TD></TR><TR><TD CLASS="l">1446</TD><TD> </TD></TR><TR><TD CLASS="l">1447</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1448</TD><TD>     * Create a new JavaScript object.</TD></TR><TR><TD CLASS="l">1449</TD><TD>     *</TD></TR><TR><TD CLASS="l">1450</TD><TD>     * Equivalent to evaluating &#34;new Object()&#34;.</TD></TR><TR><TD CLASS="l">1451</TD><TD>     * @param scope the scope to search for the constructor and to evaluate</TD></TR><TR><TD CLASS="l">1452</TD><TD>     *              against</TD></TR><TR><TD CLASS="l"><A NAME="72">1453</A></TD><TD>     * @return the new object</TD></TR><TR><TD CLASS="l">1454</TD><TD>     */</TD></TR><TR><TD CLASS="l">1455</TD><TD>    public Scriptable newObject(Scriptable scope)</TD></TR><TR><TD CLASS="l">1456</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1457</TD><TD>        NativeObject result = new NativeObject();</TD></TR><TR CLASS="c"><TD CLASS="l">1458</TD><TD>        ScriptRuntime.setBuiltinProtoAndParent(result, scope,</TD></TR><TR><TD CLASS="l">1459</TD><TD>                TopLevel.Builtins.Object);</TD></TR><TR CLASS="c"><TD CLASS="l">1460</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1461</TD><TD>    }</TD></TR><TR><TD CLASS="l">1462</TD><TD> </TD></TR><TR><TD CLASS="l">1463</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1464</TD><TD>     * Create a new JavaScript object by executing the named constructor.</TD></TR><TR><TD CLASS="l">1465</TD><TD>     *</TD></TR><TR><TD CLASS="l">1466</TD><TD>     * The call &lt;code&gt;newObject(scope, &#34;Foo&#34;)&lt;/code&gt; is equivalent to</TD></TR><TR><TD CLASS="l">1467</TD><TD>     * evaluating &#34;new Foo()&#34;.</TD></TR><TR><TD CLASS="l">1468</TD><TD>     *</TD></TR><TR><TD CLASS="l">1469</TD><TD>     * @param scope the scope to search for the constructor and to evaluate against</TD></TR><TR><TD CLASS="l">1470</TD><TD>     * @param constructorName the name of the constructor to call</TD></TR><TR><TD CLASS="l"><A NAME="13">1471</A></TD><TD>     * @return the new object</TD></TR><TR><TD CLASS="l">1472</TD><TD>     */</TD></TR><TR><TD CLASS="l">1473</TD><TD>    public Scriptable newObject(Scriptable scope, String constructorName)</TD></TR><TR><TD CLASS="l">1474</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1475</TD><TD>        return newObject(scope, constructorName, ScriptRuntime.emptyArgs);</TD></TR><TR><TD CLASS="l">1476</TD><TD>    }</TD></TR><TR><TD CLASS="l">1477</TD><TD> </TD></TR><TR><TD CLASS="l">1478</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1479</TD><TD>     * Creates a new JavaScript object by executing the named constructor.</TD></TR><TR><TD CLASS="l">1480</TD><TD>     *</TD></TR><TR><TD CLASS="l">1481</TD><TD>     * Searches &lt;code&gt;scope&lt;/code&gt; for the named constructor, calls it with</TD></TR><TR><TD CLASS="l">1482</TD><TD>     * the given arguments, and returns the result.&lt;p&gt;</TD></TR><TR><TD CLASS="l">1483</TD><TD>     *</TD></TR><TR><TD CLASS="l">1484</TD><TD>     * The code</TD></TR><TR><TD CLASS="l">1485</TD><TD>     * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">1486</TD><TD>     * Object[] args = { &#34;a&#34;, &#34;b&#34; };</TD></TR><TR><TD CLASS="l">1487</TD><TD>     * newObject(scope, &#34;Foo&#34;, args)&lt;/pre&gt;</TD></TR><TR><TD CLASS="l">1488</TD><TD>     * is equivalent to evaluating &#34;new Foo('a', 'b')&#34;, assuming that the Foo</TD></TR><TR><TD CLASS="l">1489</TD><TD>     * constructor has been defined in &lt;code&gt;scope&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1490</TD><TD>     *</TD></TR><TR><TD CLASS="l">1491</TD><TD>     * @param scope The scope to search for the constructor and to evaluate</TD></TR><TR><TD CLASS="l">1492</TD><TD>     *              against</TD></TR><TR><TD CLASS="l">1493</TD><TD>     * @param constructorName the name of the constructor to call</TD></TR><TR><TD CLASS="l">1494</TD><TD>     * @param args the array of arguments for the constructor</TD></TR><TR><TD CLASS="l">1495</TD><TD>     * @return the new object</TD></TR><TR><TD CLASS="l"><A NAME="4c">1496</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1497</TD><TD>    public Scriptable newObject(Scriptable scope, String constructorName,</TD></TR><TR><TD CLASS="l">1498</TD><TD>                                Object[] args)</TD></TR><TR><TD CLASS="l">1499</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1500</TD><TD>        scope = ScriptableObject.getTopLevelScope(scope);</TD></TR><TR CLASS="c"><TD CLASS="l">1501</TD><TD>        Function ctor = ScriptRuntime.getExistingCtor(this, scope,</TD></TR><TR><TD CLASS="l">1502</TD><TD>                                                      constructorName);</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="83% line coverage (10 out of 12 instructions)">1503</TD><TD TITLE="83% line coverage (10 out of 12 instructions)">        if (args == null) { args = ScriptRuntime.emptyArgs; }</TD></TR><TR CLASS="c"><TD CLASS="l">1504</TD><TD>        return ctor.construct(this, scope, args);</TD></TR><TR><TD CLASS="l">1505</TD><TD>    }</TD></TR><TR><TD CLASS="l">1506</TD><TD> </TD></TR><TR><TD CLASS="l">1507</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1508</TD><TD>     * Create an array with a specified initial length.</TD></TR><TR><TD CLASS="l">1509</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1510</TD><TD>     * @param scope the scope to create the object in</TD></TR><TR><TD CLASS="l">1511</TD><TD>     * @param length the initial length (JavaScript arrays may have</TD></TR><TR><TD CLASS="l">1512</TD><TD>     *               additional properties added dynamically).</TD></TR><TR><TD CLASS="l"><A NAME="71">1513</A></TD><TD>     * @return the new array object</TD></TR><TR><TD CLASS="l">1514</TD><TD>     */</TD></TR><TR><TD CLASS="l">1515</TD><TD>    public Scriptable newArray(Scriptable scope, int length)</TD></TR><TR><TD CLASS="l">1516</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1517</TD><TD>        NativeArray result = new NativeArray(length);</TD></TR><TR CLASS="c"><TD CLASS="l">1518</TD><TD>        ScriptRuntime.setBuiltinProtoAndParent(result, scope,</TD></TR><TR><TD CLASS="l">1519</TD><TD>                TopLevel.Builtins.Array);</TD></TR><TR CLASS="c"><TD CLASS="l">1520</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1521</TD><TD>    }</TD></TR><TR><TD CLASS="l">1522</TD><TD> </TD></TR><TR><TD CLASS="l">1523</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1524</TD><TD>     * Create an array with a set of initial elements.</TD></TR><TR><TD CLASS="l">1525</TD><TD>     *</TD></TR><TR><TD CLASS="l">1526</TD><TD>     * @param scope the scope to create the object in.</TD></TR><TR><TD CLASS="l">1527</TD><TD>     * @param elements the initial elements. Each object in this array</TD></TR><TR><TD CLASS="l">1528</TD><TD>     *                 must be an acceptable JavaScript type and type</TD></TR><TR><TD CLASS="l">1529</TD><TD>     *                 of array should be exactly Object[], not</TD></TR><TR><TD CLASS="l">1530</TD><TD>     *                 SomeObjectSubclass[].</TD></TR><TR><TD CLASS="l"><A NAME="43">1531</A></TD><TD>     * @return the new array object.</TD></TR><TR><TD CLASS="l">1532</TD><TD>     */</TD></TR><TR><TD CLASS="l">1533</TD><TD>    public Scriptable newArray(Scriptable scope, Object[] elements)</TD></TR><TR><TD CLASS="l">1534</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1535</TD><TD>        if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass)</TD></TR><TR CLASS="z"><TD CLASS="l">1536</TD><TD>            throw new IllegalArgumentException();</TD></TR><TR CLASS="c"><TD CLASS="l">1537</TD><TD>        NativeArray result = new NativeArray(elements);</TD></TR><TR CLASS="c"><TD CLASS="l">1538</TD><TD>        ScriptRuntime.setBuiltinProtoAndParent(result, scope,</TD></TR><TR><TD CLASS="l">1539</TD><TD>                TopLevel.Builtins.Array);</TD></TR><TR CLASS="c"><TD CLASS="l">1540</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">1541</TD><TD>    }</TD></TR><TR><TD CLASS="l">1542</TD><TD> </TD></TR><TR><TD CLASS="l">1543</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1544</TD><TD>     * Get the elements of a JavaScript array.</TD></TR><TR><TD CLASS="l">1545</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1546</TD><TD>     * If the object defines a length property convertible to double number,</TD></TR><TR><TD CLASS="l">1547</TD><TD>     * then the number is converted Uint32 value as defined in Ecma 9.6</TD></TR><TR><TD CLASS="l">1548</TD><TD>     * and Java array of that size is allocated.</TD></TR><TR><TD CLASS="l">1549</TD><TD>     * The array is initialized with the values obtained by</TD></TR><TR><TD CLASS="l">1550</TD><TD>     * calling get() on object for each value of i in [0,length-1]. If</TD></TR><TR><TD CLASS="l">1551</TD><TD>     * there is not a defined value for a property the Undefined value</TD></TR><TR><TD CLASS="l">1552</TD><TD>     * is used to initialize the corresponding element in the array. The</TD></TR><TR><TD CLASS="l">1553</TD><TD>     * Java array is then returned.</TD></TR><TR><TD CLASS="l">1554</TD><TD>     * If the object doesn't define a length property or it is not a number,</TD></TR><TR><TD CLASS="l">1555</TD><TD>     * empty array is returned.</TD></TR><TR><TD CLASS="l">1556</TD><TD>     * @param object the JavaScript array or array-like object</TD></TR><TR><TD CLASS="l">1557</TD><TD>     * @return a Java array of objects</TD></TR><TR><TD CLASS="l"><A NAME="5d">1558</A></TD><TD>     * @since 1.4 release 2</TD></TR><TR><TD CLASS="l">1559</TD><TD>     */</TD></TR><TR><TD CLASS="l">1560</TD><TD>    public final Object[] getElements(Scriptable object)</TD></TR><TR><TD CLASS="l">1561</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1562</TD><TD>        return ScriptRuntime.getArrayElements(object);</TD></TR><TR><TD CLASS="l">1563</TD><TD>    }</TD></TR><TR><TD CLASS="l">1564</TD><TD> </TD></TR><TR><TD CLASS="l">1565</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1566</TD><TD>     * Convert the value to a JavaScript boolean value.</TD></TR><TR><TD CLASS="l">1567</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1568</TD><TD>     * See ECMA 9.2.</TD></TR><TR><TD CLASS="l">1569</TD><TD>     *</TD></TR><TR><TD CLASS="l">1570</TD><TD>     * @param value a JavaScript value</TD></TR><TR><TD CLASS="l">1571</TD><TD>     * @return the corresponding boolean value converted using</TD></TR><TR><TD CLASS="l"><A NAME="29">1572</A></TD><TD>     *         the ECMA rules</TD></TR><TR><TD CLASS="l">1573</TD><TD>     */</TD></TR><TR><TD CLASS="l">1574</TD><TD>    public static boolean toBoolean(Object value)</TD></TR><TR><TD CLASS="l">1575</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1576</TD><TD>        return ScriptRuntime.toBoolean(value);</TD></TR><TR><TD CLASS="l">1577</TD><TD>    }</TD></TR><TR><TD CLASS="l">1578</TD><TD> </TD></TR><TR><TD CLASS="l">1579</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1580</TD><TD>     * Convert the value to a JavaScript Number value.</TD></TR><TR><TD CLASS="l">1581</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1582</TD><TD>     * Returns a Java double for the JavaScript Number.</TD></TR><TR><TD CLASS="l">1583</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1584</TD><TD>     * See ECMA 9.3.</TD></TR><TR><TD CLASS="l">1585</TD><TD>     *</TD></TR><TR><TD CLASS="l">1586</TD><TD>     * @param value a JavaScript value</TD></TR><TR><TD CLASS="l">1587</TD><TD>     * @return the corresponding double value converted using</TD></TR><TR><TD CLASS="l"><A NAME="7c">1588</A></TD><TD>     *         the ECMA rules</TD></TR><TR><TD CLASS="l">1589</TD><TD>     */</TD></TR><TR><TD CLASS="l">1590</TD><TD>    public static double toNumber(Object value)</TD></TR><TR><TD CLASS="l">1591</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1592</TD><TD>        return ScriptRuntime.toNumber(value);</TD></TR><TR><TD CLASS="l">1593</TD><TD>    }</TD></TR><TR><TD CLASS="l">1594</TD><TD> </TD></TR><TR><TD CLASS="l">1595</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1596</TD><TD>     * Convert the value to a JavaScript String value.</TD></TR><TR><TD CLASS="l">1597</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1598</TD><TD>     * See ECMA 9.8.</TD></TR><TR><TD CLASS="l">1599</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1600</TD><TD>     * @param value a JavaScript value</TD></TR><TR><TD CLASS="l">1601</TD><TD>     * @return the corresponding String value converted using</TD></TR><TR><TD CLASS="l"><A NAME="7e">1602</A></TD><TD>     *         the ECMA rules</TD></TR><TR><TD CLASS="l">1603</TD><TD>     */</TD></TR><TR><TD CLASS="l">1604</TD><TD>    public static String toString(Object value)</TD></TR><TR><TD CLASS="l">1605</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1606</TD><TD>        return ScriptRuntime.toString(value);</TD></TR><TR><TD CLASS="l">1607</TD><TD>    }</TD></TR><TR><TD CLASS="l">1608</TD><TD> </TD></TR><TR><TD CLASS="l">1609</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1610</TD><TD>     * Convert the value to an JavaScript object value.</TD></TR><TR><TD CLASS="l">1611</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1612</TD><TD>     * Note that a scope must be provided to look up the constructors</TD></TR><TR><TD CLASS="l">1613</TD><TD>     * for Number, Boolean, and String.</TD></TR><TR><TD CLASS="l">1614</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1615</TD><TD>     * See ECMA 9.9.</TD></TR><TR><TD CLASS="l">1616</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1617</TD><TD>     * Additionally, arbitrary Java objects and classes will be</TD></TR><TR><TD CLASS="l">1618</TD><TD>     * wrapped in a Scriptable object with its Java fields and methods</TD></TR><TR><TD CLASS="l">1619</TD><TD>     * reflected as JavaScript properties of the object.</TD></TR><TR><TD CLASS="l">1620</TD><TD>     *</TD></TR><TR><TD CLASS="l">1621</TD><TD>     * @param value any Java object</TD></TR><TR><TD CLASS="l">1622</TD><TD>     * @param scope global scope containing constructors for Number,</TD></TR><TR><TD CLASS="l">1623</TD><TD>     *              Boolean, and String</TD></TR><TR><TD CLASS="l"><A NAME="7d">1624</A></TD><TD>     * @return new JavaScript object</TD></TR><TR><TD CLASS="l">1625</TD><TD>     */</TD></TR><TR><TD CLASS="l">1626</TD><TD>    public static Scriptable toObject(Object value, Scriptable scope)</TD></TR><TR><TD CLASS="l">1627</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1628</TD><TD>        return ScriptRuntime.toObject(scope, value);</TD></TR><TR><TD CLASS="l">1629</TD><TD>    }</TD></TR><TR><TD CLASS="l">1630</TD><TD> </TD></TR><TR><TD CLASS="l">1631</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1632</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">1633</TD><TD>     * @see #toObject(Object, Scriptable)</TD></TR><TR><TD CLASS="l"><A NAME="2a">1634</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1635</TD><TD>    public static Scriptable toObject(Object value, Scriptable scope,</TD></TR><TR><TD CLASS="l">1636</TD><TD>                                      Class&lt;?&gt; staticType)</TD></TR><TR><TD CLASS="l">1637</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1638</TD><TD>        return ScriptRuntime.toObject(scope, value);</TD></TR><TR><TD CLASS="l">1639</TD><TD>    }</TD></TR><TR><TD CLASS="l">1640</TD><TD> </TD></TR><TR><TD CLASS="l">1641</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1642</TD><TD>     * Convenient method to convert java value to its closest representation</TD></TR><TR><TD CLASS="l">1643</TD><TD>     * in JavaScript.</TD></TR><TR><TD CLASS="l">1644</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1645</TD><TD>     * If value is an instance of String, Number, Boolean, Function or</TD></TR><TR><TD CLASS="l">1646</TD><TD>     * Scriptable, it is returned as it and will be treated as the corresponding</TD></TR><TR><TD CLASS="l">1647</TD><TD>     * JavaScript type of string, number, boolean, function and object.</TD></TR><TR><TD CLASS="l">1648</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1649</TD><TD>     * Note that for Number instances during any arithmetic operation in</TD></TR><TR><TD CLASS="l">1650</TD><TD>     * JavaScript the engine will always use the result of</TD></TR><TR><TD CLASS="l">1651</TD><TD>     * &lt;tt&gt;Number.doubleValue()&lt;/tt&gt; resulting in a precision loss if</TD></TR><TR><TD CLASS="l">1652</TD><TD>     * the number can not fit into double.</TD></TR><TR><TD CLASS="l">1653</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1654</TD><TD>     * If value is an instance of Character, it will be converted to string of</TD></TR><TR><TD CLASS="l">1655</TD><TD>     * length 1 and its JavaScript type will be string.</TD></TR><TR><TD CLASS="l">1656</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1657</TD><TD>     * The rest of values will be wrapped as LiveConnect objects</TD></TR><TR><TD CLASS="l">1658</TD><TD>     * by calling {@link WrapFactory#wrap(Context cx, Scriptable scope,</TD></TR><TR><TD CLASS="l">1659</TD><TD>     * Object obj, Class staticType)} as in:</TD></TR><TR><TD CLASS="l">1660</TD><TD>     * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">1661</TD><TD>     *    Context cx = Context.getCurrentContext();</TD></TR><TR><TD CLASS="l">1662</TD><TD>     *    return cx.getWrapFactory().wrap(cx, scope, value, null);</TD></TR><TR><TD CLASS="l">1663</TD><TD>     * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">1664</TD><TD>     *</TD></TR><TR><TD CLASS="l">1665</TD><TD>     * @param value any Java object</TD></TR><TR><TD CLASS="l">1666</TD><TD>     * @param scope top scope object</TD></TR><TR><TD CLASS="l"><A NAME="42">1667</A></TD><TD>     * @return value suitable to pass to any API that takes JavaScript values.</TD></TR><TR><TD CLASS="l">1668</TD><TD>     */</TD></TR><TR><TD CLASS="l">1669</TD><TD>    public static Object javaToJS(Object value, Scriptable scope)</TD></TR><TR><TD CLASS="l">1670</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1671</TD><TD>        if (value instanceof String || value instanceof Number</TD></TR><TR><TD CLASS="l">1672</TD><TD>            || value instanceof Boolean || value instanceof Scriptable)</TD></TR><TR><TD CLASS="l">1673</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1674</TD><TD>            return value;</TD></TR><TR CLASS="c"><TD CLASS="l">1675</TD><TD>        } else if (value instanceof Character) {</TD></TR><TR CLASS="z"><TD CLASS="l">1676</TD><TD>            return String.valueOf(((Character)value).charValue());</TD></TR><TR><TD CLASS="l">1677</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">1678</TD><TD>            Context cx = Context.getContext();</TD></TR><TR CLASS="c"><TD CLASS="l">1679</TD><TD>            return cx.getWrapFactory().wrap(cx, scope, value, null);</TD></TR><TR><TD CLASS="l">1680</TD><TD>        }</TD></TR><TR><TD CLASS="l">1681</TD><TD>    }</TD></TR><TR><TD CLASS="l">1682</TD><TD> </TD></TR><TR><TD CLASS="l">1683</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1684</TD><TD>     * Convert a JavaScript value into the desired type.</TD></TR><TR><TD CLASS="l">1685</TD><TD>     * Uses the semantics defined with LiveConnect3 and throws an</TD></TR><TR><TD CLASS="l">1686</TD><TD>     * Illegal argument exception if the conversion cannot be performed.</TD></TR><TR><TD CLASS="l">1687</TD><TD>     * @param value the JavaScript value to convert</TD></TR><TR><TD CLASS="l">1688</TD><TD>     * @param desiredType the Java type to convert to. Primitive Java</TD></TR><TR><TD CLASS="l">1689</TD><TD>     *        types are represented using the TYPE fields in the corresponding</TD></TR><TR><TD CLASS="l">1690</TD><TD>     *        wrapper class in java.lang.</TD></TR><TR><TD CLASS="l">1691</TD><TD>     * @return the converted value</TD></TR><TR><TD CLASS="l">1692</TD><TD>     * @throws EvaluatorException if the conversion cannot be performed</TD></TR><TR><TD CLASS="l"><A NAME="70">1693</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1694</TD><TD>    public static Object jsToJava(Object value, Class&lt;?&gt; desiredType)</TD></TR><TR><TD CLASS="l">1695</TD><TD>        throws EvaluatorException</TD></TR><TR><TD CLASS="l">1696</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1697</TD><TD>        return NativeJavaObject.coerceTypeImpl(desiredType, value);</TD></TR><TR><TD CLASS="l">1698</TD><TD>    }</TD></TR><TR><TD CLASS="l">1699</TD><TD> </TD></TR><TR><TD CLASS="l">1700</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1701</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">1702</TD><TD>     * @see #jsToJava(Object, Class)</TD></TR><TR><TD CLASS="l">1703</TD><TD>     * @throws IllegalArgumentException if the conversion cannot be performed.</TD></TR><TR><TD CLASS="l">1704</TD><TD>     *         Note that {@link #jsToJava(Object, Class)} throws</TD></TR><TR><TD CLASS="l">1705</TD><TD>     *         {@link EvaluatorException} instead.</TD></TR><TR><TD CLASS="l">1706</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="2b">1707</A></TD><TD>    public static Object toType(Object value, Class&lt;?&gt; desiredType)</TD></TR><TR><TD CLASS="l">1708</TD><TD>        throws IllegalArgumentException</TD></TR><TR><TD CLASS="l">1709</TD><TD>    {</TD></TR><TR><TD CLASS="l">1710</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1711</TD><TD>            return jsToJava(value, desiredType);</TD></TR><TR CLASS="z"><TD CLASS="l">1712</TD><TD>        } catch (EvaluatorException ex) {</TD></TR><TR><TD CLASS="l">1713</TD><TD>            IllegalArgumentException</TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>                ex2 = new IllegalArgumentException(ex.getMessage());</TD></TR><TR CLASS="z"><TD CLASS="l">1715</TD><TD>            Kit.initCause(ex2, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">1716</TD><TD>            throw ex2;</TD></TR><TR><TD CLASS="l">1717</TD><TD>        }</TD></TR><TR><TD CLASS="l">1718</TD><TD>    }</TD></TR><TR><TD CLASS="l">1719</TD><TD> </TD></TR><TR><TD CLASS="l">1720</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1721</TD><TD>     * Rethrow the exception wrapping it as the script runtime exception.</TD></TR><TR><TD CLASS="l">1722</TD><TD>     * Unless the exception is instance of {@link EcmaError} or</TD></TR><TR><TD CLASS="l">1723</TD><TD>     * {@link EvaluatorException} it will be wrapped as</TD></TR><TR><TD CLASS="l">1724</TD><TD>     * {@link WrappedException}, a subclass of {@link EvaluatorException}.</TD></TR><TR><TD CLASS="l">1725</TD><TD>     * The resulting exception object always contains</TD></TR><TR><TD CLASS="l">1726</TD><TD>     * source name and line number of script that triggered exception.</TD></TR><TR><TD CLASS="l">1727</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1728</TD><TD>     * This method always throws an exception, its return value is provided</TD></TR><TR><TD CLASS="l">1729</TD><TD>     * only for convenience to allow a usage like:</TD></TR><TR><TD CLASS="l">1730</TD><TD>     * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">1731</TD><TD>     * throw Context.throwAsScriptRuntimeEx(ex);</TD></TR><TR><TD CLASS="l">1732</TD><TD>     * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">1733</TD><TD>     * to indicate that code after the method is unreachable.</TD></TR><TR><TD CLASS="l">1734</TD><TD>     * @throws EvaluatorException</TD></TR><TR><TD CLASS="l"><A NAME="32">1735</A></TD><TD>     * @throws EcmaError</TD></TR><TR><TD CLASS="l">1736</TD><TD>     */</TD></TR><TR><TD CLASS="l">1737</TD><TD>    public static RuntimeException throwAsScriptRuntimeEx(Throwable e)</TD></TR><TR><TD CLASS="l">1738</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1739</TD><TD>        while ((e instanceof InvocationTargetException)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1740</TD><TD>            e = ((InvocationTargetException) e).getTargetException();</TD></TR><TR><TD CLASS="l">1741</TD><TD>        }</TD></TR><TR><TD CLASS="l">1742</TD><TD>        // special handling of Error so scripts would not catch them</TD></TR><TR CLASS="c"><TD CLASS="l">1743</TD><TD>        if (e instanceof Error) {</TD></TR><TR CLASS="z"><TD CLASS="l">1744</TD><TD>            Context cx = getContext();</TD></TR><TR CLASS="z"><TD CLASS="l">1745</TD><TD>            if (cx == null ||</TD></TR><TR><TD CLASS="l">1746</TD><TD>                !cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS))</TD></TR><TR><TD CLASS="l">1747</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1748</TD><TD>                throw (Error)e;</TD></TR><TR><TD CLASS="l">1749</TD><TD>            }</TD></TR><TR><TD CLASS="l">1750</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1751</TD><TD>        if (e instanceof RhinoException) {</TD></TR><TR CLASS="c"><TD CLASS="l">1752</TD><TD>            throw (RhinoException)e;</TD></TR><TR><TD CLASS="l">1753</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1754</TD><TD>        throw new WrappedException(e);</TD></TR><TR><TD CLASS="l">1755</TD><TD>    }</TD></TR><TR><TD CLASS="l">1756</TD><TD> </TD></TR><TR><TD CLASS="l">1757</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1758</TD><TD>     * Tell whether debug information is being generated.</TD></TR><TR><TD CLASS="l"><A NAME="6b">1759</A></TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l">1760</TD><TD>     */</TD></TR><TR><TD CLASS="l">1761</TD><TD>    public final boolean isGeneratingDebug()</TD></TR><TR><TD CLASS="l">1762</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1763</TD><TD>        return generatingDebug;</TD></TR><TR><TD CLASS="l">1764</TD><TD>    }</TD></TR><TR><TD CLASS="l">1765</TD><TD> </TD></TR><TR><TD CLASS="l">1766</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1767</TD><TD>     * Specify whether or not debug information should be generated.</TD></TR><TR><TD CLASS="l">1768</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1769</TD><TD>     * Setting the generation of debug information on will set the</TD></TR><TR><TD CLASS="l">1770</TD><TD>     * optimization level to zero.</TD></TR><TR><TD CLASS="l"><A NAME="37">1771</A></TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l">1772</TD><TD>     */</TD></TR><TR><TD CLASS="l">1773</TD><TD>    public final void setGeneratingDebug(boolean generatingDebug)</TD></TR><TR><TD CLASS="l">1774</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (3 out of 4 instructions)">1775</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (sealed) onSealedMutation();</TD></TR><TR CLASS="c"><TD CLASS="l">1776</TD><TD>        generatingDebugChanged = true;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="62% line coverage (5 out of 8 instructions)">1777</TD><TD TITLE="62% line coverage (5 out of 8 instructions)">        if (generatingDebug &amp;&amp; getOptimizationLevel() &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1778</TD><TD>            setOptimizationLevel(0);</TD></TR><TR CLASS="c"><TD CLASS="l">1779</TD><TD>        this.generatingDebug = generatingDebug;</TD></TR><TR CLASS="c"><TD CLASS="l">1780</TD><TD>    }</TD></TR><TR><TD CLASS="l">1781</TD><TD> </TD></TR><TR><TD CLASS="l">1782</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1783</TD><TD>     * Tell whether source information is being generated.</TD></TR><TR><TD CLASS="l"><A NAME="6d">1784</A></TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l">1785</TD><TD>     */</TD></TR><TR><TD CLASS="l">1786</TD><TD>    public final boolean isGeneratingSource()</TD></TR><TR><TD CLASS="l">1787</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1788</TD><TD>        return generatingSource;</TD></TR><TR><TD CLASS="l">1789</TD><TD>    }</TD></TR><TR><TD CLASS="l">1790</TD><TD> </TD></TR><TR><TD CLASS="l">1791</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1792</TD><TD>     * Specify whether or not source information should be generated.</TD></TR><TR><TD CLASS="l">1793</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1794</TD><TD>     * Without source information, evaluating the &#34;toString&#34; method</TD></TR><TR><TD CLASS="l">1795</TD><TD>     * on JavaScript functions produces only &#34;[native code]&#34; for</TD></TR><TR><TD CLASS="l">1796</TD><TD>     * the body of the function.</TD></TR><TR><TD CLASS="l">1797</TD><TD>     * Note that code generated without source is not fully ECMA</TD></TR><TR><TD CLASS="l">1798</TD><TD>     * conformant.</TD></TR><TR><TD CLASS="l"><A NAME="23">1799</A></TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l">1800</TD><TD>     */</TD></TR><TR><TD CLASS="l">1801</TD><TD>    public final void setGeneratingSource(boolean generatingSource)</TD></TR><TR><TD CLASS="l">1802</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1803</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>        this.generatingSource = generatingSource;</TD></TR><TR CLASS="z"><TD CLASS="l">1805</TD><TD>    }</TD></TR><TR><TD CLASS="l">1806</TD><TD> </TD></TR><TR><TD CLASS="l">1807</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1808</TD><TD>     * Get the current optimization level.</TD></TR><TR><TD CLASS="l">1809</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1810</TD><TD>     * The optimization level is expressed as an integer between -1 and</TD></TR><TR><TD CLASS="l">1811</TD><TD>     * 9.</TD></TR><TR><TD CLASS="l">1812</TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l"><A NAME="63">1813</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">1814</TD><TD>     */</TD></TR><TR><TD CLASS="l">1815</TD><TD>    public final int getOptimizationLevel()</TD></TR><TR><TD CLASS="l">1816</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1817</TD><TD>        return optimizationLevel;</TD></TR><TR><TD CLASS="l">1818</TD><TD>    }</TD></TR><TR><TD CLASS="l">1819</TD><TD> </TD></TR><TR><TD CLASS="l">1820</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1821</TD><TD>     * Set the current optimization level.</TD></TR><TR><TD CLASS="l">1822</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1823</TD><TD>     * The optimization level is expected to be an integer between -1 and</TD></TR><TR><TD CLASS="l">1824</TD><TD>     * 9. Any negative values will be interpreted as -1, and any values</TD></TR><TR><TD CLASS="l">1825</TD><TD>     * greater than 9 will be interpreted as 9.</TD></TR><TR><TD CLASS="l">1826</TD><TD>     * An optimization level of -1 indicates that interpretive mode will</TD></TR><TR><TD CLASS="l">1827</TD><TD>     * always be used. Levels 0 through 9 indicate that class files may</TD></TR><TR><TD CLASS="l">1828</TD><TD>     * be generated. Higher optimization levels trade off compile time</TD></TR><TR><TD CLASS="l">1829</TD><TD>     * performance for runtime performance.</TD></TR><TR><TD CLASS="l">1830</TD><TD>     * The optimizer level can't be set greater than -1 if the optimizer</TD></TR><TR><TD CLASS="l">1831</TD><TD>     * package doesn't exist at run time.</TD></TR><TR><TD CLASS="l">1832</TD><TD>     * @param optimizationLevel an integer indicating the level of</TD></TR><TR><TD CLASS="l">1833</TD><TD>     *        optimization to perform</TD></TR><TR><TD CLASS="l">1834</TD><TD>     * @since 1.3</TD></TR><TR><TD CLASS="l"><A NAME="40">1835</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">1836</TD><TD>     */</TD></TR><TR><TD CLASS="l">1837</TD><TD>    public final void setOptimizationLevel(int optimizationLevel)</TD></TR><TR><TD CLASS="l">1838</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (3 out of 4 instructions)">1839</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (sealed) onSealedMutation();</TD></TR><TR CLASS="c"><TD CLASS="l">1840</TD><TD>        if (optimizationLevel == -2) {</TD></TR><TR><TD CLASS="l">1841</TD><TD>            // To be compatible with Cocoon fork</TD></TR><TR CLASS="z"><TD CLASS="l">1842</TD><TD>            optimizationLevel = -1;</TD></TR><TR><TD CLASS="l">1843</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1844</TD><TD>        checkOptimizationLevel(optimizationLevel);</TD></TR><TR CLASS="c"><TD CLASS="l">1845</TD><TD>        if (codegenClass == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1846</TD><TD>            optimizationLevel = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">1847</TD><TD>        this.optimizationLevel = optimizationLevel;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="4d">1848</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1849</TD><TD> </TD></TR><TR><TD CLASS="l">1850</TD><TD>    public static boolean isValidOptimizationLevel(int optimizationLevel)</TD></TR><TR><TD CLASS="l">1851</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="90% line coverage (9 out of 10 instructions)">1852</TD><TD TITLE="90% line coverage (9 out of 10 instructions)">        return -1 &lt;= optimizationLevel &amp;&amp; optimizationLevel &lt;= 9;</TD></TR><TR><TD CLASS="l"><A NAME="2f">1853</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1854</TD><TD> </TD></TR><TR><TD CLASS="l">1855</TD><TD>    public static void checkOptimizationLevel(int optimizationLevel)</TD></TR><TR><TD CLASS="l">1856</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1857</TD><TD>        if (isValidOptimizationLevel(optimizationLevel)) {</TD></TR><TR CLASS="c"><TD CLASS="l">1858</TD><TD>            return;</TD></TR><TR><TD CLASS="l">1859</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1860</TD><TD>        throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">1861</TD><TD>            &#34;Optimization level outside [-1..9]: &#34;+optimizationLevel);</TD></TR><TR><TD CLASS="l">1862</TD><TD>    }</TD></TR><TR><TD CLASS="l">1863</TD><TD> </TD></TR><TR><TD CLASS="l">1864</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1865</TD><TD>     * Returns the maximum stack depth (in terms of number of call frames)</TD></TR><TR><TD CLASS="l">1866</TD><TD>     * allowed in a single invocation of interpreter. If the set depth would be</TD></TR><TR><TD CLASS="l">1867</TD><TD>     * exceeded, the interpreter will throw an EvaluatorException in the script.</TD></TR><TR><TD CLASS="l">1868</TD><TD>     * Defaults to Integer.MAX_VALUE. The setting only has effect for</TD></TR><TR><TD CLASS="l">1869</TD><TD>     * interpreted functions (those compiled with optimization level set to -1).</TD></TR><TR><TD CLASS="l">1870</TD><TD>     * As the interpreter doesn't use the Java stack but rather manages its own</TD></TR><TR><TD CLASS="l">1871</TD><TD>     * stack in the heap memory, a runaway recursion in interpreted code would</TD></TR><TR><TD CLASS="l">1872</TD><TD>     * eventually consume all available memory and cause OutOfMemoryError</TD></TR><TR><TD CLASS="l">1873</TD><TD>     * instead of a StackOverflowError limited to only a single thread. This</TD></TR><TR><TD CLASS="l">1874</TD><TD>     * setting helps prevent such situations.</TD></TR><TR><TD CLASS="l">1875</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="62">1876</A></TD><TD>     * @return The current maximum interpreter stack depth.</TD></TR><TR><TD CLASS="l">1877</TD><TD>     */</TD></TR><TR><TD CLASS="l">1878</TD><TD>    public final int getMaximumInterpreterStackDepth()</TD></TR><TR><TD CLASS="l">1879</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1880</TD><TD>        return maximumInterpreterStackDepth;</TD></TR><TR><TD CLASS="l">1881</TD><TD>    }</TD></TR><TR><TD CLASS="l">1882</TD><TD> </TD></TR><TR><TD CLASS="l">1883</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1884</TD><TD>     * Sets the maximum stack depth (in terms of number of call frames)</TD></TR><TR><TD CLASS="l">1885</TD><TD>     * allowed in a single invocation of interpreter. If the set depth would be</TD></TR><TR><TD CLASS="l">1886</TD><TD>     * exceeded, the interpreter will throw an EvaluatorException in the script.</TD></TR><TR><TD CLASS="l">1887</TD><TD>     * Defaults to Integer.MAX_VALUE. The setting only has effect for</TD></TR><TR><TD CLASS="l">1888</TD><TD>     * interpreted functions (those compiled with optimization level set to -1).</TD></TR><TR><TD CLASS="l">1889</TD><TD>     * As the interpreter doesn't use the Java stack but rather manages its own</TD></TR><TR><TD CLASS="l">1890</TD><TD>     * stack in the heap memory, a runaway recursion in interpreted code would</TD></TR><TR><TD CLASS="l">1891</TD><TD>     * eventually consume all available memory and cause OutOfMemoryError</TD></TR><TR><TD CLASS="l">1892</TD><TD>     * instead of a StackOverflowError limited to only a single thread. This</TD></TR><TR><TD CLASS="l">1893</TD><TD>     * setting helps prevent such situations.</TD></TR><TR><TD CLASS="l">1894</TD><TD>     *</TD></TR><TR><TD CLASS="l">1895</TD><TD>     * @param max the new maximum interpreter stack depth</TD></TR><TR><TD CLASS="l">1896</TD><TD>     * @throws IllegalStateException if this context's optimization level is not</TD></TR><TR><TD CLASS="l">1897</TD><TD>     * -1</TD></TR><TR><TD CLASS="l"><A NAME="25">1898</A></TD><TD>     * @throws IllegalArgumentException if the new depth is not at least 1</TD></TR><TR><TD CLASS="l">1899</TD><TD>     */</TD></TR><TR><TD CLASS="l">1900</TD><TD>    public final void setMaximumInterpreterStackDepth(int max)</TD></TR><TR><TD CLASS="l">1901</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1902</TD><TD>        if(sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>        if(optimizationLevel != -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1904</TD><TD>            throw new IllegalStateException(&#34;Cannot set maximumInterpreterStackDepth when optimizationLevel != -1&#34;);</TD></TR><TR><TD CLASS="l">1905</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1906</TD><TD>        if(max &lt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>            throw new IllegalArgumentException(&#34;Cannot set maximumInterpreterStackDepth to less than 1&#34;);</TD></TR><TR><TD CLASS="l">1908</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>        maximumInterpreterStackDepth = max;</TD></TR><TR CLASS="z"><TD CLASS="l">1910</TD><TD>    }</TD></TR><TR><TD CLASS="l">1911</TD><TD> </TD></TR><TR><TD CLASS="l">1912</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1913</TD><TD>     * Set the security controller for this context.</TD></TR><TR><TD CLASS="l">1914</TD><TD>     * &lt;p&gt; SecurityController may only be set if it is currently null</TD></TR><TR><TD CLASS="l">1915</TD><TD>     * and {@link SecurityController#hasGlobal()} is &lt;tt&gt;false&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">1916</TD><TD>     * Otherwise a SecurityException is thrown.</TD></TR><TR><TD CLASS="l">1917</TD><TD>     * @param controller a SecurityController object</TD></TR><TR><TD CLASS="l">1918</TD><TD>     * @throws SecurityException if there is already a SecurityController</TD></TR><TR><TD CLASS="l">1919</TD><TD>     *         object for this Context or globally installed.</TD></TR><TR><TD CLASS="l">1920</TD><TD>     * @see SecurityController#initGlobal(SecurityController controller)</TD></TR><TR><TD CLASS="l"><A NAME="26">1921</A></TD><TD>     * @see SecurityController#hasGlobal()</TD></TR><TR><TD CLASS="l">1922</TD><TD>     */</TD></TR><TR><TD CLASS="l">1923</TD><TD>    public final void setSecurityController(SecurityController controller)</TD></TR><TR><TD CLASS="l">1924</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1925</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">1926</TD><TD>        if (controller == null) throw new IllegalArgumentException();</TD></TR><TR CLASS="z"><TD CLASS="l">1927</TD><TD>        if (securityController != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1928</TD><TD>            throw new SecurityException(&#34;Can not overwrite existing SecurityController object&#34;);</TD></TR><TR><TD CLASS="l">1929</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1930</TD><TD>        if (SecurityController.hasGlobal()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1931</TD><TD>            throw new SecurityException(&#34;Can not overwrite existing global SecurityController object&#34;);</TD></TR><TR><TD CLASS="l">1932</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1933</TD><TD>        securityController = controller;</TD></TR><TR CLASS="z"><TD CLASS="l">1934</TD><TD>    }</TD></TR><TR><TD CLASS="l">1935</TD><TD> </TD></TR><TR><TD CLASS="l">1936</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1937</TD><TD>     * Set the LiveConnect access filter for this context.</TD></TR><TR><TD CLASS="l">1938</TD><TD>     * &lt;p&gt; {@link ClassShutter} may only be set if it is currently null.</TD></TR><TR><TD CLASS="l">1939</TD><TD>     * Otherwise a SecurityException is thrown.</TD></TR><TR><TD CLASS="l">1940</TD><TD>     * @param shutter a ClassShutter object</TD></TR><TR><TD CLASS="l">1941</TD><TD>     * @throws SecurityException if there is already a ClassShutter</TD></TR><TR><TD CLASS="l"><A NAME="21">1942</A></TD><TD>     *         object for this Context</TD></TR><TR><TD CLASS="l">1943</TD><TD>     */</TD></TR><TR><TD CLASS="l">1944</TD><TD>    public synchronized final void setClassShutter(ClassShutter shutter)</TD></TR><TR><TD CLASS="l">1945</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1946</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">1947</TD><TD>        if (shutter == null) throw new IllegalArgumentException();</TD></TR><TR CLASS="z"><TD CLASS="l">1948</TD><TD>        if (hasClassShutter) {</TD></TR><TR CLASS="z"><TD CLASS="l">1949</TD><TD>            throw new SecurityException(&#34;Cannot overwrite existing &#34; +</TD></TR><TR><TD CLASS="l">1950</TD><TD>                                        &#34;ClassShutter object&#34;);</TD></TR><TR><TD CLASS="l">1951</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1952</TD><TD>        classShutter = shutter;</TD></TR><TR CLASS="z"><TD CLASS="l">1953</TD><TD>        hasClassShutter = true;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5a">1954</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1955</TD><TD> </TD></TR><TR><TD CLASS="l">1956</TD><TD>    final synchronized ClassShutter getClassShutter()</TD></TR><TR><TD CLASS="l">1957</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1958</TD><TD>        return classShutter;</TD></TR><TR><TD CLASS="l">1959</TD><TD>    }</TD></TR><TR><TD CLASS="l">1960</TD><TD> </TD></TR><TR><TD CLASS="l">1961</TD><TD>    public interface ClassShutterSetter {</TD></TR><TR><TD CLASS="l">1962</TD><TD>        public void setClassShutter(ClassShutter shutter);</TD></TR><TR><TD CLASS="l"><A NAME="47">1963</A></TD><TD>        public ClassShutter getClassShutter();</TD></TR><TR><TD CLASS="l">1964</TD><TD>    }</TD></TR><TR><TD CLASS="l">1965</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="7f">1966</A></TD><TD>    public final synchronized ClassShutterSetter getClassShutterSetter() {</TD></TR><TR CLASS="c"><TD CLASS="l">1967</TD><TD>        if (hasClassShutter)</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="82">1968</A></TD><TD>            return null;</TD></TR><TR CLASS="c"><TD CLASS="l">1969</TD><TD>        hasClassShutter = true;</TD></TR><TR CLASS="c"><TD CLASS="l">1970</TD><TD>        return new ClassShutterSetter() {</TD></TR><TR><TD CLASS="l"><A NAME="80">1971</A></TD><TD>            public void setClassShutter(ClassShutter shutter) {</TD></TR><TR CLASS="c"><TD CLASS="l">1972</TD><TD>                classShutter = shutter;</TD></TR><TR CLASS="c"><TD CLASS="l">1973</TD><TD>            }</TD></TR><TR><TD CLASS="l">1974</TD><TD>            public ClassShutter getClassShutter() {</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                return classShutter;</TD></TR><TR><TD CLASS="l">1976</TD><TD>            }</TD></TR><TR><TD CLASS="l">1977</TD><TD>        };</TD></TR><TR><TD CLASS="l">1978</TD><TD>    }</TD></TR><TR><TD CLASS="l">1979</TD><TD> </TD></TR><TR><TD CLASS="l">1980</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1981</TD><TD>     * Get a value corresponding to a key.</TD></TR><TR><TD CLASS="l">1982</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1983</TD><TD>     * Since the Context is associated with a thread it can be</TD></TR><TR><TD CLASS="l">1984</TD><TD>     * used to maintain values that can be later retrieved using</TD></TR><TR><TD CLASS="l">1985</TD><TD>     * the current thread.</TD></TR><TR><TD CLASS="l">1986</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1987</TD><TD>     * Note that the values are maintained with the Context, so</TD></TR><TR><TD CLASS="l">1988</TD><TD>     * if the Context is disassociated from the thread the values</TD></TR><TR><TD CLASS="l">1989</TD><TD>     * cannot be retrieved. Also, if private data is to be maintained</TD></TR><TR><TD CLASS="l">1990</TD><TD>     * in this manner the key should be a java.lang.Object</TD></TR><TR><TD CLASS="l">1991</TD><TD>     * whose reference is not divulged to untrusted code.</TD></TR><TR><TD CLASS="l">1992</TD><TD>     * @param key the key used to lookup the value</TD></TR><TR><TD CLASS="l"><A NAME="11">1993</A></TD><TD>     * @return a value previously stored using putThreadLocal.</TD></TR><TR><TD CLASS="l">1994</TD><TD>     */</TD></TR><TR><TD CLASS="l">1995</TD><TD>    public final Object getThreadLocal(Object key)</TD></TR><TR><TD CLASS="l">1996</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1997</TD><TD>        if (threadLocalMap == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1998</TD><TD>            return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1999</TD><TD>        return threadLocalMap.get(key);</TD></TR><TR><TD CLASS="l">2000</TD><TD>    }</TD></TR><TR><TD CLASS="l">2001</TD><TD> </TD></TR><TR><TD CLASS="l">2002</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2003</TD><TD>     * Put a value that can later be retrieved using a given key.</TD></TR><TR><TD CLASS="l">2004</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">2005</TD><TD>     * @param key the key used to index the value</TD></TR><TR><TD CLASS="l"><A NAME="16">2006</A></TD><TD>     * @param value the value to save</TD></TR><TR><TD CLASS="l">2007</TD><TD>     */</TD></TR><TR><TD CLASS="l">2008</TD><TD>    public synchronized final void putThreadLocal(Object key, Object value)</TD></TR><TR><TD CLASS="l">2009</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2010</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>        if (threadLocalMap == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2012</TD><TD>            threadLocalMap = new HashMap&lt;Object,Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2013</TD><TD>        threadLocalMap.put(key, value);</TD></TR><TR CLASS="z"><TD CLASS="l">2014</TD><TD>    }</TD></TR><TR><TD CLASS="l">2015</TD><TD> </TD></TR><TR><TD CLASS="l">2016</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2017</TD><TD>     * Remove values from thread-local storage.</TD></TR><TR><TD CLASS="l">2018</TD><TD>     * @param key the key for the entry to remove.</TD></TR><TR><TD CLASS="l"><A NAME="1a">2019</A></TD><TD>     * @since 1.5 release 2</TD></TR><TR><TD CLASS="l">2020</TD><TD>     */</TD></TR><TR><TD CLASS="l">2021</TD><TD>    public final void removeThreadLocal(Object key)</TD></TR><TR><TD CLASS="l">2022</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2023</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>        if (threadLocalMap == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2025</TD><TD>            return;</TD></TR><TR CLASS="z"><TD CLASS="l">2026</TD><TD>        threadLocalMap.remove(key);</TD></TR><TR CLASS="z"><TD CLASS="l">2027</TD><TD>    }</TD></TR><TR><TD CLASS="l">2028</TD><TD> </TD></TR><TR><TD CLASS="l">2029</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2030</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">2031</TD><TD>     * @see ClassCache#get(Scriptable)</TD></TR><TR><TD CLASS="l"><A NAME="20">2032</A></TD><TD>     * @see ClassCache#setCachingEnabled(boolean)</TD></TR><TR><TD CLASS="l">2033</TD><TD>     */</TD></TR><TR><TD CLASS="l">2034</TD><TD>    public static void setCachingEnabled(boolean cachingEnabled)</TD></TR><TR><TD CLASS="l">2035</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2036</TD><TD>    }</TD></TR><TR><TD CLASS="l">2037</TD><TD> </TD></TR><TR><TD CLASS="l">2038</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2039</TD><TD>     * Set a WrapFactory for this Context.</TD></TR><TR><TD CLASS="l">2040</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">2041</TD><TD>     * The WrapFactory allows custom object wrapping behavior for</TD></TR><TR><TD CLASS="l">2042</TD><TD>     * Java object manipulated with JavaScript.</TD></TR><TR><TD CLASS="l">2043</TD><TD>     * @see WrapFactory</TD></TR><TR><TD CLASS="l"><A NAME="27">2044</A></TD><TD>     * @since 1.5 Release 4</TD></TR><TR><TD CLASS="l">2045</TD><TD>     */</TD></TR><TR><TD CLASS="l">2046</TD><TD>    public final void setWrapFactory(WrapFactory wrapFactory)</TD></TR><TR><TD CLASS="l">2047</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2048</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>        if (wrapFactory == null) throw new IllegalArgumentException();</TD></TR><TR CLASS="z"><TD CLASS="l">2050</TD><TD>        this.wrapFactory = wrapFactory;</TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>    }</TD></TR><TR><TD CLASS="l">2052</TD><TD> </TD></TR><TR><TD CLASS="l">2053</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2054</TD><TD>     * Return the current WrapFactory, or null if none is defined.</TD></TR><TR><TD CLASS="l">2055</TD><TD>     * @see WrapFactory</TD></TR><TR><TD CLASS="l"><A NAME="66">2056</A></TD><TD>     * @since 1.5 Release 4</TD></TR><TR><TD CLASS="l">2057</TD><TD>     */</TD></TR><TR><TD CLASS="l">2058</TD><TD>    public final WrapFactory getWrapFactory()</TD></TR><TR><TD CLASS="l">2059</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2060</TD><TD>        if (wrapFactory == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2061</TD><TD>            wrapFactory = new WrapFactory();</TD></TR><TR><TD CLASS="l">2062</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2063</TD><TD>        return wrapFactory;</TD></TR><TR><TD CLASS="l">2064</TD><TD>    }</TD></TR><TR><TD CLASS="l">2065</TD><TD> </TD></TR><TR><TD CLASS="l">2066</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2067</TD><TD>     * Return the current debugger.</TD></TR><TR><TD CLASS="l"><A NAME="d">2068</A></TD><TD>     * @return the debugger, or null if none is attached.</TD></TR><TR><TD CLASS="l">2069</TD><TD>     */</TD></TR><TR><TD CLASS="l">2070</TD><TD>    public final Debugger getDebugger()</TD></TR><TR><TD CLASS="l">2071</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2072</TD><TD>        return debugger;</TD></TR><TR><TD CLASS="l">2073</TD><TD>    }</TD></TR><TR><TD CLASS="l">2074</TD><TD> </TD></TR><TR><TD CLASS="l">2075</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2076</TD><TD>     * Return the debugger context data associated with current context.</TD></TR><TR><TD CLASS="l"><A NAME="e">2077</A></TD><TD>     * @return the debugger data, or null if debugger is not attached</TD></TR><TR><TD CLASS="l">2078</TD><TD>     */</TD></TR><TR><TD CLASS="l">2079</TD><TD>    public final Object getDebuggerContextData()</TD></TR><TR><TD CLASS="l">2080</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2081</TD><TD>        return debuggerData;</TD></TR><TR><TD CLASS="l">2082</TD><TD>    }</TD></TR><TR><TD CLASS="l">2083</TD><TD> </TD></TR><TR><TD CLASS="l">2084</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2085</TD><TD>     * Set the associated debugger.</TD></TR><TR><TD CLASS="l">2086</TD><TD>     * @param debugger the debugger to be used on callbacks from</TD></TR><TR><TD CLASS="l">2087</TD><TD>     * the engine.</TD></TR><TR><TD CLASS="l">2088</TD><TD>     * @param contextData arbitrary object that debugger can use to store</TD></TR><TR><TD CLASS="l"><A NAME="22">2089</A></TD><TD>     *        per Context data.</TD></TR><TR><TD CLASS="l">2090</TD><TD>     */</TD></TR><TR><TD CLASS="l">2091</TD><TD>    public final void setDebugger(Debugger debugger, Object contextData)</TD></TR><TR><TD CLASS="l">2092</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2094</TD><TD>        this.debugger = debugger;</TD></TR><TR CLASS="z"><TD CLASS="l">2095</TD><TD>        debuggerData = contextData;</TD></TR><TR CLASS="z"><TD CLASS="l">2096</TD><TD>    }</TD></TR><TR><TD CLASS="l">2097</TD><TD> </TD></TR><TR><TD CLASS="l">2098</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2099</TD><TD>     * Return DebuggableScript instance if any associated with the script.</TD></TR><TR><TD CLASS="l">2100</TD><TD>     * If callable supports DebuggableScript implementation, the method</TD></TR><TR><TD CLASS="l"><A NAME="c">2101</A></TD><TD>     * returns it. Otherwise null is returned.</TD></TR><TR><TD CLASS="l">2102</TD><TD>     */</TD></TR><TR><TD CLASS="l">2103</TD><TD>    public static DebuggableScript getDebuggableView(Script script)</TD></TR><TR><TD CLASS="l">2104</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2105</TD><TD>        if (script instanceof NativeFunction) {</TD></TR><TR CLASS="z"><TD CLASS="l">2106</TD><TD>            return ((NativeFunction)script).getDebuggableView();</TD></TR><TR><TD CLASS="l">2107</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2108</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">2109</TD><TD>    }</TD></TR><TR><TD CLASS="l">2110</TD><TD> </TD></TR><TR><TD CLASS="l">2111</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2112</TD><TD>     * Controls certain aspects of script semantics.</TD></TR><TR><TD CLASS="l">2113</TD><TD>     * Should be overwritten to alter default behavior.</TD></TR><TR><TD CLASS="l">2114</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">2115</TD><TD>     * The default implementation calls</TD></TR><TR><TD CLASS="l">2116</TD><TD>     * {@link ContextFactory#hasFeature(Context cx, int featureIndex)}</TD></TR><TR><TD CLASS="l">2117</TD><TD>     * that allows to customize Context behavior without introducing</TD></TR><TR><TD CLASS="l">2118</TD><TD>     * Context subclasses.  {@link ContextFactory} documentation gives</TD></TR><TR><TD CLASS="l">2119</TD><TD>     * an example of hasFeature implementation.</TD></TR><TR><TD CLASS="l">2120</TD><TD>     *</TD></TR><TR><TD CLASS="l">2121</TD><TD>     * @param featureIndex feature index to check</TD></TR><TR><TD CLASS="l">2122</TD><TD>     * @return true if the &lt;code&gt;featureIndex&lt;/code&gt; feature is turned on</TD></TR><TR><TD CLASS="l">2123</TD><TD>     * @see #FEATURE_NON_ECMA_GET_YEAR</TD></TR><TR><TD CLASS="l">2124</TD><TD>     * @see #FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME</TD></TR><TR><TD CLASS="l">2125</TD><TD>     * @see #FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER</TD></TR><TR><TD CLASS="l">2126</TD><TD>     * @see #FEATURE_TO_STRING_AS_SOURCE</TD></TR><TR><TD CLASS="l">2127</TD><TD>     * @see #FEATURE_PARENT_PROTO_PROPRTIES</TD></TR><TR><TD CLASS="l">2128</TD><TD>     * @see #FEATURE_E4X</TD></TR><TR><TD CLASS="l">2129</TD><TD>     * @see #FEATURE_DYNAMIC_SCOPE</TD></TR><TR><TD CLASS="l">2130</TD><TD>     * @see #FEATURE_STRICT_VARS</TD></TR><TR><TD CLASS="l">2131</TD><TD>     * @see #FEATURE_STRICT_EVAL</TD></TR><TR><TD CLASS="l">2132</TD><TD>     * @see #FEATURE_LOCATION_INFORMATION_IN_ERROR</TD></TR><TR><TD CLASS="l">2133</TD><TD>     * @see #FEATURE_STRICT_MODE</TD></TR><TR><TD CLASS="l">2134</TD><TD>     * @see #FEATURE_WARNING_AS_ERROR</TD></TR><TR><TD CLASS="l"><A NAME="67">2135</A></TD><TD>     * @see #FEATURE_ENHANCED_JAVA_ACCESS</TD></TR><TR><TD CLASS="l">2136</TD><TD>     */</TD></TR><TR><TD CLASS="l">2137</TD><TD>    public boolean hasFeature(int featureIndex)</TD></TR><TR><TD CLASS="l">2138</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2139</TD><TD>        ContextFactory f = getFactory();</TD></TR><TR CLASS="c"><TD CLASS="l">2140</TD><TD>        return f.hasFeature(this, featureIndex);</TD></TR><TR><TD CLASS="l">2141</TD><TD>    }</TD></TR><TR><TD CLASS="l">2142</TD><TD> </TD></TR><TR><TD CLASS="l">2143</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2144</TD><TD>     * Returns an object which specifies an E4X implementation to use within</TD></TR><TR><TD CLASS="l">2145</TD><TD>     * this &lt;code&gt;Context&lt;/code&gt;. Note that the XMLLib.Factory interface should</TD></TR><TR><TD CLASS="l">2146</TD><TD>     * be considered experimental.</TD></TR><TR><TD CLASS="l">2147</TD><TD>     *</TD></TR><TR><TD CLASS="l">2148</TD><TD>     * The default implementation uses the implementation provided by this</TD></TR><TR><TD CLASS="l">2149</TD><TD>     * &lt;code&gt;Context&lt;/code&gt;'s {@link ContextFactory}.</TD></TR><TR><TD CLASS="l">2150</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="5c">2151</A></TD><TD>     * @return An XMLLib.Factory. Should not return &lt;code&gt;null&lt;/code&gt; if</TD></TR><TR><TD CLASS="l">2152</TD><TD>     *         {@link #FEATURE_E4X} is enabled. See {@link #hasFeature}.</TD></TR><TR><TD CLASS="l">2153</TD><TD>     */</TD></TR><TR><TD CLASS="l">2154</TD><TD>    public XMLLib.Factory getE4xImplementationFactory() {</TD></TR><TR CLASS="c"><TD CLASS="l">2155</TD><TD>        return getFactory().getE4xImplementationFactory();</TD></TR><TR><TD CLASS="l">2156</TD><TD>    }</TD></TR><TR><TD CLASS="l">2157</TD><TD> </TD></TR><TR><TD CLASS="l">2158</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2159</TD><TD>     * Get threshold of executed instructions counter that triggers call to</TD></TR><TR><TD CLASS="l">2160</TD><TD>     * &lt;code&gt;observeInstructionCount()&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">2161</TD><TD>     * When the threshold is zero, instruction counting is disabled,</TD></TR><TR><TD CLASS="l">2162</TD><TD>     * otherwise each time the run-time executes at least the threshold value</TD></TR><TR><TD CLASS="l">2163</TD><TD>     * of script instructions, &lt;code&gt;observeInstructionCount()&lt;/code&gt; will</TD></TR><TR><TD CLASS="l"><A NAME="10">2164</A></TD><TD>     * be called.</TD></TR><TR><TD CLASS="l">2165</TD><TD>     */</TD></TR><TR><TD CLASS="l">2166</TD><TD>    public final int getInstructionObserverThreshold()</TD></TR><TR><TD CLASS="l">2167</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2168</TD><TD>        return instructionThreshold;</TD></TR><TR><TD CLASS="l">2169</TD><TD>    }</TD></TR><TR><TD CLASS="l">2170</TD><TD> </TD></TR><TR><TD CLASS="l">2171</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2172</TD><TD>     * Set threshold of executed instructions counter that triggers call to</TD></TR><TR><TD CLASS="l">2173</TD><TD>     * &lt;code&gt;observeInstructionCount()&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">2174</TD><TD>     * When the threshold is zero, instruction counting is disabled,</TD></TR><TR><TD CLASS="l">2175</TD><TD>     * otherwise each time the run-time executes at least the threshold value</TD></TR><TR><TD CLASS="l">2176</TD><TD>     * of script instructions, &lt;code&gt;observeInstructionCount()&lt;/code&gt; will</TD></TR><TR><TD CLASS="l">2177</TD><TD>     * be called.&lt;p/&gt;</TD></TR><TR><TD CLASS="l">2178</TD><TD>     * Note that the meaning of &#34;instruction&#34; is not guaranteed to be</TD></TR><TR><TD CLASS="l">2179</TD><TD>     * consistent between compiled and interpretive modes: executing a given</TD></TR><TR><TD CLASS="l">2180</TD><TD>     * script or function in the different modes will result in different</TD></TR><TR><TD CLASS="l">2181</TD><TD>     * instruction counts against the threshold.</TD></TR><TR><TD CLASS="l">2182</TD><TD>     * {@link #setGenerateObserverCount} is called with true if</TD></TR><TR><TD CLASS="l">2183</TD><TD>     * &lt;code&gt;threshold&lt;/code&gt; is greater than zero, false otherwise.</TD></TR><TR><TD CLASS="l"><A NAME="3c">2184</A></TD><TD>     * @param threshold The instruction threshold</TD></TR><TR><TD CLASS="l">2185</TD><TD>     */</TD></TR><TR><TD CLASS="l">2186</TD><TD>    public final void setInstructionObserverThreshold(int threshold)</TD></TR><TR><TD CLASS="l">2187</TD><TD>    {</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="75% line coverage (3 out of 4 instructions)">2188</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (sealed) onSealedMutation();</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="33% line coverage (2 out of 6 instructions)">2189</TD><TD TITLE="33% line coverage (2 out of 6 instructions)">        if (threshold &lt; 0) throw new IllegalArgumentException();</TD></TR><TR CLASS="c"><TD CLASS="l">2190</TD><TD>        instructionThreshold = threshold;</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="91% line coverage (10 out of 11 instructions)">2191</TD><TD TITLE="91% line coverage (10 out of 11 instructions)">        setGenerateObserverCount(threshold &gt; 0);</TD></TR><TR CLASS="c"><TD CLASS="l">2192</TD><TD>    }</TD></TR><TR><TD CLASS="l">2193</TD><TD> </TD></TR><TR><TD CLASS="l">2194</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2195</TD><TD>     * Turn on or off generation of code with callbacks to</TD></TR><TR><TD CLASS="l">2196</TD><TD>     * track the count of executed instructions.</TD></TR><TR><TD CLASS="l">2197</TD><TD>     * Currently only affects JVM byte code generation: this slows down the</TD></TR><TR><TD CLASS="l">2198</TD><TD>     * generated code, but code generated without the callbacks will not</TD></TR><TR><TD CLASS="l">2199</TD><TD>     * be counted toward instruction thresholds. Rhino's interpretive</TD></TR><TR><TD CLASS="l">2200</TD><TD>     * mode does instruction counting without inserting callbacks, so</TD></TR><TR><TD CLASS="l">2201</TD><TD>     * there is no requirement to compile code differently.</TD></TR><TR><TD CLASS="l"><A NAME="7b">2202</A></TD><TD>     * @param generateObserverCount if true, generated code will contain</TD></TR><TR><TD CLASS="l">2203</TD><TD>     * calls to accumulate an estimate of the instructions executed.</TD></TR><TR><TD CLASS="l">2204</TD><TD>     */</TD></TR><TR><TD CLASS="l">2205</TD><TD>    public void setGenerateObserverCount(boolean generateObserverCount) {</TD></TR><TR CLASS="c"><TD CLASS="l">2206</TD><TD>        this.generateObserverCount = generateObserverCount;</TD></TR><TR CLASS="c"><TD CLASS="l">2207</TD><TD>    }</TD></TR><TR><TD CLASS="l">2208</TD><TD> </TD></TR><TR><TD CLASS="l">2209</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2210</TD><TD>     * Allow application to monitor counter of executed script instructions</TD></TR><TR><TD CLASS="l">2211</TD><TD>     * in Context subclasses.</TD></TR><TR><TD CLASS="l">2212</TD><TD>     * Run-time calls this when instruction counting is enabled and the counter</TD></TR><TR><TD CLASS="l">2213</TD><TD>     * reaches limit set by &lt;code&gt;setInstructionObserverThreshold()&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">2214</TD><TD>     * The method is useful to observe long running scripts and if necessary</TD></TR><TR><TD CLASS="l">2215</TD><TD>     * to terminate them.</TD></TR><TR><TD CLASS="l">2216</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">2217</TD><TD>     * The default implementation calls</TD></TR><TR><TD CLASS="l">2218</TD><TD>     * {@link ContextFactory#observeInstructionCount(Context cx,</TD></TR><TR><TD CLASS="l">2219</TD><TD>     *                                               int instructionCount)}</TD></TR><TR><TD CLASS="l">2220</TD><TD>     * that allows to customize Context behavior without introducing</TD></TR><TR><TD CLASS="l">2221</TD><TD>     * Context subclasses.</TD></TR><TR><TD CLASS="l">2222</TD><TD>     *</TD></TR><TR><TD CLASS="l">2223</TD><TD>     * @param instructionCount amount of script instruction executed since</TD></TR><TR><TD CLASS="l">2224</TD><TD>     * last call to &lt;code&gt;observeInstructionCount&lt;/code&gt;</TD></TR><TR><TD CLASS="l">2225</TD><TD>     * @throws Error to terminate the script</TD></TR><TR><TD CLASS="l"><A NAME="73">2226</A></TD><TD>     * @see #setOptimizationLevel(int)</TD></TR><TR><TD CLASS="l">2227</TD><TD>     */</TD></TR><TR><TD CLASS="l">2228</TD><TD>    protected void observeInstructionCount(int instructionCount)</TD></TR><TR><TD CLASS="l">2229</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2230</TD><TD>        ContextFactory f = getFactory();</TD></TR><TR CLASS="c"><TD CLASS="l">2231</TD><TD>        f.observeInstructionCount(this, instructionCount);</TD></TR><TR CLASS="c"><TD CLASS="l">2232</TD><TD>    }</TD></TR><TR><TD CLASS="l">2233</TD><TD> </TD></TR><TR><TD CLASS="l">2234</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2235</TD><TD>     * Create class loader for generated classes.</TD></TR><TR><TD CLASS="l">2236</TD><TD>     * The method calls {@link ContextFactory#createClassLoader(ClassLoader)}</TD></TR><TR><TD CLASS="l"><A NAME="54">2237</A></TD><TD>     * using the result of {@link #getFactory()}.</TD></TR><TR><TD CLASS="l">2238</TD><TD>     */</TD></TR><TR><TD CLASS="l">2239</TD><TD>    public GeneratedClassLoader createClassLoader(ClassLoader parent)</TD></TR><TR><TD CLASS="l">2240</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2241</TD><TD>        ContextFactory f = getFactory();</TD></TR><TR CLASS="c"><TD CLASS="l">2242</TD><TD>        return f.createClassLoader(parent);</TD></TR><TR><TD CLASS="l"><A NAME="31">2243</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2244</TD><TD> </TD></TR><TR><TD CLASS="l">2245</TD><TD>    public final ClassLoader getApplicationClassLoader()</TD></TR><TR><TD CLASS="l">2246</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2247</TD><TD>        if (applicationClassLoader == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2248</TD><TD>            ContextFactory f = getFactory();</TD></TR><TR CLASS="c"><TD CLASS="l">2249</TD><TD>            ClassLoader loader = f.getApplicationClassLoader();</TD></TR><TR CLASS="c"><TD CLASS="l">2250</TD><TD>            if (loader == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2251</TD><TD>                ClassLoader threadLoader</TD></TR><TR><TD CLASS="l">2252</TD><TD>                    = VMBridge.instance.getCurrentThreadClassLoader();</TD></TR><TR CLASS="c"><TD CLASS="l">2253</TD><TD>                if (threadLoader != null</TD></TR><TR><TD CLASS="l">2254</TD><TD>                    &amp;&amp; Kit.testIfCanLoadRhinoClasses(threadLoader))</TD></TR><TR><TD CLASS="l">2255</TD><TD>                {</TD></TR><TR><TD CLASS="l">2256</TD><TD>                    // Thread.getContextClassLoader is not cached since</TD></TR><TR><TD CLASS="l">2257</TD><TD>                    // its caching prevents it from GC which may lead to</TD></TR><TR><TD CLASS="l">2258</TD><TD>                    // a memory leak and hides updates to</TD></TR><TR><TD CLASS="l">2259</TD><TD>                    // Thread.getContextClassLoader</TD></TR><TR CLASS="c"><TD CLASS="l">2260</TD><TD>                    return threadLoader;</TD></TR><TR><TD CLASS="l">2261</TD><TD>                }</TD></TR><TR><TD CLASS="l">2262</TD><TD>                // Thread.getContextClassLoader can not load Rhino classes,</TD></TR><TR><TD CLASS="l">2263</TD><TD>                // try to use the loader of ContextFactory or Context</TD></TR><TR><TD CLASS="l">2264</TD><TD>                // subclasses.</TD></TR><TR CLASS="z"><TD CLASS="l">2265</TD><TD>                Class&lt;?&gt; fClass = f.getClass();</TD></TR><TR CLASS="z"><TD CLASS="l">2266</TD><TD>                if (fClass != ScriptRuntime.ContextFactoryClass) {</TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>                    loader = fClass.getClassLoader();</TD></TR><TR><TD CLASS="l">2268</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2269</TD><TD>                    loader = getClass().getClassLoader();</TD></TR><TR><TD CLASS="l">2270</TD><TD>                }</TD></TR><TR><TD CLASS="l">2271</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">2272</TD><TD>            applicationClassLoader = loader;</TD></TR><TR><TD CLASS="l">2273</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2274</TD><TD>        return applicationClassLoader;</TD></TR><TR><TD CLASS="l"><A NAME="1f">2275</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2276</TD><TD> </TD></TR><TR><TD CLASS="l">2277</TD><TD>    public final void setApplicationClassLoader(ClassLoader loader)</TD></TR><TR><TD CLASS="l">2278</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2279</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2280</TD><TD>        if (loader == null) {</TD></TR><TR><TD CLASS="l">2281</TD><TD>            // restore default behaviour</TD></TR><TR CLASS="z"><TD CLASS="l">2282</TD><TD>            applicationClassLoader = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2283</TD><TD>            return;</TD></TR><TR><TD CLASS="l">2284</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2285</TD><TD>        if (!Kit.testIfCanLoadRhinoClasses(loader)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2286</TD><TD>            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">2287</TD><TD>                &#34;Loader can not resolve Rhino classes&#34;);</TD></TR><TR><TD CLASS="l">2288</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2289</TD><TD>        applicationClassLoader = loader;</TD></TR><TR CLASS="z"><TD CLASS="l">2290</TD><TD>    }</TD></TR><TR><TD CLASS="l">2291</TD><TD> </TD></TR><TR><TD CLASS="l">2292</TD><TD>    /********** end of API **********/</TD></TR><TR><TD CLASS="l">2293</TD><TD> </TD></TR><TR><TD CLASS="l">2294</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2295</TD><TD>     * Internal method that reports an error for missing calls to</TD></TR><TR><TD CLASS="l"><A NAME="33">2296</A></TD><TD>     * enter().</TD></TR><TR><TD CLASS="l">2297</TD><TD>     */</TD></TR><TR><TD CLASS="l">2298</TD><TD>    static Context getContext()</TD></TR><TR><TD CLASS="l">2299</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2300</TD><TD>        Context cx = getCurrentContext();</TD></TR><TR CLASS="c"><TD CLASS="l">2301</TD><TD>        if (cx == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2302</TD><TD>            throw new RuntimeException(</TD></TR><TR><TD CLASS="l">2303</TD><TD>                &#34;No Context associated with current Thread&#34;);</TD></TR><TR><TD CLASS="l">2304</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2305</TD><TD>        return cx;</TD></TR><TR><TD CLASS="l">2306</TD><TD>    }</TD></TR><TR><TD CLASS="l">2307</TD><TD> </TD></TR><TR><TD CLASS="l">2308</TD><TD>    private Object compileImpl(Scriptable scope,</TD></TR><TR><TD CLASS="l">2309</TD><TD>                               Reader sourceReader, String sourceString,</TD></TR><TR><TD CLASS="l">2310</TD><TD>                               String sourceName, int lineno,</TD></TR><TR><TD CLASS="l">2311</TD><TD>                               Object securityDomain, boolean returnFunction,</TD></TR><TR><TD CLASS="l"><A NAME="3b">2312</A></TD><TD>                               Evaluator compiler,</TD></TR><TR><TD CLASS="l">2313</TD><TD>                               ErrorReporter compilationErrorReporter)</TD></TR><TR><TD CLASS="l">2314</TD><TD>        throws IOException</TD></TR><TR><TD CLASS="l">2315</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2316</TD><TD>        if(sourceName == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2317</TD><TD>            sourceName = &#34;unnamed script&#34;;</TD></TR><TR><TD CLASS="l">2318</TD><TD>        }</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="40% line coverage (2 out of 5 instructions)">2319</TD><TD TITLE="40% line coverage (2 out of 5 instructions)">        if (securityDomain != null &amp;&amp; getSecurityController() == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2320</TD><TD>            throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">2321</TD><TD>                &#34;securityDomain should be null if setSecurityController() was never called&#34;);</TD></TR><TR><TD CLASS="l">2322</TD><TD>        }</TD></TR><TR><TD CLASS="l">2323</TD><TD> </TD></TR><TR><TD CLASS="l">2324</TD><TD>        // One of sourceReader or sourceString has to be null</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="86% line coverage (12 out of 14 instructions)">2325</TD><TD TITLE="86% line coverage (12 out of 14 instructions)">        if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();</TD></TR><TR><TD CLASS="l">2326</TD><TD>        // scope should be given if and only if compiling function</TD></TR><TR CLASS="p"><TD CLASS="l" TITLE="80% line coverage (8 out of 10 instructions)">2327</TD><TD TITLE="80% line coverage (8 out of 10 instructions)">        if (!(scope == null ^ returnFunction)) Kit.codeBug();</TD></TR><TR><TD CLASS="l">2328</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2329</TD><TD>        CompilerEnvirons compilerEnv = new CompilerEnvirons();</TD></TR><TR CLASS="c"><TD CLASS="l">2330</TD><TD>        compilerEnv.initFromContext(this);</TD></TR><TR CLASS="c"><TD CLASS="l">2331</TD><TD>        if (compilationErrorReporter == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2332</TD><TD>            compilationErrorReporter = compilerEnv.getErrorReporter();</TD></TR><TR><TD CLASS="l">2333</TD><TD>        }</TD></TR><TR><TD CLASS="l">2334</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2335</TD><TD>        if (debugger != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2336</TD><TD>            if (sourceReader != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2337</TD><TD>                sourceString = Kit.readReader(sourceReader);</TD></TR><TR CLASS="z"><TD CLASS="l">2338</TD><TD>                sourceReader = null;</TD></TR><TR><TD CLASS="l">2339</TD><TD>            }</TD></TR><TR><TD CLASS="l">2340</TD><TD>        }</TD></TR><TR><TD CLASS="l">2341</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2342</TD><TD>        Parser p = new Parser(compilerEnv, compilationErrorReporter);</TD></TR><TR CLASS="c"><TD CLASS="l">2343</TD><TD>        if (returnFunction) {</TD></TR><TR CLASS="c"><TD CLASS="l">2344</TD><TD>            p.calledByCompileFunction = true;</TD></TR><TR><TD CLASS="l">2345</TD><TD>        }</TD></TR><TR><TD CLASS="l">2346</TD><TD>        AstRoot ast;</TD></TR><TR CLASS="c"><TD CLASS="l">2347</TD><TD>        if (sourceString != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2348</TD><TD>            ast = p.parse(sourceString, sourceName, lineno);</TD></TR><TR><TD CLASS="l">2349</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2350</TD><TD>            ast = p.parse(sourceReader, sourceName, lineno);</TD></TR><TR><TD CLASS="l">2351</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2352</TD><TD>        if (returnFunction) {</TD></TR><TR><TD CLASS="l">2353</TD><TD>            // parser no longer adds function to script node</TD></TR><TR CLASS="c"><TD CLASS="l">2354</TD><TD>            if (!(ast.getFirstChild() != null</TD></TR><TR><TD CLASS="l">2355</TD><TD>                  &amp;&amp; ast.getFirstChild().getType() == Token.FUNCTION))</TD></TR><TR><TD CLASS="l">2356</TD><TD>            {</TD></TR><TR><TD CLASS="l">2357</TD><TD>                // XXX: the check just looks for the first child</TD></TR><TR><TD CLASS="l">2358</TD><TD>                // and allows for more nodes after it for compatibility</TD></TR><TR><TD CLASS="l">2359</TD><TD>                // with sources like function() {};;;</TD></TR><TR CLASS="z"><TD CLASS="l">2360</TD><TD>                throw new IllegalArgumentException(</TD></TR><TR><TD CLASS="l">2361</TD><TD>                    &#34;compileFunction only accepts source with single JS function: &#34;+sourceString);</TD></TR><TR><TD CLASS="l">2362</TD><TD>            }</TD></TR><TR><TD CLASS="l">2363</TD><TD>        }</TD></TR><TR><TD CLASS="l">2364</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2365</TD><TD>        IRFactory irf = new IRFactory(compilerEnv, compilationErrorReporter);</TD></TR><TR CLASS="c"><TD CLASS="l">2366</TD><TD>        ScriptNode tree = irf.transformTree(ast);</TD></TR><TR><TD CLASS="l">2367</TD><TD> </TD></TR><TR><TD CLASS="l">2368</TD><TD>        // discard everything but the IR tree</TD></TR><TR CLASS="c"><TD CLASS="l">2369</TD><TD>        p = null;</TD></TR><TR CLASS="c"><TD CLASS="l">2370</TD><TD>        ast = null;</TD></TR><TR CLASS="c"><TD CLASS="l">2371</TD><TD>        irf = null;</TD></TR><TR><TD CLASS="l">2372</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2373</TD><TD>        if (compiler == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2374</TD><TD>            compiler = createCompiler();</TD></TR><TR><TD CLASS="l">2375</TD><TD>        }</TD></TR><TR><TD CLASS="l">2376</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2377</TD><TD>        Object bytecode = compiler.compile(compilerEnv,</TD></TR><TR><TD CLASS="l">2378</TD><TD>                                           tree, tree.getEncodedSource(),</TD></TR><TR><TD CLASS="l">2379</TD><TD>                                           returnFunction);</TD></TR><TR CLASS="c"><TD CLASS="l">2380</TD><TD>        if (debugger != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2381</TD><TD>            if (sourceString == null) Kit.codeBug();</TD></TR><TR CLASS="z"><TD CLASS="l">2382</TD><TD>            if (bytecode instanceof DebuggableScript) {</TD></TR><TR CLASS="z"><TD CLASS="l">2383</TD><TD>                DebuggableScript dscript = (DebuggableScript)bytecode;</TD></TR><TR CLASS="z"><TD CLASS="l">2384</TD><TD>                notifyDebugger_r(this, dscript, sourceString);</TD></TR><TR CLASS="z"><TD CLASS="l">2385</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2386</TD><TD>                throw new RuntimeException(&#34;NOT SUPPORTED&#34;);</TD></TR><TR><TD CLASS="l">2387</TD><TD>            }</TD></TR><TR><TD CLASS="l">2388</TD><TD>        }</TD></TR><TR><TD CLASS="l">2389</TD><TD> </TD></TR><TR><TD CLASS="l">2390</TD><TD>        Object result;</TD></TR><TR CLASS="c"><TD CLASS="l">2391</TD><TD>        if (returnFunction) {</TD></TR><TR CLASS="c"><TD CLASS="l">2392</TD><TD>            result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);</TD></TR><TR><TD CLASS="l">2393</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">2394</TD><TD>            result = compiler.createScriptObject(bytecode, securityDomain);</TD></TR><TR><TD CLASS="l">2395</TD><TD>        }</TD></TR><TR><TD CLASS="l">2396</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2397</TD><TD>        return result;</TD></TR><TR><TD CLASS="l">2398</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="14">2399</A></TD><TD> </TD></TR><TR><TD CLASS="l">2400</TD><TD>    private static void notifyDebugger_r(Context cx, DebuggableScript dscript,</TD></TR><TR><TD CLASS="l">2401</TD><TD>                                         String debugSource)</TD></TR><TR><TD CLASS="l">2402</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2403</TD><TD>        cx.debugger.handleCompilationDone(cx, dscript, debugSource);</TD></TR><TR CLASS="z"><TD CLASS="l">2404</TD><TD>        for (int i = 0; i != dscript.getFunctionCount(); ++i) {</TD></TR><TR CLASS="z"><TD CLASS="l">2405</TD><TD>            notifyDebugger_r(cx, dscript.getFunction(i), debugSource);</TD></TR><TR><TD CLASS="l">2406</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2407</TD><TD>    }</TD></TR><TR><TD CLASS="l">2408</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2409</TD><TD>    private static Class&lt;?&gt; codegenClass = Kit.classOrNull(</TD></TR><TR><TD CLASS="l">2410</TD><TD>                             &#34;org.mozilla.javascript.optimizer.Codegen&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">2411</TD><TD>    private static Class&lt;?&gt; interpreterClass = Kit.classOrNull(</TD></TR><TR><TD CLASS="l"><A NAME="55">2412</A></TD><TD>                             &#34;org.mozilla.javascript.Interpreter&#34;);</TD></TR><TR><TD CLASS="l">2413</TD><TD> </TD></TR><TR><TD CLASS="l">2414</TD><TD>    private Evaluator createCompiler()</TD></TR><TR><TD CLASS="l">2415</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2416</TD><TD>        Evaluator result = null;</TD></TR><TR CLASS="c"><TD CLASS="l">2417</TD><TD>        if (optimizationLevel &gt;= 0 &amp;&amp; codegenClass != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2418</TD><TD>            result = (Evaluator)Kit.newInstanceOrNull(codegenClass);</TD></TR><TR><TD CLASS="l">2419</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2420</TD><TD>        if (result == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2421</TD><TD>            result = createInterpreter();</TD></TR><TR><TD CLASS="l">2422</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2423</TD><TD>        return result;</TD></TR><TR><TD CLASS="l"><A NAME="56">2424</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2425</TD><TD> </TD></TR><TR><TD CLASS="l">2426</TD><TD>    static Evaluator createInterpreter()</TD></TR><TR><TD CLASS="l">2427</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2428</TD><TD>        return (Evaluator)Kit.newInstanceOrNull(interpreterClass);</TD></TR><TR><TD CLASS="l"><A NAME="4e">2429</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2430</TD><TD> </TD></TR><TR><TD CLASS="l">2431</TD><TD>    static String getSourcePositionFromStack(int[] linep)</TD></TR><TR><TD CLASS="l">2432</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2433</TD><TD>        Context cx = getCurrentContext();</TD></TR><TR CLASS="c"><TD CLASS="l">2434</TD><TD>        if (cx == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2435</TD><TD>            return null;</TD></TR><TR CLASS="c"><TD CLASS="l">2436</TD><TD>        if (cx.lastInterpreterFrame != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2437</TD><TD>            Evaluator evaluator = createInterpreter();</TD></TR><TR CLASS="c"><TD CLASS="l">2438</TD><TD>            if (evaluator != null)</TD></TR><TR CLASS="c"><TD CLASS="l">2439</TD><TD>                return evaluator.getSourcePositionFromStack(cx, linep);</TD></TR><TR><TD CLASS="l">2440</TD><TD>        }</TD></TR><TR><TD CLASS="l">2441</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2442</TD><TD>         * A bit of a hack, but the only way to get filename and line</TD></TR><TR><TD CLASS="l">2443</TD><TD>         * number from an enclosing frame.</TD></TR><TR><TD CLASS="l">2444</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">2445</TD><TD>        CharArrayWriter writer = new CharArrayWriter();</TD></TR><TR CLASS="c"><TD CLASS="l">2446</TD><TD>        RuntimeException re = new RuntimeException();</TD></TR><TR CLASS="c"><TD CLASS="l">2447</TD><TD>        re.printStackTrace(new PrintWriter(writer));</TD></TR><TR CLASS="c"><TD CLASS="l">2448</TD><TD>        String s = writer.toString();</TD></TR><TR CLASS="c"><TD CLASS="l">2449</TD><TD>        int open = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">2450</TD><TD>        int close = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">2451</TD><TD>        int colon = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">2452</TD><TD>        for (int i=0; i &lt; s.length(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">2453</TD><TD>            char c = s.charAt(i);</TD></TR><TR CLASS="c"><TD CLASS="l">2454</TD><TD>            if (c == ':')</TD></TR><TR CLASS="c"><TD CLASS="l">2455</TD><TD>                colon = i;</TD></TR><TR CLASS="c"><TD CLASS="l">2456</TD><TD>            else if (c == '(')</TD></TR><TR CLASS="c"><TD CLASS="l">2457</TD><TD>                open = i;</TD></TR><TR CLASS="c"><TD CLASS="l">2458</TD><TD>            else if (c == ')')</TD></TR><TR CLASS="c"><TD CLASS="l">2459</TD><TD>                close = i;</TD></TR><TR CLASS="c"><TD CLASS="l">2460</TD><TD>            else if (c == '\n' &amp;&amp; open != -1 &amp;&amp; close != -1 &amp;&amp; colon != -1 &amp;&amp;</TD></TR><TR><TD CLASS="l">2461</TD><TD>                     open &lt; colon &amp;&amp; colon &lt; close)</TD></TR><TR><TD CLASS="l">2462</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">2463</TD><TD>                String fileStr = s.substring(open + 1, colon);</TD></TR><TR CLASS="c"><TD CLASS="l">2464</TD><TD>                if (!fileStr.endsWith(&#34;.java&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">2465</TD><TD>                    String lineStr = s.substring(colon + 1, close);</TD></TR><TR><TD CLASS="l">2466</TD><TD>                    try {</TD></TR><TR CLASS="c"><TD CLASS="l">2467</TD><TD>                        linep[0] = Integer.parseInt(lineStr);</TD></TR><TR CLASS="c"><TD CLASS="l">2468</TD><TD>                        if (linep[0] &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2469</TD><TD>                            linep[0] = 0;</TD></TR><TR><TD CLASS="l">2470</TD><TD>                        }</TD></TR><TR CLASS="c"><TD CLASS="l">2471</TD><TD>                        return fileStr;</TD></TR><TR><TD CLASS="l">2472</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2473</TD><TD>                    catch (NumberFormatException e) {</TD></TR><TR><TD CLASS="l">2474</TD><TD>                        // fall through</TD></TR><TR><TD CLASS="l">2475</TD><TD>                    }</TD></TR><TR><TD CLASS="l">2476</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">2477</TD><TD>                open = close = colon = -1;</TD></TR><TR><TD CLASS="l">2478</TD><TD>            }</TD></TR><TR><TD CLASS="l">2479</TD><TD>        }</TD></TR><TR><TD CLASS="l">2480</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">2481</TD><TD>        return null;</TD></TR><TR><TD CLASS="l"><A NAME="64">2482</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2483</TD><TD> </TD></TR><TR><TD CLASS="l">2484</TD><TD>    RegExpProxy getRegExpProxy()</TD></TR><TR><TD CLASS="l">2485</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2486</TD><TD>        if (regExpProxy == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2487</TD><TD>            Class&lt;?&gt; cl = Kit.classOrNull(</TD></TR><TR><TD CLASS="l">2488</TD><TD>                          &#34;org.mozilla.javascript.regexp.RegExpImpl&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">2489</TD><TD>            if (cl != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">2490</TD><TD>                regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);</TD></TR><TR><TD CLASS="l">2491</TD><TD>            }</TD></TR><TR><TD CLASS="l">2492</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2493</TD><TD>        return regExpProxy;</TD></TR><TR><TD CLASS="l"><A NAME="6f">2494</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2495</TD><TD> </TD></TR><TR><TD CLASS="l">2496</TD><TD>    final boolean isVersionECMA1()</TD></TR><TR><TD CLASS="l">2497</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2498</TD><TD>        return version == VERSION_DEFAULT || version &gt;= VERSION_1_3;</TD></TR><TR><TD CLASS="l">2499</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="41">2500</A></TD><TD> </TD></TR><TR><TD CLASS="l">2501</TD><TD>// The method must NOT be public or protected</TD></TR><TR><TD CLASS="l">2502</TD><TD>    SecurityController getSecurityController()</TD></TR><TR><TD CLASS="l">2503</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2504</TD><TD>        SecurityController global = SecurityController.global();</TD></TR><TR CLASS="c"><TD CLASS="l">2505</TD><TD>        if (global != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2506</TD><TD>            return global;</TD></TR><TR><TD CLASS="l">2507</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">2508</TD><TD>        return securityController;</TD></TR><TR><TD CLASS="l"><A NAME="6c">2509</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">2510</TD><TD> </TD></TR><TR><TD CLASS="l">2511</TD><TD>    public final boolean isGeneratingDebugChanged()</TD></TR><TR><TD CLASS="l">2512</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">2513</TD><TD>        return generatingDebugChanged;</TD></TR><TR><TD CLASS="l">2514</TD><TD>    }</TD></TR><TR><TD CLASS="l">2515</TD><TD> </TD></TR><TR><TD CLASS="l">2516</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2517</TD><TD>     * Add a name to the list of names forcing the creation of real</TD></TR><TR><TD CLASS="l">2518</TD><TD>     * activation objects for functions.</TD></TR><TR><TD CLASS="l">2519</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="3">2520</A></TD><TD>     * @param name the name of the object to add to the list</TD></TR><TR><TD CLASS="l">2521</TD><TD>     */</TD></TR><TR><TD CLASS="l">2522</TD><TD>    public void addActivationName(String name)</TD></TR><TR><TD CLASS="l">2523</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2524</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2525</TD><TD>        if (activationNames == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2526</TD><TD>            activationNames = new HashSet&lt;String&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2527</TD><TD>        activationNames.add(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2528</TD><TD>    }</TD></TR><TR><TD CLASS="l">2529</TD><TD> </TD></TR><TR><TD CLASS="l">2530</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2531</TD><TD>     * Check whether the name is in the list of names of objects</TD></TR><TR><TD CLASS="l">2532</TD><TD>     * forcing the creation of activation objects.</TD></TR><TR><TD CLASS="l">2533</TD><TD>     *</TD></TR><TR><TD CLASS="l">2534</TD><TD>     * @param name the name of the object to test</TD></TR><TR><TD CLASS="l">2535</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="12">2536</A></TD><TD>     * @return true if an function activation object is needed.</TD></TR><TR><TD CLASS="l">2537</TD><TD>     */</TD></TR><TR><TD CLASS="l">2538</TD><TD>    public final boolean isActivationNeeded(String name)</TD></TR><TR><TD CLASS="l">2539</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2540</TD><TD>        return activationNames != null &amp;&amp; activationNames.contains(name);</TD></TR><TR><TD CLASS="l">2541</TD><TD>    }</TD></TR><TR><TD CLASS="l">2542</TD><TD> </TD></TR><TR><TD CLASS="l">2543</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2544</TD><TD>     * Remove a name from the list of names forcing the creation of real</TD></TR><TR><TD CLASS="l">2545</TD><TD>     * activation objects for functions.</TD></TR><TR><TD CLASS="l">2546</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="17">2547</A></TD><TD>     * @param name the name of the object to remove from the list</TD></TR><TR><TD CLASS="l">2548</TD><TD>     */</TD></TR><TR><TD CLASS="l">2549</TD><TD>    public void removeActivationName(String name)</TD></TR><TR><TD CLASS="l">2550</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2551</TD><TD>        if (sealed) onSealedMutation();</TD></TR><TR CLASS="z"><TD CLASS="l">2552</TD><TD>        if (activationNames != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2553</TD><TD>            activationNames.remove(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2554</TD><TD>    }</TD></TR><TR><TD CLASS="l">2555</TD><TD> </TD></TR><TR><TD CLASS="l">2556</TD><TD>    private static String implementationVersion;</TD></TR><TR><TD CLASS="l">2557</TD><TD> </TD></TR><TR><TD CLASS="l">2558</TD><TD>    private final ContextFactory factory;</TD></TR><TR><TD CLASS="l">2559</TD><TD>    private boolean sealed;</TD></TR><TR><TD CLASS="l">2560</TD><TD>    private Object sealKey;</TD></TR><TR><TD CLASS="l">2561</TD><TD> </TD></TR><TR><TD CLASS="l">2562</TD><TD>    Scriptable topCallScope;</TD></TR><TR><TD CLASS="l">2563</TD><TD>    boolean isContinuationsTopCall;</TD></TR><TR><TD CLASS="l">2564</TD><TD>    NativeCall currentActivationCall;</TD></TR><TR><TD CLASS="l">2565</TD><TD>    XMLLib cachedXMLLib;</TD></TR><TR><TD CLASS="l">2566</TD><TD> </TD></TR><TR><TD CLASS="l">2567</TD><TD>    // for Objects, Arrays to tag themselves as being printed out,</TD></TR><TR><TD CLASS="l">2568</TD><TD>    // so they don't print themselves out recursively.</TD></TR><TR><TD CLASS="l">2569</TD><TD>    // Use ObjToIntMap instead of java.util.HashSet for JDK 1.1 compatibility</TD></TR><TR><TD CLASS="l">2570</TD><TD>    ObjToIntMap iterating;</TD></TR><TR><TD CLASS="l">2571</TD><TD> </TD></TR><TR><TD CLASS="l">2572</TD><TD>    Object interpreterSecurityDomain;</TD></TR><TR><TD CLASS="l">2573</TD><TD> </TD></TR><TR><TD CLASS="l">2574</TD><TD>    int version;</TD></TR><TR><TD CLASS="l">2575</TD><TD> </TD></TR><TR><TD CLASS="l">2576</TD><TD>    private SecurityController securityController;</TD></TR><TR><TD CLASS="l">2577</TD><TD>    private boolean hasClassShutter;</TD></TR><TR><TD CLASS="l">2578</TD><TD>    private ClassShutter classShutter;</TD></TR><TR><TD CLASS="l">2579</TD><TD>    private ErrorReporter errorReporter;</TD></TR><TR><TD CLASS="l">2580</TD><TD>    RegExpProxy regExpProxy;</TD></TR><TR><TD CLASS="l">2581</TD><TD>    private Locale locale;</TD></TR><TR><TD CLASS="l">2582</TD><TD>    private boolean generatingDebug;</TD></TR><TR><TD CLASS="l">2583</TD><TD>    private boolean generatingDebugChanged;</TD></TR><TR CLASS="c"><TD CLASS="l">2584</TD><TD>    private boolean generatingSource=true;</TD></TR><TR><TD CLASS="l">2585</TD><TD>    boolean useDynamicScope;</TD></TR><TR><TD CLASS="l">2586</TD><TD>    private int optimizationLevel;</TD></TR><TR><TD CLASS="l">2587</TD><TD>    private int maximumInterpreterStackDepth;</TD></TR><TR><TD CLASS="l">2588</TD><TD>    private WrapFactory wrapFactory;</TD></TR><TR><TD CLASS="l">2589</TD><TD>    Debugger debugger;</TD></TR><TR><TD CLASS="l">2590</TD><TD>    private Object debuggerData;</TD></TR><TR><TD CLASS="l">2591</TD><TD>    private int enterCount;</TD></TR><TR><TD CLASS="l">2592</TD><TD>    private Object propertyListeners;</TD></TR><TR><TD CLASS="l">2593</TD><TD>    private Map&lt;Object,Object&gt; threadLocalMap;</TD></TR><TR><TD CLASS="l">2594</TD><TD>    private ClassLoader applicationClassLoader;</TD></TR><TR><TD CLASS="l">2595</TD><TD> </TD></TR><TR><TD CLASS="l">2596</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2597</TD><TD>     * This is the list of names of objects forcing the creation of</TD></TR><TR><TD CLASS="l">2598</TD><TD>     * function activation records.</TD></TR><TR><TD CLASS="l">2599</TD><TD>     */</TD></TR><TR><TD CLASS="l">2600</TD><TD>    Set&lt;String&gt; activationNames;</TD></TR><TR><TD CLASS="l">2601</TD><TD> </TD></TR><TR><TD CLASS="l">2602</TD><TD>    // For the interpreter to store the last frame for error reports etc.</TD></TR><TR><TD CLASS="l">2603</TD><TD>    Object lastInterpreterFrame;</TD></TR><TR><TD CLASS="l">2604</TD><TD> </TD></TR><TR><TD CLASS="l">2605</TD><TD>    // For the interpreter to store information about previous invocations</TD></TR><TR><TD CLASS="l">2606</TD><TD>    // interpreter invocations</TD></TR><TR><TD CLASS="l">2607</TD><TD>    ObjArray previousInterpreterInvocations;</TD></TR><TR><TD CLASS="l">2608</TD><TD> </TD></TR><TR><TD CLASS="l">2609</TD><TD>    // For instruction counting (interpreter only)</TD></TR><TR><TD CLASS="l">2610</TD><TD>    int instructionCount;</TD></TR><TR><TD CLASS="l">2611</TD><TD>    int instructionThreshold;</TD></TR><TR><TD CLASS="l">2612</TD><TD> </TD></TR><TR><TD CLASS="l">2613</TD><TD>    // It can be used to return the second index-like result from function</TD></TR><TR><TD CLASS="l">2614</TD><TD>    int scratchIndex;</TD></TR><TR><TD CLASS="l">2615</TD><TD> </TD></TR><TR><TD CLASS="l">2616</TD><TD>    // It can be used to return the second uint32 result from function</TD></TR><TR><TD CLASS="l">2617</TD><TD>    long scratchUint32;</TD></TR><TR><TD CLASS="l">2618</TD><TD> </TD></TR><TR><TD CLASS="l">2619</TD><TD>    // It can be used to return the second Scriptable result from function</TD></TR><TR><TD CLASS="l">2620</TD><TD>    Scriptable scratchScriptable;</TD></TR><TR><TD CLASS="l">2621</TD><TD> </TD></TR><TR><TD CLASS="l">2622</TD><TD>    // Generate an observer count on compiled code</TD></TR><TR CLASS="c"><TD CLASS="l">2623</TD><TD>    public boolean generateObserverCount = false;</TD></TR><TR><TD CLASS="l">2624</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="f.html">org.mozilla.javascript</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>